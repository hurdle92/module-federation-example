"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/_app";
exports.ids = ["pages/_app"];
exports.modules = {

/***/ "./node_modules/.federation/entry.a08328371f641a576d7cc8435cf027b0.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.federation/entry.a08328371f641a576d7cc8435cf027b0.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Users_sihyungpark_Documents_GitHub_module_federation_example_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js */ \"../../node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js\");\n/* harmony import */ var _Users_sihyungpark_Documents_GitHub_module_federation_example_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_sihyungpark_Documents_GitHub_module_federation_example_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Users_sihyungpark_Documents_GitHub_module_federation_example_node_modules_module_federation_nextjs_mf_dist_src_plugins_container_runtimePlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js */ \"../../node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js\");\n\n\n\nvar prevFederation = __webpack_require__.federation;\n__webpack_require__.federation = {}\nfor(var key in (_Users_sihyungpark_Documents_GitHub_module_federation_example_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0___default())){\n\t__webpack_require__.federation[key] = (_Users_sihyungpark_Documents_GitHub_module_federation_example_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0___default())[key];\n}\nfor(var key in prevFederation){\n\t__webpack_require__.federation[key] = prevFederation[key];\n}\nif(!__webpack_require__.federation.instance){\n\tconst pluginsToAdd = [\n\t\t_Users_sihyungpark_Documents_GitHub_module_federation_example_node_modules_module_federation_nextjs_mf_dist_src_plugins_container_runtimePlugin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ? (0,_Users_sihyungpark_Documents_GitHub_module_federation_example_node_modules_module_federation_nextjs_mf_dist_src_plugins_container_runtimePlugin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])() : false,\n\t].filter(Boolean);\n\t__webpack_require__.federation.initOptions.plugins = __webpack_require__.federation.initOptions.plugins ? \n\t__webpack_require__.federation.initOptions.plugins.concat(pluginsToAdd) : pluginsToAdd;\n\t__webpack_require__.federation.instance = __webpack_require__.federation.runtime.init(__webpack_require__.federation.initOptions);\n\tif(__webpack_require__.federation.attachShareScopeMap){\n\t\t__webpack_require__.federation.attachShareScopeMap(__webpack_require__)\n\t}\n\tif(__webpack_require__.federation.installInitialConsumes){\n\t\t__webpack_require__.federation.installInitialConsumes()\n\t}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLmZlZGVyYXRpb24vZW50cnkuYTA4MzI4MzcxZjY0MWE1NzZkN2NjODQzNWNmMDI3YjAuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFpSztBQUNVOztBQUUzSyxxQkFBcUIsbUJBQW1CO0FBQ3hDLG1CQUFtQjtBQUNuQixlQUFlLCtLQUFVO0FBQ3pCLENBQUMsbUJBQW1CLG1CQUFtQiwrS0FBVTtBQUNqRDtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7QUFDcEI7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBLEVBQUUsMExBQVEsR0FBRyw4TEFBUTtBQUNyQjtBQUNBLENBQUMsbUJBQW1CLGtDQUFrQyxtQkFBbUI7QUFDekUsQ0FBQyxtQkFBbUI7QUFDcEIsQ0FBQyxtQkFBbUIsdUJBQXVCLG1CQUFtQix5QkFBeUIsbUJBQW1CO0FBQzFHLElBQUksbUJBQW1CO0FBQ3ZCLEVBQUUsbUJBQW1CLGdDQUFnQyxtQkFBbUI7QUFDeEU7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QixFQUFFLG1CQUFtQjtBQUNyQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9kdWxlQXBwQi8uL25vZGVfbW9kdWxlcy8uZmVkZXJhdGlvbi9lbnRyeS5hMDgzMjgzNzFmNjQxYTU3NmQ3Y2M4NDM1Y2YwMjdiMC5qcz81ZDc1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmZWRlcmF0aW9uIGZyb20gJy9Vc2Vycy9zaWh5dW5ncGFyay9Eb2N1bWVudHMvR2l0SHViL21vZHVsZS1mZWRlcmF0aW9uLWV4YW1wbGUvbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi93ZWJwYWNrLWJ1bmRsZXItcnVudGltZS9kaXN0L2luZGV4LmNqcy5qcyc7XG5pbXBvcnQgcGx1Z2luXzAgZnJvbSAnL1VzZXJzL3NpaHl1bmdwYXJrL0RvY3VtZW50cy9HaXRIdWIvbW9kdWxlLWZlZGVyYXRpb24tZXhhbXBsZS9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL25leHRqcy1tZi9kaXN0L3NyYy9wbHVnaW5zL2NvbnRhaW5lci9ydW50aW1lUGx1Z2luLmpzJztcblxudmFyIHByZXZGZWRlcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uID0ge31cbmZvcih2YXIga2V5IGluIGZlZGVyYXRpb24pe1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb25ba2V5XSA9IGZlZGVyYXRpb25ba2V5XTtcbn1cbmZvcih2YXIga2V5IGluIHByZXZGZWRlcmF0aW9uKXtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uW2tleV0gPSBwcmV2RmVkZXJhdGlvbltrZXldO1xufVxuaWYoIV9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5pbnN0YW5jZSl7XG5cdGNvbnN0IHBsdWdpbnNUb0FkZCA9IFtcblx0XHRwbHVnaW5fMCA/IHBsdWdpbl8wKCkgOiBmYWxzZSxcblx0XS5maWx0ZXIoQm9vbGVhbik7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5pbml0T3B0aW9ucy5wbHVnaW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluaXRPcHRpb25zLnBsdWdpbnMgPyBcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluaXRPcHRpb25zLnBsdWdpbnMuY29uY2F0KHBsdWdpbnNUb0FkZCkgOiBwbHVnaW5zVG9BZGQ7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5pbnN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5ydW50aW1lLmluaXQoX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluaXRPcHRpb25zKTtcblx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmF0dGFjaFNoYXJlU2NvcGVNYXApe1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5hdHRhY2hTaGFyZVNjb3BlTWFwKF9fd2VicGFja19yZXF1aXJlX18pXG5cdH1cblx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluc3RhbGxJbml0aWFsQ29uc3VtZXMpe1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5pbnN0YWxsSW5pdGlhbENvbnN1bWVzKClcblx0fVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.federation/entry.a08328371f641a576d7cc8435cf027b0.js\n");

/***/ }),

/***/ "../../node_modules/@module-federation/runtime/dist/index.esm.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@module-federation/runtime/dist/index.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FederationHost: () => (/* binding */ FederationHost),\n/* harmony export */   getRemoteEntry: () => (/* binding */ getRemoteEntry),\n/* harmony export */   getRemoteInfo: () => (/* binding */ getRemoteInfo),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   loadRemote: () => (/* binding */ loadRemote),\n/* harmony export */   loadScript: () => (/* reexport safe */ _module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScript),\n/* harmony export */   loadScriptNode: () => (/* reexport safe */ _module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScriptNode),\n/* harmony export */   loadShare: () => (/* binding */ loadShare),\n/* harmony export */   loadShareSync: () => (/* binding */ loadShareSync),\n/* harmony export */   preloadRemote: () => (/* binding */ preloadRemote),\n/* harmony export */   registerGlobalPlugins: () => (/* reexport safe */ _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   registerPlugins: () => (/* binding */ registerPlugins),\n/* harmony export */   registerRemotes: () => (/* binding */ registerRemotes)\n/* harmony export */ });\n/* harmony import */ var _share_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./share.esm.js */ \"../../node_modules/@module-federation/runtime/dist/share.esm.js\");\n/* harmony import */ var _module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @module-federation/sdk */ \"../../node_modules/@module-federation/sdk/dist/index.esm.js\");\n\n\n\n\n\n// Function to match a remote with its name and expose\n// id: pkgName(@federation/app1) + expose(button) = @federation/app1/button\n// id: alias(app1) + expose(button) = app1/button\n// id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort\nfunction matchRemoteWithNameAndExpose(remotes, id) {\n    for (const remote of remotes){\n        // match pkgName\n        const isNameMatched = id.startsWith(remote.name);\n        let expose = id.replace(remote.name, '');\n        if (isNameMatched) {\n            if (expose.startsWith('/')) {\n                const pkgNameOrAlias = remote.name;\n                expose = `.${expose}`;\n                return {\n                    pkgNameOrAlias,\n                    expose,\n                    remote\n                };\n            } else if (expose === '') {\n                return {\n                    pkgNameOrAlias: remote.name,\n                    expose: '.',\n                    remote\n                };\n            }\n        }\n        // match alias\n        const isAliasMatched = remote.alias && id.startsWith(remote.alias);\n        let exposeWithAlias = remote.alias && id.replace(remote.alias, '');\n        if (remote.alias && isAliasMatched) {\n            if (exposeWithAlias && exposeWithAlias.startsWith('/')) {\n                const pkgNameOrAlias = remote.alias;\n                exposeWithAlias = `.${exposeWithAlias}`;\n                return {\n                    pkgNameOrAlias,\n                    expose: exposeWithAlias,\n                    remote\n                };\n            } else if (exposeWithAlias === '') {\n                return {\n                    pkgNameOrAlias: remote.alias,\n                    expose: '.',\n                    remote\n                };\n            }\n        }\n    }\n    return;\n}\n// Function to match a remote with its name or alias\nfunction matchRemote(remotes, nameOrAlias) {\n    for (const remote of remotes){\n        const isNameMatched = nameOrAlias === remote.name;\n        if (isNameMatched) {\n            return remote;\n        }\n        const isAliasMatched = remote.alias && nameOrAlias === remote.alias;\n        if (isAliasMatched) {\n            return remote;\n        }\n    }\n    return;\n}\n\nfunction registerPlugins$1(plugins, hookInstances) {\n    const globalPlugins = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.g)();\n    // Incorporate global plugins\n    if (globalPlugins.length > 0) {\n        globalPlugins.forEach((plugin)=>{\n            if (plugins == null ? void 0 : plugins.find((item)=>item.name !== plugin.name)) {\n                plugins.push(plugin);\n            }\n        });\n    }\n    if (plugins && plugins.length > 0) {\n        plugins.forEach((plugin)=>{\n            hookInstances.forEach((hookInstance)=>{\n                hookInstance.applyPlugin(plugin);\n            });\n        });\n    }\n    return plugins;\n}\n\nfunction _extends$7() {\n    _extends$7 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$7.apply(this, arguments);\n}\nasync function loadEsmEntry({ entry, remoteEntryExports }) {\n    return new Promise((resolve, reject)=>{\n        try {\n            if (!remoteEntryExports) {\n                // eslint-disable-next-line no-eval\n                new Function('callbacks', `import(\"${entry}\").then(callbacks[0]).catch(callbacks[1])`)([\n                    resolve,\n                    reject\n                ]);\n            } else {\n                resolve(remoteEntryExports);\n            }\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\nasync function loadEntryScript({ name, globalName, entry, createScriptHook }) {\n    const { entryExports: remoteEntryExports } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(name, globalName);\n    if (remoteEntryExports) {\n        return remoteEntryExports;\n    }\n    if (typeof document === 'undefined') {\n        return (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScriptNode)(entry, {\n            attrs: {\n                name,\n                globalName\n            },\n            createScriptHook\n        }).then(()=>{\n            const { remoteEntryKey, entryExports } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(name, globalName);\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(entryExports, `\n        Unable to use the ${name}'s '${entry}' URL with ${remoteEntryKey}'s globalName to get remoteEntry exports.\n        Possible reasons could be:\\n\n        1. '${entry}' is not the correct URL, or the remoteEntry resource or name is incorrect.\\n\n        2. ${remoteEntryKey} cannot be used to get remoteEntry exports in the window object.\n      `);\n            return entryExports;\n        }).catch((e)=>{\n            return e;\n        });\n    }\n    return (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScript)(entry, {\n        attrs: {},\n        createScriptHook\n    }).then(()=>{\n        const { remoteEntryKey, entryExports } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(name, globalName);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(entryExports, `\n      Unable to use the ${name}'s '${entry}' URL with ${remoteEntryKey}'s globalName to get remoteEntry exports.\n      Possible reasons could be:\\n\n      1. '${entry}' is not the correct URL, or the remoteEntry resource or name is incorrect.\\n\n      2. ${remoteEntryKey} cannot be used to get remoteEntry exports in the window object.\n    `);\n        return entryExports;\n    }).catch((e)=>{\n        return e;\n    });\n}\nfunction getRemoteEntryUniqueKey(remoteInfo) {\n    const { entry, name } = remoteInfo;\n    return (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.composeKeyWithSeparator)(name, entry);\n}\nasync function getRemoteEntry({ remoteEntryExports, remoteInfo, createScriptHook }) {\n    const { entry, name, type, entryGlobalName } = remoteInfo;\n    const uniqueKey = getRemoteEntryUniqueKey(remoteInfo);\n    if (remoteEntryExports) {\n        return remoteEntryExports;\n    }\n    if (!_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[uniqueKey]) {\n        if (type === 'esm') {\n            _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[uniqueKey] = loadEsmEntry({\n                entry,\n                remoteEntryExports\n            });\n        } else {\n            _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[uniqueKey] = loadEntryScript({\n                name,\n                globalName: entryGlobalName,\n                entry,\n                createScriptHook\n            });\n        }\n    }\n    return _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[uniqueKey];\n}\nfunction getRemoteInfo(remote) {\n    return _extends$7({}, remote, {\n        entry: 'entry' in remote ? remote.entry : '',\n        type: remote.type || _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.D,\n        entryGlobalName: remote.entryGlobalName || remote.name,\n        shareScope: remote.shareScope || _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.b\n    });\n}\n\nfunction _extends$6() {\n    _extends$6 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$6.apply(this, arguments);\n}\nlet Module = class Module {\n    async getEntry() {\n        if (this.remoteEntryExports) {\n            return this.remoteEntryExports;\n        }\n        // Get remoteEntry.js\n        const remoteEntryExports = await getRemoteEntry({\n            remoteInfo: this.remoteInfo,\n            remoteEntryExports: this.remoteEntryExports,\n            createScriptHook: (url)=>{\n                const res = this.host.loaderHook.lifecycle.createScript.emit({\n                    url\n                });\n                if (!res) return;\n                if (typeof document === 'undefined') {\n                    //todo: needs real fix\n                    return res;\n                }\n                if (res instanceof HTMLScriptElement) {\n                    return res;\n                }\n                if ('script' in res || 'timeout' in res) {\n                    return res;\n                }\n                return;\n            }\n        });\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(remoteEntryExports, `remoteEntryExports is undefined \\n ${(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.s)(this.remoteInfo)}`);\n        this.remoteEntryExports = remoteEntryExports;\n        return this.remoteEntryExports;\n    }\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    async get(expose, options) {\n        const { loadFactory = true } = options || {\n            loadFactory: true\n        };\n        // Get remoteEntry.js\n        const remoteEntryExports = await this.getEntry();\n        if (!this.inited) {\n            const localShareScopeMap = this.host.shareScopeMap;\n            const remoteShareScope = this.remoteInfo.shareScope || 'default';\n            if (!localShareScopeMap[remoteShareScope]) {\n                localShareScopeMap[remoteShareScope] = {};\n            }\n            const shareScope = localShareScopeMap[remoteShareScope];\n            const initScope = [];\n            const remoteEntryInitOptions = {\n                version: this.remoteInfo.version || ''\n            };\n            // Help to find host instance\n            Object.defineProperty(remoteEntryInitOptions, 'hostId', {\n                value: this.host.options.id || this.host.name,\n                // remoteEntryInitOptions will be traversed and assigned during container init, ,so this attribute is not allowed to be traversed\n                enumerable: false\n            });\n            const initContainerOptions = await this.host.hooks.lifecycle.beforeInitContainer.emit({\n                shareScope,\n                // @ts-ignore hostId will be set by Object.defineProperty\n                remoteEntryInitOptions,\n                initScope,\n                remoteInfo: this.remoteInfo,\n                origin: this.host\n            });\n            await remoteEntryExports.init(initContainerOptions.shareScope, initContainerOptions.initScope, initContainerOptions.remoteEntryInitOptions);\n            await this.host.hooks.lifecycle.initContainer.emit(_extends$6({}, initContainerOptions, {\n                remoteEntryExports\n            }));\n        }\n        this.lib = remoteEntryExports;\n        this.inited = true;\n        // get exposeGetter\n        const moduleFactory = await remoteEntryExports.get(expose);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(moduleFactory, `${(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(this.remoteInfo)} remote don't export ${expose}.`);\n        if (!loadFactory) {\n            return moduleFactory;\n        }\n        const exposeContent = await moduleFactory();\n        return exposeContent;\n    }\n    constructor({ remoteInfo, host }){\n        this.inited = false;\n        this.lib = undefined;\n        this.remoteInfo = remoteInfo;\n        this.host = host;\n    }\n};\n\nclass SyncHook {\n    on(fn) {\n        if (typeof fn === 'function') {\n            this.listeners.add(fn);\n        }\n    }\n    once(fn) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        this.on(function wrapper(...args) {\n            self.remove(wrapper);\n            // eslint-disable-next-line prefer-spread\n            return fn.apply(null, args);\n        });\n    }\n    emit(...data) {\n        let result;\n        if (this.listeners.size > 0) {\n            // eslint-disable-next-line prefer-spread\n            this.listeners.forEach((fn)=>{\n                result = fn(...data);\n            });\n        }\n        return result;\n    }\n    remove(fn) {\n        this.listeners.delete(fn);\n    }\n    removeAll() {\n        this.listeners.clear();\n    }\n    constructor(type){\n        this.type = '';\n        this.listeners = new Set();\n        if (type) {\n            this.type = type;\n        }\n    }\n}\n\nclass AsyncHook extends SyncHook {\n    emit(...data) {\n        let result;\n        const ls = Array.from(this.listeners);\n        if (ls.length > 0) {\n            let i = 0;\n            const call = (prev)=>{\n                if (prev === false) {\n                    return false; // Abort process\n                } else if (i < ls.length) {\n                    return Promise.resolve(ls[i++].apply(null, data)).then(call);\n                } else {\n                    return prev;\n                }\n            };\n            result = call();\n        }\n        return Promise.resolve(result);\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction checkReturnData(originalData, returnedData) {\n    if (!(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(returnedData)) {\n        return false;\n    }\n    if (originalData !== returnedData) {\n        // eslint-disable-next-line no-restricted-syntax\n        for(const key in originalData){\n            if (!(key in returnedData)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nclass SyncWaterfallHook extends SyncHook {\n    emit(data) {\n        if (!(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`The data for the \"${this.type}\" hook should be an object.`);\n        }\n        for (const fn of this.listeners){\n            try {\n                const tempData = fn(data);\n                if (checkReturnData(data, tempData)) {\n                    data = tempData;\n                } else {\n                    this.onerror(`A plugin returned an unacceptable value for the \"${this.type}\" type.`);\n                    break;\n                }\n            } catch (e) {\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)(e);\n                this.onerror(e);\n            }\n        }\n        return data;\n    }\n    constructor(type){\n        super();\n        this.onerror = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f;\n        this.type = type;\n    }\n}\n\nclass AsyncWaterfallHook extends SyncHook {\n    emit(data) {\n        if (!(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`The response data for the \"${this.type}\" hook must be an object.`);\n        }\n        const ls = Array.from(this.listeners);\n        if (ls.length > 0) {\n            let i = 0;\n            const processError = (e)=>{\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)(e);\n                this.onerror(e);\n                return data;\n            };\n            const call = (prevData)=>{\n                if (checkReturnData(data, prevData)) {\n                    data = prevData;\n                    if (i < ls.length) {\n                        try {\n                            return Promise.resolve(ls[i++](data)).then(call, processError);\n                        } catch (e) {\n                            return processError(e);\n                        }\n                    }\n                } else {\n                    this.onerror(`A plugin returned an incorrect value for the \"${this.type}\" type.`);\n                }\n                return data;\n            };\n            return Promise.resolve(call(data));\n        }\n        return Promise.resolve(data);\n    }\n    constructor(type){\n        super();\n        this.onerror = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f;\n        this.type = type;\n    }\n}\n\nclass PluginSystem {\n    applyPlugin(plugin) {\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)((0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.h)(plugin), 'Plugin configuration is invalid.');\n        // The plugin's name is mandatory and must be unique\n        const pluginName = plugin.name;\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(pluginName, 'A name must be provided by the plugin.');\n        if (!this.registerPlugins[pluginName]) {\n            this.registerPlugins[pluginName] = plugin;\n            Object.keys(this.lifecycle).forEach((key)=>{\n                const pluginLife = plugin[key];\n                if (pluginLife) {\n                    this.lifecycle[key].on(pluginLife);\n                }\n            });\n        }\n    }\n    removePlugin(pluginName) {\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(pluginName, 'A name is required.');\n        const plugin = this.registerPlugins[pluginName];\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(plugin, `The plugin \"${pluginName}\" is not registered.`);\n        Object.keys(plugin).forEach((key)=>{\n            if (key !== 'name') {\n                this.lifecycle[key].remove(plugin[key]);\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    inherit({ lifecycle, registerPlugins }) {\n        Object.keys(lifecycle).forEach((hookName)=>{\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(!this.lifecycle[hookName], `The hook \"${hookName}\" has a conflict and cannot be inherited.`);\n            this.lifecycle[hookName] = lifecycle[hookName];\n        });\n        Object.keys(registerPlugins).forEach((pluginName)=>{\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(!this.registerPlugins[pluginName], `The plugin \"${pluginName}\" has a conflict and cannot be inherited.`);\n            this.applyPlugin(registerPlugins[pluginName]);\n        });\n    }\n    constructor(lifecycle){\n        this.registerPlugins = {};\n        this.lifecycle = lifecycle;\n        this.lifecycleKeys = Object.keys(lifecycle);\n    }\n}\n\nfunction _extends$5() {\n    _extends$5 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$5.apply(this, arguments);\n}\nfunction defaultPreloadArgs(preloadConfig) {\n    return _extends$5({\n        resourceCategory: 'sync',\n        share: true,\n        depsRemote: true,\n        prefetchInterface: false\n    }, preloadConfig);\n}\nfunction formatPreloadArgs(remotes, preloadArgs) {\n    return preloadArgs.map((args)=>{\n        const remoteInfo = matchRemote(remotes, args.nameOrAlias);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(remoteInfo, `Unable to preload ${args.nameOrAlias} as it is not included in ${!remoteInfo && (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.s)({\n            remoteInfo,\n            remotes\n        })}`);\n        return {\n            remote: remoteInfo,\n            preloadConfig: defaultPreloadArgs(args)\n        };\n    });\n}\nfunction normalizePreloadExposes(exposes) {\n    if (!exposes) {\n        return [];\n    }\n    return exposes.map((expose)=>{\n        if (expose === '.') {\n            return expose;\n        }\n        if (expose.startsWith('./')) {\n            return expose.replace('./', '');\n        }\n        return expose;\n    });\n}\nfunction preloadAssets(remoteInfo, host, assets) {\n    const { cssAssets, jsAssetsWithoutEntry, entryAssets } = assets;\n    if (host.options.inBrowser) {\n        entryAssets.forEach((asset)=>{\n            const { moduleInfo } = asset;\n            const module = host.moduleCache.get(remoteInfo.name);\n            if (module) {\n                getRemoteEntry({\n                    remoteInfo: moduleInfo,\n                    remoteEntryExports: module.remoteEntryExports,\n                    createScriptHook: (url)=>{\n                        const res = host.loaderHook.lifecycle.createScript.emit({\n                            url\n                        });\n                        if (!res) return;\n                        if (typeof document === 'undefined') {\n                            //todo: needs real fix\n                            return res;\n                        }\n                        if (res instanceof HTMLScriptElement) {\n                            return res;\n                        }\n                        if ('script' in res || 'timeout' in res) {\n                            return res;\n                        }\n                        return;\n                    }\n                });\n            } else {\n                getRemoteEntry({\n                    remoteInfo: moduleInfo,\n                    remoteEntryExports: undefined,\n                    createScriptHook: (url)=>{\n                        const res = host.loaderHook.lifecycle.createScript.emit({\n                            url\n                        });\n                        if (!res) return;\n                        if (typeof document === 'undefined') {\n                            //todo: needs real fix\n                            return res;\n                        }\n                        if (res instanceof HTMLScriptElement) {\n                            return res;\n                        }\n                        if ('script' in res || 'timeout' in res) {\n                            return res;\n                        }\n                        return;\n                    }\n                });\n            }\n        });\n        const fragment = document.createDocumentFragment();\n        cssAssets.forEach((cssUrl)=>{\n            const { link: cssEl, needAttach } = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.createLink)(cssUrl, ()=>{}, {\n                rel: 'preload',\n                as: 'style'\n            }, (url)=>{\n                const res = host.loaderHook.lifecycle.createLink.emit({\n                    url\n                });\n                if (res instanceof HTMLLinkElement) {\n                    return res;\n                }\n                return;\n            });\n            needAttach && fragment.appendChild(cssEl);\n        });\n        jsAssetsWithoutEntry.forEach((jsUrl)=>{\n            const { link: linkEl, needAttach } = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.createLink)(jsUrl, ()=>{\n            // noop\n            }, {\n                rel: 'preload',\n                as: 'script'\n            }, (url)=>{\n                const res = host.loaderHook.lifecycle.createLink.emit({\n                    url\n                });\n                if (res instanceof HTMLLinkElement) {\n                    return res;\n                }\n                return;\n            });\n            needAttach && document.head.appendChild(linkEl);\n        });\n        document.head.appendChild(fragment);\n    }\n}\n\nfunction _extends$4() {\n    _extends$4 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$4.apply(this, arguments);\n}\nfunction assignRemoteInfo(remoteInfo, remoteSnapshot) {\n    if (!('remoteEntry' in remoteSnapshot) || !remoteSnapshot.remoteEntry) {\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`The attribute remoteEntry of ${name} must not be undefined.`);\n    }\n    const { remoteEntry } = remoteSnapshot;\n    const entryUrl = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(remoteSnapshot, remoteEntry);\n    remoteInfo.type = remoteSnapshot.remoteEntryType;\n    remoteInfo.entryGlobalName = remoteSnapshot.globalName;\n    remoteInfo.entry = entryUrl;\n    remoteInfo.version = remoteSnapshot.version;\n    remoteInfo.buildVersion = remoteSnapshot.buildVersion;\n}\nfunction snapshotPlugin() {\n    return {\n        name: 'snapshot-plugin',\n        async afterResolve (args) {\n            const { remote, pkgNameOrAlias, expose, origin, remoteInfo } = args;\n            if (!(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.j)(remote) || !(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.k)(remote)) {\n                const { remoteSnapshot, globalSnapshot } = await origin.snapshotHandler.loadRemoteSnapshotInfo(remote);\n                assignRemoteInfo(remoteInfo, remoteSnapshot);\n                // preloading assets\n                const preloadOptions = {\n                    remote,\n                    preloadConfig: {\n                        nameOrAlias: pkgNameOrAlias,\n                        exposes: [\n                            expose\n                        ],\n                        resourceCategory: 'sync',\n                        share: false,\n                        depsRemote: false\n                    }\n                };\n                const assets = await origin.remoteHandler.hooks.lifecycle.generatePreloadAssets.emit({\n                    origin,\n                    preloadOptions,\n                    remoteInfo,\n                    remote,\n                    remoteSnapshot,\n                    globalSnapshot\n                });\n                if (assets) {\n                    preloadAssets(remoteInfo, origin, assets);\n                }\n                return _extends$4({}, args, {\n                    remoteSnapshot\n                });\n            }\n            return args;\n        }\n    };\n}\n\n// name\n// name:version\nfunction splitId(id) {\n    const splitInfo = id.split(':');\n    if (splitInfo.length === 1) {\n        return {\n            name: splitInfo[0],\n            version: undefined\n        };\n    } else if (splitInfo.length === 2) {\n        return {\n            name: splitInfo[0],\n            version: splitInfo[1]\n        };\n    } else {\n        return {\n            name: splitInfo[1],\n            version: splitInfo[2]\n        };\n    }\n}\n// Traverse all nodes in moduleInfo and traverse the entire snapshot\nfunction traverseModuleInfo(globalSnapshot, remoteInfo, traverse, isRoot, memo = {}, remoteSnapshot) {\n    const id = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(remoteInfo);\n    const { value: snapshotValue } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.l)(globalSnapshot, id);\n    const effectiveRemoteSnapshot = remoteSnapshot || snapshotValue;\n    if (effectiveRemoteSnapshot && !(0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isManifestProvider)(effectiveRemoteSnapshot)) {\n        traverse(effectiveRemoteSnapshot, remoteInfo, isRoot);\n        if (effectiveRemoteSnapshot.remotesInfo) {\n            const remoteKeys = Object.keys(effectiveRemoteSnapshot.remotesInfo);\n            for (const key of remoteKeys){\n                if (memo[key]) {\n                    continue;\n                }\n                memo[key] = true;\n                const subRemoteInfo = splitId(key);\n                const remoteValue = effectiveRemoteSnapshot.remotesInfo[key];\n                traverseModuleInfo(globalSnapshot, {\n                    name: subRemoteInfo.name,\n                    version: remoteValue.matchedVersion\n                }, traverse, false, memo, undefined);\n            }\n        }\n    }\n}\n// eslint-disable-next-line max-lines-per-function\nfunction generatePreloadAssets(origin, preloadOptions, remote, globalSnapshot, remoteSnapshot) {\n    const cssAssets = [];\n    const jsAssets = [];\n    const entryAssets = [];\n    const loadedSharedJsAssets = new Set();\n    const loadedSharedCssAssets = new Set();\n    const { options } = origin;\n    const { preloadConfig: rootPreloadConfig } = preloadOptions;\n    const { depsRemote } = rootPreloadConfig;\n    const memo = {};\n    traverseModuleInfo(globalSnapshot, remote, (moduleInfoSnapshot, remoteInfo, isRoot)=>{\n        let preloadConfig;\n        if (isRoot) {\n            preloadConfig = rootPreloadConfig;\n        } else {\n            if (Array.isArray(depsRemote)) {\n                // eslint-disable-next-line array-callback-return\n                const findPreloadConfig = depsRemote.find((remoteConfig)=>{\n                    if (remoteConfig.nameOrAlias === remoteInfo.name || remoteConfig.nameOrAlias === remoteInfo.alias) {\n                        return true;\n                    }\n                    return false;\n                });\n                if (!findPreloadConfig) {\n                    return;\n                }\n                preloadConfig = defaultPreloadArgs(findPreloadConfig);\n            } else if (depsRemote === true) {\n                preloadConfig = rootPreloadConfig;\n            } else {\n                return;\n            }\n        }\n        const remoteEntryUrl = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(moduleInfoSnapshot, 'remoteEntry' in moduleInfoSnapshot ? moduleInfoSnapshot.remoteEntry : '');\n        if (remoteEntryUrl) {\n            entryAssets.push({\n                name: remoteInfo.name,\n                moduleInfo: {\n                    name: remoteInfo.name,\n                    entry: remoteEntryUrl,\n                    type: 'remoteEntryType' in moduleInfoSnapshot ? moduleInfoSnapshot.remoteEntryType : 'global',\n                    entryGlobalName: 'globalName' in moduleInfoSnapshot ? moduleInfoSnapshot.globalName : remoteInfo.name,\n                    shareScope: '',\n                    version: 'version' in moduleInfoSnapshot ? moduleInfoSnapshot.version : undefined\n                },\n                url: remoteEntryUrl\n            });\n        }\n        let moduleAssetsInfo = 'modules' in moduleInfoSnapshot ? moduleInfoSnapshot.modules : [];\n        const normalizedPreloadExposes = normalizePreloadExposes(preloadConfig.exposes);\n        if (normalizedPreloadExposes.length && 'modules' in moduleInfoSnapshot) {\n            var _moduleInfoSnapshot_modules;\n            moduleAssetsInfo = moduleInfoSnapshot == null ? void 0 : (_moduleInfoSnapshot_modules = moduleInfoSnapshot.modules) == null ? void 0 : _moduleInfoSnapshot_modules.reduce((assets, moduleAssetInfo)=>{\n                if ((normalizedPreloadExposes == null ? void 0 : normalizedPreloadExposes.indexOf(moduleAssetInfo.moduleName)) !== -1) {\n                    assets.push(moduleAssetInfo);\n                }\n                return assets;\n            }, []);\n        }\n        function handleAssets(assets) {\n            const assetsRes = assets.map((asset)=>(0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(moduleInfoSnapshot, asset));\n            if (preloadConfig.filter) {\n                return assetsRes.filter(preloadConfig.filter);\n            }\n            return assetsRes;\n        }\n        if (moduleAssetsInfo) {\n            const assetsLength = moduleAssetsInfo.length;\n            for(let index = 0; index < assetsLength; index++){\n                const assetsInfo = moduleAssetsInfo[index];\n                const exposeFullPath = `${remoteInfo.name}/${assetsInfo.moduleName}`;\n                origin.remoteHandler.hooks.lifecycle.handlePreloadModule.emit({\n                    id: assetsInfo.moduleName === '.' ? remoteInfo.name : exposeFullPath,\n                    name: remoteInfo.name,\n                    remoteSnapshot: moduleInfoSnapshot,\n                    preloadConfig,\n                    remote: remoteInfo,\n                    origin\n                });\n                const preloaded = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.m)(exposeFullPath);\n                if (preloaded) {\n                    continue;\n                }\n                if (preloadConfig.resourceCategory === 'all') {\n                    cssAssets.push(...handleAssets(assetsInfo.assets.css.async));\n                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));\n                    jsAssets.push(...handleAssets(assetsInfo.assets.js.async));\n                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));\n                // eslint-disable-next-line no-constant-condition\n                } else if (preloadConfig.resourceCategory = 'sync') {\n                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));\n                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));\n                }\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.n)(exposeFullPath);\n            }\n        }\n    }, true, memo, remoteSnapshot);\n    if (remoteSnapshot.shared) {\n        const collectSharedAssets = (shareInfo, snapshotShared)=>{\n            const registeredShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.o)(origin.shareScopeMap, snapshotShared.sharedName, shareInfo, origin.sharedHandler.hooks.lifecycle.resolveShare);\n            // If the global share does not exist, or the lib function does not exist, it means that the shared has not been loaded yet and can be preloaded.\n            if (registeredShared && typeof registeredShared.lib === 'function') {\n                snapshotShared.assets.js.sync.forEach((asset)=>{\n                    loadedSharedJsAssets.add(asset);\n                });\n                snapshotShared.assets.css.sync.forEach((asset)=>{\n                    loadedSharedCssAssets.add(asset);\n                });\n            }\n        };\n        remoteSnapshot.shared.forEach((shared)=>{\n            var _options_shared;\n            const shareInfos = (_options_shared = options.shared) == null ? void 0 : _options_shared[shared.sharedName];\n            if (!shareInfos) {\n                return;\n            }\n            // if no version, preload all shared\n            const sharedOptions = shared.version ? shareInfos.find((s)=>s.version === shared.version) : shareInfos;\n            if (!sharedOptions) {\n                return;\n            }\n            const arrayShareInfo = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.p)(sharedOptions);\n            arrayShareInfo.forEach((s)=>{\n                collectSharedAssets(s, shared);\n            });\n        });\n    }\n    const needPreloadJsAssets = jsAssets.filter((asset)=>!loadedSharedJsAssets.has(asset));\n    const needPreloadCssAssets = cssAssets.filter((asset)=>!loadedSharedCssAssets.has(asset));\n    return {\n        cssAssets: needPreloadCssAssets,\n        jsAssetsWithoutEntry: needPreloadJsAssets,\n        entryAssets\n    };\n}\nconst generatePreloadAssetsPlugin = function() {\n    return {\n        name: 'generate-preload-assets-plugin',\n        async generatePreloadAssets (args) {\n            const { origin, preloadOptions, remoteInfo, remote, globalSnapshot, remoteSnapshot } = args;\n            if ((0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.j)(remote) && (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.k)(remote)) {\n                return {\n                    cssAssets: [],\n                    jsAssetsWithoutEntry: [],\n                    entryAssets: [\n                        {\n                            name: remote.name,\n                            url: remote.entry,\n                            moduleInfo: {\n                                name: remoteInfo.name,\n                                entry: remote.entry,\n                                type: 'global',\n                                entryGlobalName: '',\n                                shareScope: ''\n                            }\n                        }\n                    ]\n                };\n            }\n            assignRemoteInfo(remoteInfo, remoteSnapshot);\n            const assets = generatePreloadAssets(origin, preloadOptions, remoteInfo, globalSnapshot, remoteSnapshot);\n            return assets;\n        }\n    };\n};\n\nfunction _extends$3() {\n    _extends$3 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$3.apply(this, arguments);\n}\nclass SnapshotHandler {\n    async loadSnapshot(moduleInfo) {\n        const { options } = this.HostInstance;\n        const { hostGlobalSnapshot, remoteSnapshot, globalSnapshot } = this.getGlobalRemoteInfo(moduleInfo);\n        const { remoteSnapshot: globalRemoteSnapshot, globalSnapshot: globalSnapshotRes } = await this.hooks.lifecycle.loadSnapshot.emit({\n            options,\n            moduleInfo,\n            hostGlobalSnapshot,\n            remoteSnapshot,\n            globalSnapshot\n        });\n        return {\n            remoteSnapshot: globalRemoteSnapshot,\n            globalSnapshot: globalSnapshotRes\n        };\n    }\n    // eslint-disable-next-line max-lines-per-function\n    async loadRemoteSnapshotInfo(moduleInfo) {\n        const { options } = this.HostInstance;\n        await this.hooks.lifecycle.beforeLoadRemoteSnapshot.emit({\n            options,\n            moduleInfo\n        });\n        let hostSnapshot = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)({\n            name: this.HostInstance.options.name,\n            version: this.HostInstance.options.version\n        });\n        if (!hostSnapshot) {\n            hostSnapshot = {\n                version: this.HostInstance.options.version || '',\n                remoteEntry: '',\n                remotesInfo: {}\n            };\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.r)({\n                [this.HostInstance.options.name]: hostSnapshot\n            });\n        }\n        // In dynamic loadRemote scenarios, incomplete remotesInfo delivery may occur. In such cases, the remotesInfo in the host needs to be completed in the snapshot at runtime.\n        // This ensures the snapshot's integrity and helps the chrome plugin correctly identify all producer modules, ensuring that proxyable producer modules will not be missing.\n        if (hostSnapshot && 'remotesInfo' in hostSnapshot && !(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.l)(hostSnapshot.remotesInfo, moduleInfo.name).value) {\n            if ('version' in moduleInfo || 'entry' in moduleInfo) {\n                hostSnapshot.remotesInfo = _extends$3({}, hostSnapshot == null ? void 0 : hostSnapshot.remotesInfo, {\n                    [moduleInfo.name]: {\n                        matchedVersion: 'version' in moduleInfo ? moduleInfo.version : moduleInfo.entry\n                    }\n                });\n            }\n        }\n        const { hostGlobalSnapshot, remoteSnapshot, globalSnapshot } = this.getGlobalRemoteInfo(moduleInfo);\n        const { remoteSnapshot: globalRemoteSnapshot, globalSnapshot: globalSnapshotRes } = await this.hooks.lifecycle.loadSnapshot.emit({\n            options,\n            moduleInfo,\n            hostGlobalSnapshot,\n            remoteSnapshot,\n            globalSnapshot\n        });\n        // global snapshot includes manifest or module info includes manifest\n        if (globalRemoteSnapshot) {\n            if ((0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isManifestProvider)(globalRemoteSnapshot)) {\n                const moduleSnapshot = await this.getManifestJson(globalRemoteSnapshot.remoteEntry, moduleInfo, {});\n                // eslint-disable-next-line @typescript-eslint/no-shadow\n                const globalSnapshotRes = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(_extends$3({}, moduleInfo, {\n                    // The global remote may be overridden\n                    // Therefore, set the snapshot key to the global address of the actual request\n                    entry: globalRemoteSnapshot.remoteEntry\n                }), moduleSnapshot);\n                return {\n                    remoteSnapshot: moduleSnapshot,\n                    globalSnapshot: globalSnapshotRes\n                };\n            } else {\n                const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n                    options: this.HostInstance.options,\n                    moduleInfo,\n                    remoteSnapshot: globalRemoteSnapshot,\n                    from: 'global'\n                });\n                return {\n                    remoteSnapshot: remoteSnapshotRes,\n                    globalSnapshot: globalSnapshotRes\n                };\n            }\n        } else {\n            if ((0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.j)(moduleInfo)) {\n                // get from manifest.json and merge remote info from remote server\n                const moduleSnapshot = await this.getManifestJson(moduleInfo.entry, moduleInfo, {});\n                // eslint-disable-next-line @typescript-eslint/no-shadow\n                const globalSnapshotRes = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(moduleInfo, moduleSnapshot);\n                const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n                    options: this.HostInstance.options,\n                    moduleInfo,\n                    remoteSnapshot: moduleSnapshot,\n                    from: 'global'\n                });\n                return {\n                    remoteSnapshot: remoteSnapshotRes,\n                    globalSnapshot: globalSnapshotRes\n                };\n            } else {\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`\n          Cannot get remoteSnapshot with the name: '${moduleInfo.name}', version: '${moduleInfo.version}' from __FEDERATION__.moduleInfo. The following reasons may be causing the problem:\\n\n          1. The Deploy platform did not deliver the correct data. You can use __FEDERATION__.moduleInfo to check the remoteInfo.\\n\n          2. The remote '${moduleInfo.name}' version '${moduleInfo.version}' is not released.\\n\n          The transformed module info: ${JSON.stringify(globalSnapshotRes)}\n        `);\n            }\n        }\n    }\n    getGlobalRemoteInfo(moduleInfo) {\n        const hostGlobalSnapshot = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)({\n            name: this.HostInstance.options.name,\n            version: this.HostInstance.options.version\n        });\n        // get remote detail info from global\n        const globalRemoteInfo = hostGlobalSnapshot && 'remotesInfo' in hostGlobalSnapshot && hostGlobalSnapshot.remotesInfo && (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.l)(hostGlobalSnapshot.remotesInfo, moduleInfo.name).value;\n        if (globalRemoteInfo && globalRemoteInfo.matchedVersion) {\n            return {\n                hostGlobalSnapshot,\n                globalSnapshot: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(),\n                remoteSnapshot: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)({\n                    name: moduleInfo.name,\n                    version: globalRemoteInfo.matchedVersion\n                })\n            };\n        }\n        return {\n            hostGlobalSnapshot: undefined,\n            globalSnapshot: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(),\n            remoteSnapshot: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)({\n                name: moduleInfo.name,\n                version: 'version' in moduleInfo ? moduleInfo.version : undefined\n            })\n        };\n    }\n    async getManifestJson(manifestUrl, moduleInfo, extraOptions) {\n        const getManifest = async ()=>{\n            let manifestJson = this.manifestCache.get(manifestUrl);\n            if (manifestJson) {\n                return manifestJson;\n            }\n            try {\n                let res = await this.loaderHook.lifecycle.fetch.emit(manifestUrl, {});\n                if (!res || !(res instanceof Response)) {\n                    res = await fetch(manifestUrl, {});\n                }\n                manifestJson = await res.json();\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(manifestJson.metaData && manifestJson.exposes && manifestJson.shared, `${manifestUrl} is not a federation manifest`);\n                this.manifestCache.set(manifestUrl, manifestJson);\n                return manifestJson;\n            } catch (err) {\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`Failed to get manifestJson for ${moduleInfo.name}. The manifest URL is ${manifestUrl}. Please ensure that the manifestUrl is accessible.\n          \\n Error message:\n          \\n ${err}`);\n            }\n        };\n        const asyncLoadProcess = async ()=>{\n            const manifestJson = await getManifest();\n            const remoteSnapshot = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.generateSnapshotFromManifest)(manifestJson, {\n                version: manifestUrl\n            });\n            const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n                options: this.HostInstance.options,\n                moduleInfo,\n                manifestJson,\n                remoteSnapshot,\n                manifestUrl,\n                from: 'manifest'\n            });\n            return remoteSnapshotRes;\n        };\n        if (!this.manifestLoading[manifestUrl]) {\n            this.manifestLoading[manifestUrl] = asyncLoadProcess().then((res)=>res);\n        }\n        return this.manifestLoading[manifestUrl];\n    }\n    constructor(HostInstance){\n        this.loadingHostSnapshot = null;\n        this.manifestCache = new Map();\n        this.hooks = new PluginSystem({\n            beforeLoadRemoteSnapshot: new AsyncHook('beforeLoadRemoteSnapshot'),\n            loadSnapshot: new AsyncWaterfallHook('loadGlobalSnapshot'),\n            loadRemoteSnapshot: new AsyncWaterfallHook('loadRemoteSnapshot')\n        });\n        this.manifestLoading = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.G.__FEDERATION__.__MANIFEST_LOADING__;\n        this.HostInstance = HostInstance;\n        this.loaderHook = HostInstance.loaderHook;\n    }\n}\n\nfunction _extends$2() {\n    _extends$2 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$2.apply(this, arguments);\n}\nfunction _object_without_properties_loose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nclass SharedHandler {\n    // register shared in shareScopeMap\n    registerShared(globalOptions, userOptions) {\n        const { shareInfos, shared } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.v)(globalOptions, userOptions);\n        const sharedKeys = Object.keys(shareInfos);\n        sharedKeys.forEach((sharedKey)=>{\n            const sharedVals = shareInfos[sharedKey];\n            sharedVals.forEach((sharedVal)=>{\n                const registeredShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.o)(this.shareScopeMap, sharedKey, sharedVal, this.hooks.lifecycle.resolveShare);\n                if (!registeredShared && sharedVal && sharedVal.lib) {\n                    this.setShared({\n                        pkgName: sharedKey,\n                        lib: sharedVal.lib,\n                        get: sharedVal.get,\n                        loaded: true,\n                        shared: sharedVal,\n                        from: userOptions.name\n                    });\n                }\n            });\n        });\n        return {\n            shareInfos,\n            shared\n        };\n    }\n    async loadShare(pkgName, extraOptions) {\n        const { host } = this;\n        // This function performs the following steps:\n        // 1. Checks if the currently loaded share already exists, if not, it throws an error\n        // 2. Searches globally for a matching share, if found, it uses it directly\n        // 3. If not found, it retrieves it from the current share and stores the obtained share globally.\n        const shareInfo = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.x)({\n            pkgName,\n            extraOptions,\n            shareInfos: host.options.shared\n        });\n        if (shareInfo == null ? void 0 : shareInfo.scope) {\n            await Promise.all(shareInfo.scope.map(async (shareScope)=>{\n                await Promise.all(this.initializeSharing(shareScope, shareInfo.strategy));\n                return;\n            }));\n        }\n        const loadShareRes = await this.hooks.lifecycle.beforeLoadShare.emit({\n            pkgName,\n            shareInfo,\n            shared: host.options.shared,\n            origin: host\n        });\n        const { shareInfo: shareInfoRes } = loadShareRes;\n        // Assert that shareInfoRes exists, if not, throw an error\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(shareInfoRes, `Cannot find ${pkgName} Share in the ${host.options.name}. Please ensure that the ${pkgName} Share parameters have been injected`);\n        // Retrieve from cache\n        const registeredShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.o)(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);\n        const addUseIn = (shared)=>{\n            if (!shared.useIn) {\n                shared.useIn = [];\n            }\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)(shared.useIn, host.options.name);\n        };\n        if (registeredShared && registeredShared.lib) {\n            addUseIn(registeredShared);\n            return registeredShared.lib;\n        } else if (registeredShared && registeredShared.loading && !registeredShared.loaded) {\n            const factory = await registeredShared.loading;\n            registeredShared.loaded = true;\n            if (!registeredShared.lib) {\n                registeredShared.lib = factory;\n            }\n            addUseIn(registeredShared);\n            return factory;\n        } else if (registeredShared) {\n            const asyncLoadProcess = async ()=>{\n                const factory = await registeredShared.get();\n                shareInfoRes.lib = factory;\n                shareInfoRes.loaded = true;\n                addUseIn(shareInfoRes);\n                const gShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.o)(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);\n                if (gShared) {\n                    gShared.lib = factory;\n                    gShared.loaded = true;\n                }\n                return factory;\n            };\n            const loading = asyncLoadProcess();\n            this.setShared({\n                pkgName,\n                loaded: false,\n                shared: registeredShared,\n                from: host.options.name,\n                lib: null,\n                loading\n            });\n            return loading;\n        } else {\n            if (extraOptions == null ? void 0 : extraOptions.customShareInfo) {\n                return false;\n            }\n            const asyncLoadProcess = async ()=>{\n                const factory = await shareInfoRes.get();\n                shareInfoRes.lib = factory;\n                shareInfoRes.loaded = true;\n                addUseIn(shareInfoRes);\n                const gShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.o)(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);\n                if (gShared) {\n                    gShared.lib = factory;\n                    gShared.loaded = true;\n                }\n                return factory;\n            };\n            const loading = asyncLoadProcess();\n            this.setShared({\n                pkgName,\n                loaded: false,\n                shared: shareInfoRes,\n                from: host.options.name,\n                lib: null,\n                loading\n            });\n            return loading;\n        }\n    }\n    /**\n   * This function initializes the sharing sequence (executed only once per share scope).\n   * It accepts one argument, the name of the share scope.\n   * If the share scope does not exist, it creates one.\n   */ // eslint-disable-next-line @typescript-eslint/member-ordering\n    initializeSharing(shareScopeName = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.b, strategy) {\n        const { host } = this;\n        const shareScope = this.shareScopeMap;\n        const hostName = host.options.name;\n        // Creates a new share scope if necessary\n        if (!shareScope[shareScopeName]) {\n            shareScope[shareScopeName] = {};\n        }\n        // Executes all initialization snippets from all accessible modules\n        const scope = shareScope[shareScopeName];\n        const register = (name, shared)=>{\n            var _activeVersion_shareConfig;\n            const { version, eager } = shared;\n            scope[name] = scope[name] || {};\n            const versions = scope[name];\n            const activeVersion = versions[version];\n            const activeVersionEager = Boolean(activeVersion && (activeVersion.eager || ((_activeVersion_shareConfig = activeVersion.shareConfig) == null ? void 0 : _activeVersion_shareConfig.eager)));\n            if (!activeVersion || activeVersion.strategy !== 'loaded-first' && !activeVersion.loaded && (Boolean(!eager) !== !activeVersionEager ? eager : hostName > activeVersion.from)) {\n                versions[version] = shared;\n            }\n        };\n        const promises = [];\n        const initFn = (mod)=>mod && mod.init && mod.init(shareScope[shareScopeName]);\n        const initRemoteModule = async (key)=>{\n            const { module } = await host.remoteHandler.getRemoteModuleAndOptions({\n                id: key\n            });\n            if (module.getEntry) {\n                const entry = await module.getEntry();\n                if (!module.inited) {\n                    initFn(entry);\n                    module.inited = true;\n                }\n            }\n        };\n        Object.keys(host.options.shared).forEach((shareName)=>{\n            const sharedArr = host.options.shared[shareName];\n            sharedArr.forEach((shared)=>{\n                if (shared.scope.includes(shareScopeName)) {\n                    register(shareName, shared);\n                }\n            });\n        });\n        if (strategy === 'version-first') {\n            host.options.remotes.forEach((remote)=>{\n                if (remote.shareScope === shareScopeName) {\n                    promises.push(initRemoteModule(remote.name));\n                }\n            });\n        }\n        return promises;\n    }\n    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.\n    // 1. If the loaded shared already exists globally, then it will be reused\n    // 2. If lib exists in local shared, it will be used directly\n    // 3. If the local get returns something other than Promise, then it will be used directly\n    loadShareSync(pkgName, extraOptions) {\n        const { host } = this;\n        const shareInfo = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.x)({\n            pkgName,\n            extraOptions,\n            shareInfos: host.options.shared\n        });\n        if (shareInfo == null ? void 0 : shareInfo.scope) {\n            shareInfo.scope.forEach((shareScope)=>{\n                this.initializeSharing(shareScope, shareInfo.strategy);\n            });\n        }\n        const registeredShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.o)(this.shareScopeMap, pkgName, shareInfo, this.hooks.lifecycle.resolveShare);\n        const addUseIn = (shared)=>{\n            if (!shared.useIn) {\n                shared.useIn = [];\n            }\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)(shared.useIn, host.options.name);\n        };\n        if (registeredShared) {\n            if (typeof registeredShared.lib === 'function') {\n                addUseIn(registeredShared);\n                if (!registeredShared.loaded) {\n                    registeredShared.loaded = true;\n                    if (registeredShared.from === host.options.name) {\n                        shareInfo.loaded = true;\n                    }\n                }\n                return registeredShared.lib;\n            }\n            if (typeof registeredShared.get === 'function') {\n                const module = registeredShared.get();\n                if (!(module instanceof Promise)) {\n                    addUseIn(registeredShared);\n                    this.setShared({\n                        pkgName,\n                        loaded: true,\n                        from: host.options.name,\n                        lib: module,\n                        shared: registeredShared\n                    });\n                    return module;\n                }\n            }\n        }\n        if (shareInfo.lib) {\n            if (!shareInfo.loaded) {\n                shareInfo.loaded = true;\n            }\n            return shareInfo.lib;\n        }\n        if (shareInfo.get) {\n            const module = shareInfo.get();\n            if (module instanceof Promise) {\n                throw new Error(`\n        The loadShareSync function was unable to load ${pkgName}. The ${pkgName} could not be found in ${host.options.name}.\n        Possible reasons for failure: \\n\n        1. The ${pkgName} share was registered with the 'get' attribute, but loadShare was not used beforehand.\\n\n        2. The ${pkgName} share was not registered with the 'lib' attribute.\\n\n      `);\n            }\n            shareInfo.lib = module;\n            this.setShared({\n                pkgName,\n                loaded: true,\n                from: host.options.name,\n                lib: shareInfo.lib,\n                shared: shareInfo\n            });\n            return shareInfo.lib;\n        }\n        throw new Error(`\n        The loadShareSync function was unable to load ${pkgName}. The ${pkgName} could not be found in ${host.options.name}.\n        Possible reasons for failure: \\n\n        1. The ${pkgName} share was registered with the 'get' attribute, but loadShare was not used beforehand.\\n\n        2. The ${pkgName} share was not registered with the 'lib' attribute.\\n\n      `);\n    }\n    initShareScopeMap(scopeName, shareScope) {\n        const { host } = this;\n        this.shareScopeMap[scopeName] = shareScope;\n        this.hooks.lifecycle.initContainerShareScopeMap.emit({\n            shareScope,\n            options: host.options,\n            origin: host\n        });\n    }\n    setShared({ pkgName, shared, from, lib, loading, loaded, get }) {\n        const { version, scope = 'default' } = shared, shareInfo = _object_without_properties_loose(shared, [\n            \"version\",\n            \"scope\"\n        ]);\n        const scopes = Array.isArray(scope) ? scope : [\n            scope\n        ];\n        scopes.forEach((sc)=>{\n            if (!this.shareScopeMap[sc]) {\n                this.shareScopeMap[sc] = {};\n            }\n            if (!this.shareScopeMap[sc][pkgName]) {\n                this.shareScopeMap[sc][pkgName] = {};\n            }\n            if (this.shareScopeMap[sc][pkgName][version]) {\n                return;\n            }\n            this.shareScopeMap[sc][pkgName][version] = _extends$2({\n                version,\n                scope: [\n                    'default'\n                ]\n            }, shareInfo, {\n                lib,\n                loaded,\n                loading\n            });\n            if (get) {\n                this.shareScopeMap[sc][pkgName][version].get = get;\n            }\n        });\n    }\n    _setGlobalShareScopeMap(hostOptions) {\n        const globalShareScopeMap = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.y)();\n        const identifier = hostOptions.id || hostOptions.name;\n        if (identifier && !globalShareScopeMap[identifier]) {\n            globalShareScopeMap[identifier] = this.shareScopeMap;\n        }\n    }\n    constructor(host){\n        this.hooks = new PluginSystem({\n            afterResolve: new AsyncWaterfallHook('afterResolve'),\n            beforeLoadShare: new AsyncWaterfallHook('beforeLoadShare'),\n            // not used yet\n            loadShare: new AsyncHook(),\n            resolveShare: new SyncWaterfallHook('resolveShare'),\n            // maybe will change, temporarily for internal use only\n            initContainerShareScopeMap: new AsyncWaterfallHook('initContainer')\n        });\n        this.host = host;\n        this.shareScopeMap = {};\n        this._setGlobalShareScopeMap(host.options);\n    }\n}\n\nfunction _extends$1() {\n    _extends$1 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$1.apply(this, arguments);\n}\nclass RemoteHandler {\n    formatAndRegisterRemote(globalOptions, userOptions) {\n        const userRemotes = userOptions.remotes || [];\n        return userRemotes.reduce((res, remote)=>{\n            this.registerRemote(remote, res, {\n                force: false\n            });\n            return res;\n        }, globalOptions.remotes);\n    }\n    // eslint-disable-next-line max-lines-per-function\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async loadRemote(id, options) {\n        const { host } = this;\n        try {\n            const { loadFactory = true } = options || {\n                loadFactory: true\n            };\n            // 1. Validate the parameters of the retrieved module. There are two module request methods: pkgName + expose and alias + expose.\n            // 2. Request the snapshot information of the current host and globally store the obtained snapshot information. The retrieved module information is partially offline and partially online. The online module information will retrieve the modules used online.\n            // 3. Retrieve the detailed information of the current module from global (remoteEntry address, expose resource address)\n            // 4. After retrieving remoteEntry, call the init of the module, and then retrieve the exported content of the module through get\n            // id: pkgName(@federation/app1) + expose(button) = @federation/app1/button\n            // id: alias(app1) + expose(button) = app1/button\n            // id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort\n            const { module, moduleOptions, remoteMatchInfo } = await this.getRemoteModuleAndOptions({\n                id\n            });\n            const { pkgNameOrAlias, remote, expose, id: idRes } = remoteMatchInfo;\n            const moduleOrFactory = await module.get(expose, options);\n            const moduleWrapper = await this.hooks.lifecycle.onLoad.emit({\n                id: idRes,\n                pkgNameOrAlias,\n                expose,\n                exposeModule: loadFactory ? moduleOrFactory : undefined,\n                exposeModuleFactory: loadFactory ? undefined : moduleOrFactory,\n                remote,\n                options: moduleOptions,\n                moduleInstance: module,\n                origin: host\n            });\n            if (typeof moduleWrapper === 'function') {\n                return moduleWrapper;\n            }\n            return moduleOrFactory;\n        } catch (error) {\n            const { from = 'runtime' } = options || {\n                from: 'runtime'\n            };\n            const failOver = await this.hooks.lifecycle.errorLoadRemote.emit({\n                id,\n                error,\n                from,\n                lifecycle: 'onLoad',\n                origin: host\n            });\n            if (!failOver) {\n                throw error;\n            }\n            return failOver;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async preloadRemote(preloadOptions) {\n        const { host } = this;\n        await this.hooks.lifecycle.beforePreloadRemote.emit({\n            preloadOptions,\n            options: host.options,\n            origin: host\n        });\n        const preloadOps = formatPreloadArgs(host.options.remotes, preloadOptions);\n        await Promise.all(preloadOps.map(async (ops)=>{\n            const { remote } = ops;\n            const remoteInfo = getRemoteInfo(remote);\n            const { globalSnapshot, remoteSnapshot } = await host.snapshotHandler.loadRemoteSnapshotInfo(remote);\n            const assets = await this.hooks.lifecycle.generatePreloadAssets.emit({\n                origin: host,\n                preloadOptions: ops,\n                remote,\n                remoteInfo,\n                globalSnapshot,\n                remoteSnapshot\n            });\n            if (!assets) {\n                return;\n            }\n            preloadAssets(remoteInfo, host, assets);\n        }));\n    }\n    registerRemotes(remotes, options) {\n        const { host } = this;\n        remotes.forEach((remote)=>{\n            this.registerRemote(remote, host.options.remotes, {\n                force: options == null ? void 0 : options.force\n            });\n        });\n    }\n    async getRemoteModuleAndOptions(options) {\n        const { host } = this;\n        const { id } = options;\n        let loadRemoteArgs;\n        try {\n            loadRemoteArgs = await this.hooks.lifecycle.beforeRequest.emit({\n                id,\n                options: host.options,\n                origin: host\n            });\n        } catch (error) {\n            loadRemoteArgs = await this.hooks.lifecycle.errorLoadRemote.emit({\n                id,\n                options: host.options,\n                origin: host,\n                from: 'runtime',\n                error,\n                lifecycle: 'beforeRequest'\n            });\n            if (!loadRemoteArgs) {\n                throw error;\n            }\n        }\n        const { id: idRes } = loadRemoteArgs;\n        const remoteSplitInfo = matchRemoteWithNameAndExpose(host.options.remotes, idRes);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(remoteSplitInfo, `\n        Unable to locate ${idRes} in ${host.options.name}. Potential reasons for failure include:\\n\n        1. ${idRes} was not included in the 'remotes' parameter of ${host.options.name || 'the host'}.\\n\n        2. ${idRes} could not be found in the 'remotes' of ${host.options.name} with either 'name' or 'alias' attributes.\n        3. ${idRes} is not online, injected, or loaded.\n        4. ${idRes}  cannot be accessed on the expected.\n        5. The 'beforeRequest' hook was provided but did not return the correct 'remoteInfo' when attempting to load ${idRes}.\n      `);\n        const { remote: rawRemote } = remoteSplitInfo;\n        const remoteInfo = getRemoteInfo(rawRemote);\n        const matchInfo = await host.sharedHandler.hooks.lifecycle.afterResolve.emit(_extends$1({\n            id: idRes\n        }, remoteSplitInfo, {\n            options: host.options,\n            origin: host,\n            remoteInfo\n        }));\n        const { remote, expose } = matchInfo;\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(remote && expose, `The 'beforeRequest' hook was executed, but it failed to return the correct 'remote' and 'expose' values while loading ${idRes}.`);\n        let module = host.moduleCache.get(remote.name);\n        const moduleOptions = {\n            host: host,\n            remoteInfo\n        };\n        if (!module) {\n            module = new Module(moduleOptions);\n            host.moduleCache.set(remote.name, module);\n        }\n        return {\n            module,\n            moduleOptions,\n            remoteMatchInfo: matchInfo\n        };\n    }\n    registerRemote(remote, targetRemotes, options) {\n        const normalizeRemote = ()=>{\n            if (remote.alias) {\n                // Validate if alias equals the prefix of remote.name and remote.alias, if so, throw an error\n                // As multi-level path references cannot guarantee unique names, alias being a prefix of remote.name is not supported\n                const findEqual = targetRemotes.find((item)=>{\n                    var _item_alias;\n                    return remote.alias && (item.name.startsWith(remote.alias) || ((_item_alias = item.alias) == null ? void 0 : _item_alias.startsWith(remote.alias)));\n                });\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(!findEqual, `The alias ${remote.alias} of remote ${remote.name} is not allowed to be the prefix of ${findEqual && findEqual.name} name or alias`);\n            }\n            // Set the remote entry to a complete path\n            if ('entry' in remote) {\n                if ((0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isBrowserEnv)() && !remote.entry.startsWith('http')) {\n                    remote.entry = new URL(remote.entry, window.location.origin).href;\n                }\n            }\n            if (!remote.shareScope) {\n                remote.shareScope = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.b;\n            }\n            if (!remote.type) {\n                remote.type = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.D;\n            }\n        };\n        const registeredRemote = targetRemotes.find((item)=>item.name === remote.name);\n        if (!registeredRemote) {\n            normalizeRemote();\n            targetRemotes.push(remote);\n        } else {\n            const messages = [\n                `The remote \"${remote.name}\" is already registered.`,\n                (options == null ? void 0 : options.force) ? 'Hope you have known that OVERRIDE it may have some unexpected errors' : 'If you want to merge the remote, you can set \"force: true\".'\n            ];\n            if (options == null ? void 0 : options.force) {\n                // remove registered remote\n                this.removeRemote(registeredRemote);\n                normalizeRemote();\n                targetRemotes.push(remote);\n            }\n            (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.warn)(messages.join(' '));\n        }\n    }\n    removeRemote(remote) {\n        const { host } = this;\n        const { name } = remote;\n        const remoteIndex = host.options.remotes.findIndex((item)=>item.name === name);\n        if (remoteIndex !== -1) {\n            host.options.remotes.splice(remoteIndex, 1);\n        }\n        const loadedModule = host.moduleCache.get(remote.name);\n        if (loadedModule) {\n            const remoteInfo = loadedModule.remoteInfo;\n            const key = remoteInfo.entryGlobalName;\n            if (globalThis[key]) {\n                delete globalThis[key];\n            }\n            const remoteEntryUniqueKey = getRemoteEntryUniqueKey(loadedModule.remoteInfo);\n            if (_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[remoteEntryUniqueKey]) {\n                delete _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[remoteEntryUniqueKey];\n            }\n            // delete un loaded shared and instance\n            let remoteInsId = remoteInfo.buildVersion ? (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.composeKeyWithSeparator)(remoteInfo.name, remoteInfo.buildVersion) : remoteInfo.name;\n            const remoteInsIndex = globalThis.__FEDERATION__.__INSTANCES__.findIndex((ins)=>{\n                if (remoteInfo.buildVersion) {\n                    return ins.options.id === remoteInsId;\n                } else {\n                    return ins.name === remoteInsId;\n                }\n            });\n            if (remoteInsIndex !== -1) {\n                const remoteIns = globalThis.__FEDERATION__.__INSTANCES__[remoteInsIndex];\n                remoteInsId = remoteIns.options.id || remoteInsId;\n                const globalShareScopeMap = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.y)();\n                let isAllSharedNotUsed = true;\n                const needDeleteKeys = [];\n                Object.keys(globalShareScopeMap).forEach((instId)=>{\n                    Object.keys(globalShareScopeMap[instId]).forEach((shareScope)=>{\n                        Object.keys(globalShareScopeMap[instId][shareScope]).forEach((shareName)=>{\n                            Object.keys(globalShareScopeMap[instId][shareScope][shareName]).forEach((shareVersion)=>{\n                                const shared = globalShareScopeMap[instId][shareScope][shareName][shareVersion];\n                                if (shared.from === remoteInfo.name) {\n                                    if (shared.loaded || shared.loading) {\n                                        shared.useIn = shared.useIn.filter((usedHostName)=>usedHostName !== remoteInfo.name);\n                                        if (shared.useIn.length) {\n                                            isAllSharedNotUsed = false;\n                                        } else {\n                                            needDeleteKeys.push([\n                                                instId,\n                                                shareScope,\n                                                shareName,\n                                                shareVersion\n                                            ]);\n                                        }\n                                    } else {\n                                        needDeleteKeys.push([\n                                            instId,\n                                            shareScope,\n                                            shareName,\n                                            shareVersion\n                                        ]);\n                                    }\n                                }\n                            });\n                        });\n                    });\n                });\n                if (isAllSharedNotUsed) {\n                    remoteIns.shareScopeMap = {};\n                    delete globalShareScopeMap[remoteInsId];\n                }\n                needDeleteKeys.forEach(([insId, shareScope, shareName, shareVersion])=>{\n                    var _globalShareScopeMap_insId_shareScope_shareName, _globalShareScopeMap_insId_shareScope, _globalShareScopeMap_insId;\n                    (_globalShareScopeMap_insId = globalShareScopeMap[insId]) == null ? true : (_globalShareScopeMap_insId_shareScope = _globalShareScopeMap_insId[shareScope]) == null ? true : (_globalShareScopeMap_insId_shareScope_shareName = _globalShareScopeMap_insId_shareScope[shareName]) == null ? true : delete _globalShareScopeMap_insId_shareScope_shareName[shareVersion];\n                });\n                globalThis.__FEDERATION__.__INSTANCES__.splice(remoteInsIndex, 1);\n            }\n            host.moduleCache.delete(remote.name);\n        }\n    }\n    constructor(host){\n        this.hooks = new PluginSystem({\n            beforeRequest: new AsyncWaterfallHook('beforeRequest'),\n            onLoad: new AsyncHook('onLoad'),\n            handlePreloadModule: new SyncHook('handlePreloadModule'),\n            errorLoadRemote: new AsyncHook('errorLoadRemote'),\n            beforePreloadRemote: new AsyncHook(),\n            generatePreloadAssets: new AsyncHook('generatePreloadAssets'),\n            // not used yet\n            afterPreloadRemote: new AsyncHook()\n        });\n        this.host = host;\n    }\n}\n\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nclass FederationHost {\n    initOptions(userOptions) {\n        this.registerPlugins(userOptions.plugins);\n        const options = this.formatOptions(this.options, userOptions);\n        this.options = options;\n        return options;\n    }\n    async loadShare(pkgName, extraOptions) {\n        return this.sharedHandler.loadShare(pkgName, extraOptions);\n    }\n    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.\n    // 1. If the loaded shared already exists globally, then it will be reused\n    // 2. If lib exists in local shared, it will be used directly\n    // 3. If the local get returns something other than Promise, then it will be used directly\n    loadShareSync(pkgName, extraOptions) {\n        return this.sharedHandler.loadShareSync(pkgName, extraOptions);\n    }\n    initializeSharing(shareScopeName = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.b, strategy) {\n        return this.sharedHandler.initializeSharing(shareScopeName, strategy);\n    }\n    initRawContainer(name, url, container) {\n        const remoteInfo = getRemoteInfo({\n            name,\n            entry: url\n        });\n        const module = new Module({\n            host: this,\n            remoteInfo\n        });\n        module.remoteEntryExports = container;\n        this.moduleCache.set(name, module);\n        return module;\n    }\n    // eslint-disable-next-line max-lines-per-function\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async loadRemote(id, options) {\n        return this.remoteHandler.loadRemote(id, options);\n    }\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async preloadRemote(preloadOptions) {\n        return this.remoteHandler.preloadRemote(preloadOptions);\n    }\n    initShareScopeMap(scopeName, shareScope) {\n        this.sharedHandler.initShareScopeMap(scopeName, shareScope);\n    }\n    formatOptions(globalOptions, userOptions) {\n        const { shared } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.v)(globalOptions, userOptions);\n        const { userOptions: userOptionsRes, options: globalOptionsRes } = this.hooks.lifecycle.beforeInit.emit({\n            origin: this,\n            userOptions,\n            options: globalOptions,\n            shareInfo: shared\n        });\n        const remotes = this.remoteHandler.formatAndRegisterRemote(globalOptionsRes, userOptionsRes);\n        const { shared: handledShared } = this.sharedHandler.registerShared(globalOptionsRes, userOptionsRes);\n        const plugins = [\n            ...globalOptionsRes.plugins\n        ];\n        if (userOptionsRes.plugins) {\n            userOptionsRes.plugins.forEach((plugin)=>{\n                if (!plugins.includes(plugin)) {\n                    plugins.push(plugin);\n                }\n            });\n        }\n        const optionsRes = _extends({}, globalOptions, userOptions, {\n            plugins,\n            remotes,\n            shared: handledShared\n        });\n        this.hooks.lifecycle.init.emit({\n            origin: this,\n            options: optionsRes\n        });\n        return optionsRes;\n    }\n    registerPlugins(plugins) {\n        const pluginRes = registerPlugins$1(plugins, [\n            this.hooks,\n            this.remoteHandler.hooks,\n            this.sharedHandler.hooks,\n            this.snapshotHandler.hooks,\n            this.loaderHook\n        ]);\n        // Merge plugin\n        this.options.plugins = this.options.plugins.reduce((res, plugin)=>{\n            if (!plugin) return res;\n            if (res && !res.find((item)=>item.name === plugin.name)) {\n                res.push(plugin);\n            }\n            return res;\n        }, pluginRes || []);\n    }\n    registerRemotes(remotes, options) {\n        return this.remoteHandler.registerRemotes(remotes, options);\n    }\n    constructor(userOptions){\n        this.hooks = new PluginSystem({\n            beforeInit: new SyncWaterfallHook('beforeInit'),\n            init: new SyncHook(),\n            // maybe will change, temporarily for internal use only\n            beforeInitContainer: new AsyncWaterfallHook('beforeInitContainer'),\n            // maybe will change, temporarily for internal use only\n            initContainer: new AsyncWaterfallHook('initContainer')\n        });\n        this.version = \"0.1.15\";\n        this.moduleCache = new Map();\n        this.loaderHook = new PluginSystem({\n            // FIXME: may not be suitable , not open to the public yet\n            getModuleInfo: new SyncHook(),\n            createScript: new SyncHook(),\n            createLink: new SyncHook(),\n            // only work for manifest , so not open to the public yet\n            fetch: new AsyncHook('fetch')\n        });\n        // TODO: Validate the details of the options\n        // Initialize options with default values\n        const defaultOptions = {\n            id: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)(),\n            name: userOptions.name,\n            plugins: [\n                snapshotPlugin(),\n                generatePreloadAssetsPlugin()\n            ],\n            remotes: [],\n            shared: {},\n            inBrowser: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.B)()\n        };\n        this.name = userOptions.name;\n        this.options = defaultOptions;\n        this.snapshotHandler = new SnapshotHandler(this);\n        this.sharedHandler = new SharedHandler(this);\n        this.remoteHandler = new RemoteHandler(this);\n        this.shareScopeMap = this.sharedHandler.shareScopeMap;\n        this.registerPlugins([\n            ...defaultOptions.plugins,\n            ...userOptions.plugins || []\n        ]);\n        this.options = this.formatOptions(defaultOptions, userOptions);\n    }\n}\n\nlet FederationInstance = null;\nfunction init(options) {\n    // Retrieve the same instance with the same name\n    const instance = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.name, options.version);\n    if (!instance) {\n        // Retrieve debug constructor\n        const FederationConstructor = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.F)() || FederationHost;\n        FederationInstance = new FederationConstructor(options);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.H)(FederationInstance);\n        return FederationInstance;\n    } else {\n        // Merge options\n        instance.initOptions(options);\n        if (!FederationInstance) {\n            FederationInstance = instance;\n        }\n        return instance;\n    }\n}\nfunction loadRemote(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    const loadRemote1 = FederationInstance.loadRemote;\n    // eslint-disable-next-line prefer-spread\n    return loadRemote1.apply(FederationInstance, args);\n}\nfunction loadShare(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    // eslint-disable-next-line prefer-spread\n    const loadShare1 = FederationInstance.loadShare;\n    return loadShare1.apply(FederationInstance, args);\n}\nfunction loadShareSync(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    const loadShareSync1 = FederationInstance.loadShareSync;\n    // eslint-disable-next-line prefer-spread\n    return loadShareSync1.apply(FederationInstance, args);\n}\nfunction preloadRemote(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    // eslint-disable-next-line prefer-spread\n    return FederationInstance.preloadRemote.apply(FederationInstance, args);\n}\nfunction registerRemotes(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    // eslint-disable-next-line prefer-spread\n    return FederationInstance.registerRemotes.apply(FederationInstance, args);\n}\nfunction registerPlugins(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    // eslint-disable-next-line prefer-spread\n    return FederationInstance.registerPlugins.apply(FederationInstance, args);\n}\n// Inject for debug\n(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.C)(FederationHost);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi9ydW50aW1lL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1MEI7QUFDM3dCO0FBQzZJO0FBQ3JJOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixnREFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUMsMkNBQTJDO0FBQzVFLFlBQVksbUNBQW1DLEVBQUUsZ0RBQXFCO0FBQ3RFO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnREFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsdUJBQXVCLGdEQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdEQUEyQjtBQUNoRDtBQUNBO0FBQ0Esc0NBQXNDLGdEQUE4QjtBQUNwRTtBQUNBLFFBQVEsZ0RBQTJCO0FBQ25DO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUE4Qjs7QUFFd0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2R1bGVBcHBCLy4uLy4uL25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vcnVudGltZS9kaXN0L2luZGV4LmVzbS5qcz9hYzg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGcgYXMgZ2V0R2xvYmFsSG9zdFBsdWdpbnMsIGEgYXMgZ2xvYmFsTG9hZGluZywgRCBhcyBERUZBVUxUX1JFTU9URV9UWVBFLCBiIGFzIERFRkFVTFRfU0NPUEUsIGMgYXMgZ2V0UmVtb3RlRW50cnlFeHBvcnRzLCBkIGFzIGFzc2VydCwgcyBhcyBzYWZlVG9TdHJpbmcsIGUgYXMgZ2V0Rk1JZCwgaSBhcyBpc09iamVjdCwgZiBhcyBlcnJvciwgdyBhcyB3YXJuLCBoIGFzIGlzUGxhaW5PYmplY3QsIGogYXMgaXNSZW1vdGVJbmZvV2l0aEVudHJ5LCBrIGFzIGlzUHVyZVJlbW90ZUVudHJ5LCBsIGFzIGdldEluZm9XaXRob3V0VHlwZSwgbSBhcyBnZXRQcmVsb2FkZWQsIG4gYXMgc2V0UHJlbG9hZGVkLCBvIGFzIGdldFJlZ2lzdGVyZWRTaGFyZSwgcCBhcyBhcnJheU9wdGlvbnMsIHEgYXMgZ2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvLCByIGFzIGFkZEdsb2JhbFNuYXBzaG90LCB0IGFzIHNldEdsb2JhbFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbywgdSBhcyBnZXRHbG9iYWxTbmFwc2hvdCwgRyBhcyBHbG9iYWwsIHYgYXMgZm9ybWF0U2hhcmVDb25maWdzLCB4IGFzIGdldFRhcmdldFNoYXJlZE9wdGlvbnMsIHkgYXMgZ2V0R2xvYmFsU2hhcmVTY29wZSwgeiBhcyBhZGRVbmlxdWVJdGVtLCBBIGFzIGdldEJ1aWxkZXJJZCwgQiBhcyBpc0Jyb3dzZXJFbnYkMSwgQyBhcyBzZXRHbG9iYWxGZWRlcmF0aW9uQ29uc3RydWN0b3IsIEUgYXMgZ2V0R2xvYmFsRmVkZXJhdGlvbkluc3RhbmNlLCBGIGFzIGdldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvciwgSCBhcyBzZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UgfSBmcm9tICcuL3NoYXJlLmVzbS5qcyc7XG5leHBvcnQgeyBJIGFzIHJlZ2lzdGVyR2xvYmFsUGx1Z2lucyB9IGZyb20gJy4vc2hhcmUuZXNtLmpzJztcbmltcG9ydCB7IGxvYWRTY3JpcHROb2RlLCBsb2FkU2NyaXB0LCBjb21wb3NlS2V5V2l0aFNlcGFyYXRvciwgY3JlYXRlTGluaywgZ2V0UmVzb3VyY2VVcmwsIGlzTWFuaWZlc3RQcm92aWRlciwgZ2VuZXJhdGVTbmFwc2hvdEZyb21NYW5pZmVzdCwgd2FybiBhcyB3YXJuJDEsIGlzQnJvd3NlckVudiB9IGZyb20gJ0Btb2R1bGUtZmVkZXJhdGlvbi9zZGsnO1xuZXhwb3J0IHsgbG9hZFNjcmlwdCwgbG9hZFNjcmlwdE5vZGUgfSBmcm9tICdAbW9kdWxlLWZlZGVyYXRpb24vc2RrJztcblxuLy8gRnVuY3Rpb24gdG8gbWF0Y2ggYSByZW1vdGUgd2l0aCBpdHMgbmFtZSBhbmQgZXhwb3NlXG4vLyBpZDogcGtnTmFtZShAZmVkZXJhdGlvbi9hcHAxKSArIGV4cG9zZShidXR0b24pID0gQGZlZGVyYXRpb24vYXBwMS9idXR0b25cbi8vIGlkOiBhbGlhcyhhcHAxKSArIGV4cG9zZShidXR0b24pID0gYXBwMS9idXR0b25cbi8vIGlkOiBhbGlhcyhhcHAxL3V0aWxzKSArIGV4cG9zZShsb2FkYXNoL3NvcnQpID0gYXBwMS91dGlscy9sb2FkYXNoL3NvcnRcbmZ1bmN0aW9uIG1hdGNoUmVtb3RlV2l0aE5hbWVBbmRFeHBvc2UocmVtb3RlcywgaWQpIHtcbiAgICBmb3IgKGNvbnN0IHJlbW90ZSBvZiByZW1vdGVzKXtcbiAgICAgICAgLy8gbWF0Y2ggcGtnTmFtZVxuICAgICAgICBjb25zdCBpc05hbWVNYXRjaGVkID0gaWQuc3RhcnRzV2l0aChyZW1vdGUubmFtZSk7XG4gICAgICAgIGxldCBleHBvc2UgPSBpZC5yZXBsYWNlKHJlbW90ZS5uYW1lLCAnJyk7XG4gICAgICAgIGlmIChpc05hbWVNYXRjaGVkKSB7XG4gICAgICAgICAgICBpZiAoZXhwb3NlLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBrZ05hbWVPckFsaWFzID0gcmVtb3RlLm5hbWU7XG4gICAgICAgICAgICAgICAgZXhwb3NlID0gYC4ke2V4cG9zZX1gO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBrZ05hbWVPckFsaWFzLFxuICAgICAgICAgICAgICAgICAgICBleHBvc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cG9zZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwa2dOYW1lT3JBbGlhczogcmVtb3RlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZTogJy4nLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG1hdGNoIGFsaWFzXG4gICAgICAgIGNvbnN0IGlzQWxpYXNNYXRjaGVkID0gcmVtb3RlLmFsaWFzICYmIGlkLnN0YXJ0c1dpdGgocmVtb3RlLmFsaWFzKTtcbiAgICAgICAgbGV0IGV4cG9zZVdpdGhBbGlhcyA9IHJlbW90ZS5hbGlhcyAmJiBpZC5yZXBsYWNlKHJlbW90ZS5hbGlhcywgJycpO1xuICAgICAgICBpZiAocmVtb3RlLmFsaWFzICYmIGlzQWxpYXNNYXRjaGVkKSB7XG4gICAgICAgICAgICBpZiAoZXhwb3NlV2l0aEFsaWFzICYmIGV4cG9zZVdpdGhBbGlhcy5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwa2dOYW1lT3JBbGlhcyA9IHJlbW90ZS5hbGlhcztcbiAgICAgICAgICAgICAgICBleHBvc2VXaXRoQWxpYXMgPSBgLiR7ZXhwb3NlV2l0aEFsaWFzfWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGtnTmFtZU9yQWxpYXMsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZTogZXhwb3NlV2l0aEFsaWFzLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleHBvc2VXaXRoQWxpYXMgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGtnTmFtZU9yQWxpYXM6IHJlbW90ZS5hbGlhcyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3NlOiAnLicsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufVxuLy8gRnVuY3Rpb24gdG8gbWF0Y2ggYSByZW1vdGUgd2l0aCBpdHMgbmFtZSBvciBhbGlhc1xuZnVuY3Rpb24gbWF0Y2hSZW1vdGUocmVtb3RlcywgbmFtZU9yQWxpYXMpIHtcbiAgICBmb3IgKGNvbnN0IHJlbW90ZSBvZiByZW1vdGVzKXtcbiAgICAgICAgY29uc3QgaXNOYW1lTWF0Y2hlZCA9IG5hbWVPckFsaWFzID09PSByZW1vdGUubmFtZTtcbiAgICAgICAgaWYgKGlzTmFtZU1hdGNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZW1vdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBbGlhc01hdGNoZWQgPSByZW1vdGUuYWxpYXMgJiYgbmFtZU9yQWxpYXMgPT09IHJlbW90ZS5hbGlhcztcbiAgICAgICAgaWYgKGlzQWxpYXNNYXRjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW5zJDEocGx1Z2lucywgaG9va0luc3RhbmNlcykge1xuICAgIGNvbnN0IGdsb2JhbFBsdWdpbnMgPSBnZXRHbG9iYWxIb3N0UGx1Z2lucygpO1xuICAgIC8vIEluY29ycG9yYXRlIGdsb2JhbCBwbHVnaW5zXG4gICAgaWYgKGdsb2JhbFBsdWdpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBnbG9iYWxQbHVnaW5zLmZvckVhY2goKHBsdWdpbik9PntcbiAgICAgICAgICAgIGlmIChwbHVnaW5zID09IG51bGwgPyB2b2lkIDAgOiBwbHVnaW5zLmZpbmQoKGl0ZW0pPT5pdGVtLm5hbWUgIT09IHBsdWdpbi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBsdWdpbnMgJiYgcGx1Z2lucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKT0+e1xuICAgICAgICAgICAgaG9va0luc3RhbmNlcy5mb3JFYWNoKChob29rSW5zdGFuY2UpPT57XG4gICAgICAgICAgICAgICAgaG9va0luc3RhbmNlLmFwcGx5UGx1Z2luKHBsdWdpbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwbHVnaW5zO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcyQ3KCkge1xuICAgIF9leHRlbmRzJDcgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2Upe1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMkNy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEVzbUVudHJ5KHsgZW50cnksIHJlbW90ZUVudHJ5RXhwb3J0cyB9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXJlbW90ZUVudHJ5RXhwb3J0cykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1ldmFsXG4gICAgICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKCdjYWxsYmFja3MnLCBgaW1wb3J0KFwiJHtlbnRyeX1cIikudGhlbihjYWxsYmFja3NbMF0pLmNhdGNoKGNhbGxiYWNrc1sxXSlgKShbXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlbW90ZUVudHJ5RXhwb3J0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEVudHJ5U2NyaXB0KHsgbmFtZSwgZ2xvYmFsTmFtZSwgZW50cnksIGNyZWF0ZVNjcmlwdEhvb2sgfSkge1xuICAgIGNvbnN0IHsgZW50cnlFeHBvcnRzOiByZW1vdGVFbnRyeUV4cG9ydHMgfSA9IGdldFJlbW90ZUVudHJ5RXhwb3J0cyhuYW1lLCBnbG9iYWxOYW1lKTtcbiAgICBpZiAocmVtb3RlRW50cnlFeHBvcnRzKSB7XG4gICAgICAgIHJldHVybiByZW1vdGVFbnRyeUV4cG9ydHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBsb2FkU2NyaXB0Tm9kZShlbnRyeSwge1xuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGdsb2JhbE5hbWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVhdGVTY3JpcHRIb29rXG4gICAgICAgIH0pLnRoZW4oKCk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgcmVtb3RlRW50cnlLZXksIGVudHJ5RXhwb3J0cyB9ID0gZ2V0UmVtb3RlRW50cnlFeHBvcnRzKG5hbWUsIGdsb2JhbE5hbWUpO1xuICAgICAgICAgICAgYXNzZXJ0KGVudHJ5RXhwb3J0cywgYFxuICAgICAgICBVbmFibGUgdG8gdXNlIHRoZSAke25hbWV9J3MgJyR7ZW50cnl9JyBVUkwgd2l0aCAke3JlbW90ZUVudHJ5S2V5fSdzIGdsb2JhbE5hbWUgdG8gZ2V0IHJlbW90ZUVudHJ5IGV4cG9ydHMuXG4gICAgICAgIFBvc3NpYmxlIHJlYXNvbnMgY291bGQgYmU6XFxuXG4gICAgICAgIDEuICcke2VudHJ5fScgaXMgbm90IHRoZSBjb3JyZWN0IFVSTCwgb3IgdGhlIHJlbW90ZUVudHJ5IHJlc291cmNlIG9yIG5hbWUgaXMgaW5jb3JyZWN0LlxcblxuICAgICAgICAyLiAke3JlbW90ZUVudHJ5S2V5fSBjYW5ub3QgYmUgdXNlZCB0byBnZXQgcmVtb3RlRW50cnkgZXhwb3J0cyBpbiB0aGUgd2luZG93IG9iamVjdC5cbiAgICAgIGApO1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5RXhwb3J0cztcbiAgICAgICAgfSkuY2F0Y2goKGUpPT57XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBsb2FkU2NyaXB0KGVudHJ5LCB7XG4gICAgICAgIGF0dHJzOiB7fSxcbiAgICAgICAgY3JlYXRlU2NyaXB0SG9va1xuICAgIH0pLnRoZW4oKCk9PntcbiAgICAgICAgY29uc3QgeyByZW1vdGVFbnRyeUtleSwgZW50cnlFeHBvcnRzIH0gPSBnZXRSZW1vdGVFbnRyeUV4cG9ydHMobmFtZSwgZ2xvYmFsTmFtZSk7XG4gICAgICAgIGFzc2VydChlbnRyeUV4cG9ydHMsIGBcbiAgICAgIFVuYWJsZSB0byB1c2UgdGhlICR7bmFtZX0ncyAnJHtlbnRyeX0nIFVSTCB3aXRoICR7cmVtb3RlRW50cnlLZXl9J3MgZ2xvYmFsTmFtZSB0byBnZXQgcmVtb3RlRW50cnkgZXhwb3J0cy5cbiAgICAgIFBvc3NpYmxlIHJlYXNvbnMgY291bGQgYmU6XFxuXG4gICAgICAxLiAnJHtlbnRyeX0nIGlzIG5vdCB0aGUgY29ycmVjdCBVUkwsIG9yIHRoZSByZW1vdGVFbnRyeSByZXNvdXJjZSBvciBuYW1lIGlzIGluY29ycmVjdC5cXG5cbiAgICAgIDIuICR7cmVtb3RlRW50cnlLZXl9IGNhbm5vdCBiZSB1c2VkIHRvIGdldCByZW1vdGVFbnRyeSBleHBvcnRzIGluIHRoZSB3aW5kb3cgb2JqZWN0LlxuICAgIGApO1xuICAgICAgICByZXR1cm4gZW50cnlFeHBvcnRzO1xuICAgIH0pLmNhdGNoKChlKT0+e1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJlbW90ZUVudHJ5VW5pcXVlS2V5KHJlbW90ZUluZm8pIHtcbiAgICBjb25zdCB7IGVudHJ5LCBuYW1lIH0gPSByZW1vdGVJbmZvO1xuICAgIHJldHVybiBjb21wb3NlS2V5V2l0aFNlcGFyYXRvcihuYW1lLCBlbnRyeSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZW1vdGVFbnRyeSh7IHJlbW90ZUVudHJ5RXhwb3J0cywgcmVtb3RlSW5mbywgY3JlYXRlU2NyaXB0SG9vayB9KSB7XG4gICAgY29uc3QgeyBlbnRyeSwgbmFtZSwgdHlwZSwgZW50cnlHbG9iYWxOYW1lIH0gPSByZW1vdGVJbmZvO1xuICAgIGNvbnN0IHVuaXF1ZUtleSA9IGdldFJlbW90ZUVudHJ5VW5pcXVlS2V5KHJlbW90ZUluZm8pO1xuICAgIGlmIChyZW1vdGVFbnRyeUV4cG9ydHMpIHtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICB9XG4gICAgaWYgKCFnbG9iYWxMb2FkaW5nW3VuaXF1ZUtleV0pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdlc20nKSB7XG4gICAgICAgICAgICBnbG9iYWxMb2FkaW5nW3VuaXF1ZUtleV0gPSBsb2FkRXNtRW50cnkoe1xuICAgICAgICAgICAgICAgIGVudHJ5LFxuICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWxMb2FkaW5nW3VuaXF1ZUtleV0gPSBsb2FkRW50cnlTY3JpcHQoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZ2xvYmFsTmFtZTogZW50cnlHbG9iYWxOYW1lLFxuICAgICAgICAgICAgICAgIGVudHJ5LFxuICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdEhvb2tcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxMb2FkaW5nW3VuaXF1ZUtleV07XG59XG5mdW5jdGlvbiBnZXRSZW1vdGVJbmZvKHJlbW90ZSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyQ3KHt9LCByZW1vdGUsIHtcbiAgICAgICAgZW50cnk6ICdlbnRyeScgaW4gcmVtb3RlID8gcmVtb3RlLmVudHJ5IDogJycsXG4gICAgICAgIHR5cGU6IHJlbW90ZS50eXBlIHx8IERFRkFVTFRfUkVNT1RFX1RZUEUsXG4gICAgICAgIGVudHJ5R2xvYmFsTmFtZTogcmVtb3RlLmVudHJ5R2xvYmFsTmFtZSB8fCByZW1vdGUubmFtZSxcbiAgICAgICAgc2hhcmVTY29wZTogcmVtb3RlLnNoYXJlU2NvcGUgfHwgREVGQVVMVF9TQ09QRVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcyQ2KCkge1xuICAgIF9leHRlbmRzJDYgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2Upe1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMkNi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxubGV0IE1vZHVsZSA9IGNsYXNzIE1vZHVsZSB7XG4gICAgYXN5bmMgZ2V0RW50cnkoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW90ZUVudHJ5RXhwb3J0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRW50cnlFeHBvcnRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCByZW1vdGVFbnRyeS5qc1xuICAgICAgICBjb25zdCByZW1vdGVFbnRyeUV4cG9ydHMgPSBhd2FpdCBnZXRSZW1vdGVFbnRyeSh7XG4gICAgICAgICAgICByZW1vdGVJbmZvOiB0aGlzLnJlbW90ZUluZm8sXG4gICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHM6IHRoaXMucmVtb3RlRW50cnlFeHBvcnRzLFxuICAgICAgICAgICAgY3JlYXRlU2NyaXB0SG9vazogKHVybCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLmhvc3QubG9hZGVySG9vay5saWZlY3ljbGUuY3JlYXRlU2NyaXB0LmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICB1cmxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdG9kbzogbmVlZHMgcmVhbCBmaXhcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIEhUTUxTY3JpcHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnc2NyaXB0JyBpbiByZXMgfHwgJ3RpbWVvdXQnIGluIHJlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhc3NlcnQocmVtb3RlRW50cnlFeHBvcnRzLCBgcmVtb3RlRW50cnlFeHBvcnRzIGlzIHVuZGVmaW5lZCBcXG4gJHtzYWZlVG9TdHJpbmcodGhpcy5yZW1vdGVJbmZvKX1gKTtcbiAgICAgICAgdGhpcy5yZW1vdGVFbnRyeUV4cG9ydHMgPSByZW1vdGVFbnRyeUV4cG9ydHM7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgICBhc3luYyBnZXQoZXhwb3NlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgbG9hZEZhY3RvcnkgPSB0cnVlIH0gPSBvcHRpb25zIHx8IHtcbiAgICAgICAgICAgIGxvYWRGYWN0b3J5OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIC8vIEdldCByZW1vdGVFbnRyeS5qc1xuICAgICAgICBjb25zdCByZW1vdGVFbnRyeUV4cG9ydHMgPSBhd2FpdCB0aGlzLmdldEVudHJ5KCk7XG4gICAgICAgIGlmICghdGhpcy5pbml0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU2hhcmVTY29wZU1hcCA9IHRoaXMuaG9zdC5zaGFyZVNjb3BlTWFwO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlU2hhcmVTY29wZSA9IHRoaXMucmVtb3RlSW5mby5zaGFyZVNjb3BlIHx8ICdkZWZhdWx0JztcbiAgICAgICAgICAgIGlmICghbG9jYWxTaGFyZVNjb3BlTWFwW3JlbW90ZVNoYXJlU2NvcGVdKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTaGFyZVNjb3BlTWFwW3JlbW90ZVNoYXJlU2NvcGVdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaGFyZVNjb3BlID0gbG9jYWxTaGFyZVNjb3BlTWFwW3JlbW90ZVNoYXJlU2NvcGVdO1xuICAgICAgICAgICAgY29uc3QgaW5pdFNjb3BlID0gW107XG4gICAgICAgICAgICBjb25zdCByZW1vdGVFbnRyeUluaXRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IHRoaXMucmVtb3RlSW5mby52ZXJzaW9uIHx8ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gSGVscCB0byBmaW5kIGhvc3QgaW5zdGFuY2VcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZW1vdGVFbnRyeUluaXRPcHRpb25zLCAnaG9zdElkJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmhvc3Qub3B0aW9ucy5pZCB8fCB0aGlzLmhvc3QubmFtZSxcbiAgICAgICAgICAgICAgICAvLyByZW1vdGVFbnRyeUluaXRPcHRpb25zIHdpbGwgYmUgdHJhdmVyc2VkIGFuZCBhc3NpZ25lZCBkdXJpbmcgY29udGFpbmVyIGluaXQsICxzbyB0aGlzIGF0dHJpYnV0ZSBpcyBub3QgYWxsb3dlZCB0byBiZSB0cmF2ZXJzZWRcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBpbml0Q29udGFpbmVyT3B0aW9ucyA9IGF3YWl0IHRoaXMuaG9zdC5ob29rcy5saWZlY3ljbGUuYmVmb3JlSW5pdENvbnRhaW5lci5lbWl0KHtcbiAgICAgICAgICAgICAgICBzaGFyZVNjb3BlLFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgaG9zdElkIHdpbGwgYmUgc2V0IGJ5IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaW5pdFNjb3BlLFxuICAgICAgICAgICAgICAgIHJlbW90ZUluZm86IHRoaXMucmVtb3RlSW5mbyxcbiAgICAgICAgICAgICAgICBvcmlnaW46IHRoaXMuaG9zdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByZW1vdGVFbnRyeUV4cG9ydHMuaW5pdChpbml0Q29udGFpbmVyT3B0aW9ucy5zaGFyZVNjb3BlLCBpbml0Q29udGFpbmVyT3B0aW9ucy5pbml0U2NvcGUsIGluaXRDb250YWluZXJPcHRpb25zLnJlbW90ZUVudHJ5SW5pdE9wdGlvbnMpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5ob3N0Lmhvb2tzLmxpZmVjeWNsZS5pbml0Q29udGFpbmVyLmVtaXQoX2V4dGVuZHMkNih7fSwgaW5pdENvbnRhaW5lck9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpYiA9IHJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICAgICAgdGhpcy5pbml0ZWQgPSB0cnVlO1xuICAgICAgICAvLyBnZXQgZXhwb3NlR2V0dGVyXG4gICAgICAgIGNvbnN0IG1vZHVsZUZhY3RvcnkgPSBhd2FpdCByZW1vdGVFbnRyeUV4cG9ydHMuZ2V0KGV4cG9zZSk7XG4gICAgICAgIGFzc2VydChtb2R1bGVGYWN0b3J5LCBgJHtnZXRGTUlkKHRoaXMucmVtb3RlSW5mbyl9IHJlbW90ZSBkb24ndCBleHBvcnQgJHtleHBvc2V9LmApO1xuICAgICAgICBpZiAoIWxvYWRGYWN0b3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlRmFjdG9yeTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHBvc2VDb250ZW50ID0gYXdhaXQgbW9kdWxlRmFjdG9yeSgpO1xuICAgICAgICByZXR1cm4gZXhwb3NlQ29udGVudDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyByZW1vdGVJbmZvLCBob3N0IH0pe1xuICAgICAgICB0aGlzLmluaXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpYiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZW1vdGVJbmZvID0gcmVtb3RlSW5mbztcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB9XG59O1xuXG5jbGFzcyBTeW5jSG9vayB7XG4gICAgb24oZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuYWRkKGZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbmNlKGZuKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5vbihmdW5jdGlvbiB3cmFwcGVyKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlKHdyYXBwZXIpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtaXQoLi4uZGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChmbik9PntcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbiguLi5kYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlbW92ZShmbikge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUoZm4pO1xuICAgIH1cbiAgICByZW1vdmVBbGwoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHR5cGUpe1xuICAgICAgICB0aGlzLnR5cGUgPSAnJztcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBBc3luY0hvb2sgZXh0ZW5kcyBTeW5jSG9vayB7XG4gICAgZW1pdCguLi5kYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IGxzID0gQXJyYXkuZnJvbSh0aGlzLmxpc3RlbmVycyk7XG4gICAgICAgIGlmIChscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBjb25zdCBjYWxsID0gKHByZXYpPT57XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gQWJvcnQgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IGxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxzW2krK10uYXBwbHkobnVsbCwgZGF0YSkpLnRoZW4oY2FsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhbGwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gY2hlY2tSZXR1cm5EYXRhKG9yaWdpbmFsRGF0YSwgcmV0dXJuZWREYXRhKSB7XG4gICAgaWYgKCFpc09iamVjdChyZXR1cm5lZERhdGEpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbmFsRGF0YSAhPT0gcmV0dXJuZWREYXRhKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBmb3IoY29uc3Qga2V5IGluIG9yaWdpbmFsRGF0YSl7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gcmV0dXJuZWREYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIFN5bmNXYXRlcmZhbGxIb29rIGV4dGVuZHMgU3luY0hvb2sge1xuICAgIGVtaXQoZGF0YSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgICBlcnJvcihgVGhlIGRhdGEgZm9yIHRoZSBcIiR7dGhpcy50eXBlfVwiIGhvb2sgc2hvdWxkIGJlIGFuIG9iamVjdC5gKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMubGlzdGVuZXJzKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcERhdGEgPSBmbihkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tSZXR1cm5EYXRhKGRhdGEsIHRlbXBEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGVtcERhdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKGBBIHBsdWdpbiByZXR1cm5lZCBhbiB1bmFjY2VwdGFibGUgdmFsdWUgZm9yIHRoZSBcIiR7dGhpcy50eXBlfVwiIHR5cGUuYCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGUpO1xuICAgICAgICAgICAgICAgIHRoaXMub25lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodHlwZSl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub25lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbn1cblxuY2xhc3MgQXN5bmNXYXRlcmZhbGxIb29rIGV4dGVuZHMgU3luY0hvb2sge1xuICAgIGVtaXQoZGF0YSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgICBlcnJvcihgVGhlIHJlc3BvbnNlIGRhdGEgZm9yIHRoZSBcIiR7dGhpcy50eXBlfVwiIGhvb2sgbXVzdCBiZSBhbiBvYmplY3QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbHMgPSBBcnJheS5mcm9tKHRoaXMubGlzdGVuZXJzKTtcbiAgICAgICAgaWYgKGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlKT0+e1xuICAgICAgICAgICAgICAgIHdhcm4oZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGwgPSAocHJldkRhdGEpPT57XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUmV0dXJuRGF0YShkYXRhLCBwcmV2RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHByZXZEYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxzW2krK10oZGF0YSkpLnRoZW4oY2FsbCwgcHJvY2Vzc0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0Vycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKGBBIHBsdWdpbiByZXR1cm5lZCBhbiBpbmNvcnJlY3QgdmFsdWUgZm9yIHRoZSBcIiR7dGhpcy50eXBlfVwiIHR5cGUuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FsbChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodHlwZSl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub25lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbn1cblxuY2xhc3MgUGx1Z2luU3lzdGVtIHtcbiAgICBhcHBseVBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgYXNzZXJ0KGlzUGxhaW5PYmplY3QocGx1Z2luKSwgJ1BsdWdpbiBjb25maWd1cmF0aW9uIGlzIGludmFsaWQuJyk7XG4gICAgICAgIC8vIFRoZSBwbHVnaW4ncyBuYW1lIGlzIG1hbmRhdG9yeSBhbmQgbXVzdCBiZSB1bmlxdWVcbiAgICAgICAgY29uc3QgcGx1Z2luTmFtZSA9IHBsdWdpbi5uYW1lO1xuICAgICAgICBhc3NlcnQocGx1Z2luTmFtZSwgJ0EgbmFtZSBtdXN0IGJlIHByb3ZpZGVkIGJ5IHRoZSBwbHVnaW4uJyk7XG4gICAgICAgIGlmICghdGhpcy5yZWdpc3RlclBsdWdpbnNbcGx1Z2luTmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJQbHVnaW5zW3BsdWdpbk5hbWVdID0gcGx1Z2luO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5saWZlY3ljbGUpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBwbHVnaW5MaWZlID0gcGx1Z2luW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbkxpZmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saWZlY3ljbGVba2V5XS5vbihwbHVnaW5MaWZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVQbHVnaW4ocGx1Z2luTmFtZSkge1xuICAgICAgICBhc3NlcnQocGx1Z2luTmFtZSwgJ0EgbmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy5yZWdpc3RlclBsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICAgIGFzc2VydChwbHVnaW4sIGBUaGUgcGx1Z2luIFwiJHtwbHVnaW5OYW1lfVwiIGlzIG5vdCByZWdpc3RlcmVkLmApO1xuICAgICAgICBPYmplY3Qua2V5cyhwbHVnaW4pLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICduYW1lJykge1xuICAgICAgICAgICAgICAgIHRoaXMubGlmZWN5Y2xlW2tleV0ucmVtb3ZlKHBsdWdpbltrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgaW5oZXJpdCh7IGxpZmVjeWNsZSwgcmVnaXN0ZXJQbHVnaW5zIH0pIHtcbiAgICAgICAgT2JqZWN0LmtleXMobGlmZWN5Y2xlKS5mb3JFYWNoKChob29rTmFtZSk9PntcbiAgICAgICAgICAgIGFzc2VydCghdGhpcy5saWZlY3ljbGVbaG9va05hbWVdLCBgVGhlIGhvb2sgXCIke2hvb2tOYW1lfVwiIGhhcyBhIGNvbmZsaWN0IGFuZCBjYW5ub3QgYmUgaW5oZXJpdGVkLmApO1xuICAgICAgICAgICAgdGhpcy5saWZlY3ljbGVbaG9va05hbWVdID0gbGlmZWN5Y2xlW2hvb2tOYW1lXTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHJlZ2lzdGVyUGx1Z2lucykuZm9yRWFjaCgocGx1Z2luTmFtZSk9PntcbiAgICAgICAgICAgIGFzc2VydCghdGhpcy5yZWdpc3RlclBsdWdpbnNbcGx1Z2luTmFtZV0sIGBUaGUgcGx1Z2luIFwiJHtwbHVnaW5OYW1lfVwiIGhhcyBhIGNvbmZsaWN0IGFuZCBjYW5ub3QgYmUgaW5oZXJpdGVkLmApO1xuICAgICAgICAgICAgdGhpcy5hcHBseVBsdWdpbihyZWdpc3RlclBsdWdpbnNbcGx1Z2luTmFtZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobGlmZWN5Y2xlKXtcbiAgICAgICAgdGhpcy5yZWdpc3RlclBsdWdpbnMgPSB7fTtcbiAgICAgICAgdGhpcy5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgIHRoaXMubGlmZWN5Y2xlS2V5cyA9IE9iamVjdC5rZXlzKGxpZmVjeWNsZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcyQ1KCkge1xuICAgIF9leHRlbmRzJDUgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2Upe1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMkNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFByZWxvYWRBcmdzKHByZWxvYWRDb25maWcpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMkNSh7XG4gICAgICAgIHJlc291cmNlQ2F0ZWdvcnk6ICdzeW5jJyxcbiAgICAgICAgc2hhcmU6IHRydWUsXG4gICAgICAgIGRlcHNSZW1vdGU6IHRydWUsXG4gICAgICAgIHByZWZldGNoSW50ZXJmYWNlOiBmYWxzZVxuICAgIH0sIHByZWxvYWRDb25maWcpO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJlbG9hZEFyZ3MocmVtb3RlcywgcHJlbG9hZEFyZ3MpIHtcbiAgICByZXR1cm4gcHJlbG9hZEFyZ3MubWFwKChhcmdzKT0+e1xuICAgICAgICBjb25zdCByZW1vdGVJbmZvID0gbWF0Y2hSZW1vdGUocmVtb3RlcywgYXJncy5uYW1lT3JBbGlhcyk7XG4gICAgICAgIGFzc2VydChyZW1vdGVJbmZvLCBgVW5hYmxlIHRvIHByZWxvYWQgJHthcmdzLm5hbWVPckFsaWFzfSBhcyBpdCBpcyBub3QgaW5jbHVkZWQgaW4gJHshcmVtb3RlSW5mbyAmJiBzYWZlVG9TdHJpbmcoe1xuICAgICAgICAgICAgcmVtb3RlSW5mbyxcbiAgICAgICAgICAgIHJlbW90ZXNcbiAgICAgICAgfSl9YCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZW1vdGU6IHJlbW90ZUluZm8sXG4gICAgICAgICAgICBwcmVsb2FkQ29uZmlnOiBkZWZhdWx0UHJlbG9hZEFyZ3MoYXJncylcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByZWxvYWRFeHBvc2VzKGV4cG9zZXMpIHtcbiAgICBpZiAoIWV4cG9zZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3Nlcy5tYXAoKGV4cG9zZSk9PntcbiAgICAgICAgaWYgKGV4cG9zZSA9PT0gJy4nKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3NlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvc2Uuc3RhcnRzV2l0aCgnLi8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9zZS5yZXBsYWNlKCcuLycsICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3NlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJlbG9hZEFzc2V0cyhyZW1vdGVJbmZvLCBob3N0LCBhc3NldHMpIHtcbiAgICBjb25zdCB7IGNzc0Fzc2V0cywganNBc3NldHNXaXRob3V0RW50cnksIGVudHJ5QXNzZXRzIH0gPSBhc3NldHM7XG4gICAgaWYgKGhvc3Qub3B0aW9ucy5pbkJyb3dzZXIpIHtcbiAgICAgICAgZW50cnlBc3NldHMuZm9yRWFjaCgoYXNzZXQpPT57XG4gICAgICAgICAgICBjb25zdCB7IG1vZHVsZUluZm8gfSA9IGFzc2V0O1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gaG9zdC5tb2R1bGVDYWNoZS5nZXQocmVtb3RlSW5mby5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBnZXRSZW1vdGVFbnRyeSh7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUluZm86IG1vZHVsZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0czogbW9kdWxlLnJlbW90ZUVudHJ5RXhwb3J0cyxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2NyaXB0SG9vazogKHVybCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGhvc3QubG9hZGVySG9vay5saWZlY3ljbGUuY3JlYXRlU2NyaXB0LmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RvZG86IG5lZWRzIHJlYWwgZml4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBIVE1MU2NyaXB0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ3NjcmlwdCcgaW4gcmVzIHx8ICd0aW1lb3V0JyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldFJlbW90ZUVudHJ5KHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSW5mbzogbW9kdWxlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlRW50cnlFeHBvcnRzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdEhvb2s6ICh1cmwpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBob3N0LmxvYWRlckhvb2subGlmZWN5Y2xlLmNyZWF0ZVNjcmlwdC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90b2RvOiBuZWVkcyByZWFsIGZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgSFRNTFNjcmlwdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdzY3JpcHQnIGluIHJlcyB8fCAndGltZW91dCcgaW4gcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGNzc0Fzc2V0cy5mb3JFYWNoKChjc3NVcmwpPT57XG4gICAgICAgICAgICBjb25zdCB7IGxpbms6IGNzc0VsLCBuZWVkQXR0YWNoIH0gPSBjcmVhdGVMaW5rKGNzc1VybCwgKCk9Pnt9LCB7XG4gICAgICAgICAgICAgICAgcmVsOiAncHJlbG9hZCcsXG4gICAgICAgICAgICAgICAgYXM6ICdzdHlsZSdcbiAgICAgICAgICAgIH0sICh1cmwpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gaG9zdC5sb2FkZXJIb29rLmxpZmVjeWNsZS5jcmVhdGVMaW5rLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICB1cmxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgSFRNTExpbmtFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmVlZEF0dGFjaCAmJiBmcmFnbWVudC5hcHBlbmRDaGlsZChjc3NFbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBqc0Fzc2V0c1dpdGhvdXRFbnRyeS5mb3JFYWNoKChqc1VybCk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgbGluazogbGlua0VsLCBuZWVkQXR0YWNoIH0gPSBjcmVhdGVMaW5rKGpzVXJsLCAoKT0+e1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgICAgIGFzOiAnc2NyaXB0J1xuICAgICAgICAgICAgfSwgKHVybCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBob3N0LmxvYWRlckhvb2subGlmZWN5Y2xlLmNyZWF0ZUxpbmsuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIHVybFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBIVE1MTGlua0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGlua0VsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMkNCgpIHtcbiAgICBfZXh0ZW5kcyQ0ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzJDQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGFzc2lnblJlbW90ZUluZm8ocmVtb3RlSW5mbywgcmVtb3RlU25hcHNob3QpIHtcbiAgICBpZiAoISgncmVtb3RlRW50cnknIGluIHJlbW90ZVNuYXBzaG90KSB8fCAhcmVtb3RlU25hcHNob3QucmVtb3RlRW50cnkpIHtcbiAgICAgICAgZXJyb3IoYFRoZSBhdHRyaWJ1dGUgcmVtb3RlRW50cnkgb2YgJHtuYW1lfSBtdXN0IG5vdCBiZSB1bmRlZmluZWQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHsgcmVtb3RlRW50cnkgfSA9IHJlbW90ZVNuYXBzaG90O1xuICAgIGNvbnN0IGVudHJ5VXJsID0gZ2V0UmVzb3VyY2VVcmwocmVtb3RlU25hcHNob3QsIHJlbW90ZUVudHJ5KTtcbiAgICByZW1vdGVJbmZvLnR5cGUgPSByZW1vdGVTbmFwc2hvdC5yZW1vdGVFbnRyeVR5cGU7XG4gICAgcmVtb3RlSW5mby5lbnRyeUdsb2JhbE5hbWUgPSByZW1vdGVTbmFwc2hvdC5nbG9iYWxOYW1lO1xuICAgIHJlbW90ZUluZm8uZW50cnkgPSBlbnRyeVVybDtcbiAgICByZW1vdGVJbmZvLnZlcnNpb24gPSByZW1vdGVTbmFwc2hvdC52ZXJzaW9uO1xuICAgIHJlbW90ZUluZm8uYnVpbGRWZXJzaW9uID0gcmVtb3RlU25hcHNob3QuYnVpbGRWZXJzaW9uO1xufVxuZnVuY3Rpb24gc25hcHNob3RQbHVnaW4oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ3NuYXBzaG90LXBsdWdpbicsXG4gICAgICAgIGFzeW5jIGFmdGVyUmVzb2x2ZSAoYXJncykge1xuICAgICAgICAgICAgY29uc3QgeyByZW1vdGUsIHBrZ05hbWVPckFsaWFzLCBleHBvc2UsIG9yaWdpbiwgcmVtb3RlSW5mbyB9ID0gYXJncztcbiAgICAgICAgICAgIGlmICghaXNSZW1vdGVJbmZvV2l0aEVudHJ5KHJlbW90ZSkgfHwgIWlzUHVyZVJlbW90ZUVudHJ5KHJlbW90ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlbW90ZVNuYXBzaG90LCBnbG9iYWxTbmFwc2hvdCB9ID0gYXdhaXQgb3JpZ2luLnNuYXBzaG90SGFuZGxlci5sb2FkUmVtb3RlU25hcHNob3RJbmZvKHJlbW90ZSk7XG4gICAgICAgICAgICAgICAgYXNzaWduUmVtb3RlSW5mbyhyZW1vdGVJbmZvLCByZW1vdGVTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgLy8gcHJlbG9hZGluZyBhc3NldHNcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVsb2FkT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lT3JBbGlhczogcGtnTmFtZU9yQWxpYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VDYXRlZ29yeTogJ3N5bmMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwc1JlbW90ZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzZXRzID0gYXdhaXQgb3JpZ2luLnJlbW90ZUhhbmRsZXIuaG9va3MubGlmZWN5Y2xlLmdlbmVyYXRlUHJlbG9hZEFzc2V0cy5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU25hcHNob3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoYXNzZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWxvYWRBc3NldHMocmVtb3RlSW5mbywgb3JpZ2luLCBhc3NldHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMkNCh7fSwgYXJncywge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBuYW1lXG4vLyBuYW1lOnZlcnNpb25cbmZ1bmN0aW9uIHNwbGl0SWQoaWQpIHtcbiAgICBjb25zdCBzcGxpdEluZm8gPSBpZC5zcGxpdCgnOicpO1xuICAgIGlmIChzcGxpdEluZm8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBzcGxpdEluZm9bMF0sXG4gICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHNwbGl0SW5mby5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHNwbGl0SW5mb1swXSxcbiAgICAgICAgICAgIHZlcnNpb246IHNwbGl0SW5mb1sxXVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBzcGxpdEluZm9bMV0sXG4gICAgICAgICAgICB2ZXJzaW9uOiBzcGxpdEluZm9bMl1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyBUcmF2ZXJzZSBhbGwgbm9kZXMgaW4gbW9kdWxlSW5mbyBhbmQgdHJhdmVyc2UgdGhlIGVudGlyZSBzbmFwc2hvdFxuZnVuY3Rpb24gdHJhdmVyc2VNb2R1bGVJbmZvKGdsb2JhbFNuYXBzaG90LCByZW1vdGVJbmZvLCB0cmF2ZXJzZSwgaXNSb290LCBtZW1vID0ge30sIHJlbW90ZVNuYXBzaG90KSB7XG4gICAgY29uc3QgaWQgPSBnZXRGTUlkKHJlbW90ZUluZm8pO1xuICAgIGNvbnN0IHsgdmFsdWU6IHNuYXBzaG90VmFsdWUgfSA9IGdldEluZm9XaXRob3V0VHlwZShnbG9iYWxTbmFwc2hvdCwgaWQpO1xuICAgIGNvbnN0IGVmZmVjdGl2ZVJlbW90ZVNuYXBzaG90ID0gcmVtb3RlU25hcHNob3QgfHwgc25hcHNob3RWYWx1ZTtcbiAgICBpZiAoZWZmZWN0aXZlUmVtb3RlU25hcHNob3QgJiYgIWlzTWFuaWZlc3RQcm92aWRlcihlZmZlY3RpdmVSZW1vdGVTbmFwc2hvdCkpIHtcbiAgICAgICAgdHJhdmVyc2UoZWZmZWN0aXZlUmVtb3RlU25hcHNob3QsIHJlbW90ZUluZm8sIGlzUm9vdCk7XG4gICAgICAgIGlmIChlZmZlY3RpdmVSZW1vdGVTbmFwc2hvdC5yZW1vdGVzSW5mbykge1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlS2V5cyA9IE9iamVjdC5rZXlzKGVmZmVjdGl2ZVJlbW90ZVNuYXBzaG90LnJlbW90ZXNJbmZvKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJlbW90ZUtleXMpe1xuICAgICAgICAgICAgICAgIGlmIChtZW1vW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViUmVtb3RlSW5mbyA9IHNwbGl0SWQoa2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVWYWx1ZSA9IGVmZmVjdGl2ZVJlbW90ZVNuYXBzaG90LnJlbW90ZXNJbmZvW2tleV07XG4gICAgICAgICAgICAgICAgdHJhdmVyc2VNb2R1bGVJbmZvKGdsb2JhbFNuYXBzaG90LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHN1YlJlbW90ZUluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogcmVtb3RlVmFsdWUubWF0Y2hlZFZlcnNpb25cbiAgICAgICAgICAgICAgICB9LCB0cmF2ZXJzZSwgZmFsc2UsIG1lbW8sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxpbmVzLXBlci1mdW5jdGlvblxuZnVuY3Rpb24gZ2VuZXJhdGVQcmVsb2FkQXNzZXRzKG9yaWdpbiwgcHJlbG9hZE9wdGlvbnMsIHJlbW90ZSwgZ2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90KSB7XG4gICAgY29uc3QgY3NzQXNzZXRzID0gW107XG4gICAgY29uc3QganNBc3NldHMgPSBbXTtcbiAgICBjb25zdCBlbnRyeUFzc2V0cyA9IFtdO1xuICAgIGNvbnN0IGxvYWRlZFNoYXJlZEpzQXNzZXRzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGxvYWRlZFNoYXJlZENzc0Fzc2V0cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IG9yaWdpbjtcbiAgICBjb25zdCB7IHByZWxvYWRDb25maWc6IHJvb3RQcmVsb2FkQ29uZmlnIH0gPSBwcmVsb2FkT3B0aW9ucztcbiAgICBjb25zdCB7IGRlcHNSZW1vdGUgfSA9IHJvb3RQcmVsb2FkQ29uZmlnO1xuICAgIGNvbnN0IG1lbW8gPSB7fTtcbiAgICB0cmF2ZXJzZU1vZHVsZUluZm8oZ2xvYmFsU25hcHNob3QsIHJlbW90ZSwgKG1vZHVsZUluZm9TbmFwc2hvdCwgcmVtb3RlSW5mbywgaXNSb290KT0+e1xuICAgICAgICBsZXQgcHJlbG9hZENvbmZpZztcbiAgICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICAgICAgcHJlbG9hZENvbmZpZyA9IHJvb3RQcmVsb2FkQ29uZmlnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVwc1JlbW90ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICAgICAgICAgICAgY29uc3QgZmluZFByZWxvYWRDb25maWcgPSBkZXBzUmVtb3RlLmZpbmQoKHJlbW90ZUNvbmZpZyk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW90ZUNvbmZpZy5uYW1lT3JBbGlhcyA9PT0gcmVtb3RlSW5mby5uYW1lIHx8IHJlbW90ZUNvbmZpZy5uYW1lT3JBbGlhcyA9PT0gcmVtb3RlSW5mby5hbGlhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghZmluZFByZWxvYWRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmVsb2FkQ29uZmlnID0gZGVmYXVsdFByZWxvYWRBcmdzKGZpbmRQcmVsb2FkQ29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwc1JlbW90ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHByZWxvYWRDb25maWcgPSByb290UHJlbG9hZENvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbW90ZUVudHJ5VXJsID0gZ2V0UmVzb3VyY2VVcmwobW9kdWxlSW5mb1NuYXBzaG90LCAncmVtb3RlRW50cnknIGluIG1vZHVsZUluZm9TbmFwc2hvdCA/IG1vZHVsZUluZm9TbmFwc2hvdC5yZW1vdGVFbnRyeSA6ICcnKTtcbiAgICAgICAgaWYgKHJlbW90ZUVudHJ5VXJsKSB7XG4gICAgICAgICAgICBlbnRyeUFzc2V0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiByZW1vdGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgbW9kdWxlSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiByZW1vdGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5OiByZW1vdGVFbnRyeVVybCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3JlbW90ZUVudHJ5VHlwZScgaW4gbW9kdWxlSW5mb1NuYXBzaG90ID8gbW9kdWxlSW5mb1NuYXBzaG90LnJlbW90ZUVudHJ5VHlwZSA6ICdnbG9iYWwnLFxuICAgICAgICAgICAgICAgICAgICBlbnRyeUdsb2JhbE5hbWU6ICdnbG9iYWxOYW1lJyBpbiBtb2R1bGVJbmZvU25hcHNob3QgPyBtb2R1bGVJbmZvU25hcHNob3QuZ2xvYmFsTmFtZSA6IHJlbW90ZUluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVTY29wZTogJycsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246ICd2ZXJzaW9uJyBpbiBtb2R1bGVJbmZvU25hcHNob3QgPyBtb2R1bGVJbmZvU25hcHNob3QudmVyc2lvbiA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdXJsOiByZW1vdGVFbnRyeVVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1vZHVsZUFzc2V0c0luZm8gPSAnbW9kdWxlcycgaW4gbW9kdWxlSW5mb1NuYXBzaG90ID8gbW9kdWxlSW5mb1NuYXBzaG90Lm1vZHVsZXMgOiBbXTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFByZWxvYWRFeHBvc2VzID0gbm9ybWFsaXplUHJlbG9hZEV4cG9zZXMocHJlbG9hZENvbmZpZy5leHBvc2VzKTtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcmVsb2FkRXhwb3Nlcy5sZW5ndGggJiYgJ21vZHVsZXMnIGluIG1vZHVsZUluZm9TbmFwc2hvdCkge1xuICAgICAgICAgICAgdmFyIF9tb2R1bGVJbmZvU25hcHNob3RfbW9kdWxlcztcbiAgICAgICAgICAgIG1vZHVsZUFzc2V0c0luZm8gPSBtb2R1bGVJbmZvU25hcHNob3QgPT0gbnVsbCA/IHZvaWQgMCA6IChfbW9kdWxlSW5mb1NuYXBzaG90X21vZHVsZXMgPSBtb2R1bGVJbmZvU25hcHNob3QubW9kdWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9tb2R1bGVJbmZvU25hcHNob3RfbW9kdWxlcy5yZWR1Y2UoKGFzc2V0cywgbW9kdWxlQXNzZXRJbmZvKT0+e1xuICAgICAgICAgICAgICAgIGlmICgobm9ybWFsaXplZFByZWxvYWRFeHBvc2VzID09IG51bGwgPyB2b2lkIDAgOiBub3JtYWxpemVkUHJlbG9hZEV4cG9zZXMuaW5kZXhPZihtb2R1bGVBc3NldEluZm8ubW9kdWxlTmFtZSkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NldHMucHVzaChtb2R1bGVBc3NldEluZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzZXRzO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUFzc2V0cyhhc3NldHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0c1JlcyA9IGFzc2V0cy5tYXAoKGFzc2V0KT0+Z2V0UmVzb3VyY2VVcmwobW9kdWxlSW5mb1NuYXBzaG90LCBhc3NldCkpO1xuICAgICAgICAgICAgaWYgKHByZWxvYWRDb25maWcuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzc2V0c1Jlcy5maWx0ZXIocHJlbG9hZENvbmZpZy5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFzc2V0c1JlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kdWxlQXNzZXRzSW5mbykge1xuICAgICAgICAgICAgY29uc3QgYXNzZXRzTGVuZ3RoID0gbW9kdWxlQXNzZXRzSW5mby5sZW5ndGg7XG4gICAgICAgICAgICBmb3IobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhc3NldHNMZW5ndGg7IGluZGV4Kyspe1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzc2V0c0luZm8gPSBtb2R1bGVBc3NldHNJbmZvW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBvc2VGdWxsUGF0aCA9IGAke3JlbW90ZUluZm8ubmFtZX0vJHthc3NldHNJbmZvLm1vZHVsZU5hbWV9YDtcbiAgICAgICAgICAgICAgICBvcmlnaW4ucmVtb3RlSGFuZGxlci5ob29rcy5saWZlY3ljbGUuaGFuZGxlUHJlbG9hZE1vZHVsZS5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGFzc2V0c0luZm8ubW9kdWxlTmFtZSA9PT0gJy4nID8gcmVtb3RlSW5mby5uYW1lIDogZXhwb3NlRnVsbFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHJlbW90ZUluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3Q6IG1vZHVsZUluZm9TbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlOiByZW1vdGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVsb2FkZWQgPSBnZXRQcmVsb2FkZWQoZXhwb3NlRnVsbFBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVsb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmVsb2FkQ29uZmlnLnJlc291cmNlQ2F0ZWdvcnkgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzc0Fzc2V0cy5wdXNoKC4uLmhhbmRsZUFzc2V0cyhhc3NldHNJbmZvLmFzc2V0cy5jc3MuYXN5bmMpKTtcbiAgICAgICAgICAgICAgICAgICAgY3NzQXNzZXRzLnB1c2goLi4uaGFuZGxlQXNzZXRzKGFzc2V0c0luZm8uYXNzZXRzLmNzcy5zeW5jKSk7XG4gICAgICAgICAgICAgICAgICAgIGpzQXNzZXRzLnB1c2goLi4uaGFuZGxlQXNzZXRzKGFzc2V0c0luZm8uYXNzZXRzLmpzLmFzeW5jKSk7XG4gICAgICAgICAgICAgICAgICAgIGpzQXNzZXRzLnB1c2goLi4uaGFuZGxlQXNzZXRzKGFzc2V0c0luZm8uYXNzZXRzLmpzLnN5bmMpKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVsb2FkQ29uZmlnLnJlc291cmNlQ2F0ZWdvcnkgPSAnc3luYycpIHtcbiAgICAgICAgICAgICAgICAgICAgY3NzQXNzZXRzLnB1c2goLi4uaGFuZGxlQXNzZXRzKGFzc2V0c0luZm8uYXNzZXRzLmNzcy5zeW5jKSk7XG4gICAgICAgICAgICAgICAgICAgIGpzQXNzZXRzLnB1c2goLi4uaGFuZGxlQXNzZXRzKGFzc2V0c0luZm8uYXNzZXRzLmpzLnN5bmMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0UHJlbG9hZGVkKGV4cG9zZUZ1bGxQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHRydWUsIG1lbW8sIHJlbW90ZVNuYXBzaG90KTtcbiAgICBpZiAocmVtb3RlU25hcHNob3Quc2hhcmVkKSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3RTaGFyZWRBc3NldHMgPSAoc2hhcmVJbmZvLCBzbmFwc2hvdFNoYXJlZCk9PntcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRTaGFyZWQgPSBnZXRSZWdpc3RlcmVkU2hhcmUob3JpZ2luLnNoYXJlU2NvcGVNYXAsIHNuYXBzaG90U2hhcmVkLnNoYXJlZE5hbWUsIHNoYXJlSW5mbywgb3JpZ2luLnNoYXJlZEhhbmRsZXIuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZ2xvYmFsIHNoYXJlIGRvZXMgbm90IGV4aXN0LCBvciB0aGUgbGliIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0LCBpdCBtZWFucyB0aGF0IHRoZSBzaGFyZWQgaGFzIG5vdCBiZWVuIGxvYWRlZCB5ZXQgYW5kIGNhbiBiZSBwcmVsb2FkZWQuXG4gICAgICAgICAgICBpZiAocmVnaXN0ZXJlZFNoYXJlZCAmJiB0eXBlb2YgcmVnaXN0ZXJlZFNoYXJlZC5saWIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzbmFwc2hvdFNoYXJlZC5hc3NldHMuanMuc3luYy5mb3JFYWNoKChhc3NldCk9PntcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkU2hhcmVkSnNBc3NldHMuYWRkKGFzc2V0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzbmFwc2hvdFNoYXJlZC5hc3NldHMuY3NzLnN5bmMuZm9yRWFjaCgoYXNzZXQpPT57XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZFNoYXJlZENzc0Fzc2V0cy5hZGQoYXNzZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZW1vdGVTbmFwc2hvdC5zaGFyZWQuZm9yRWFjaCgoc2hhcmVkKT0+e1xuICAgICAgICAgICAgdmFyIF9vcHRpb25zX3NoYXJlZDtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlSW5mb3MgPSAoX29wdGlvbnNfc2hhcmVkID0gb3B0aW9ucy5zaGFyZWQpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0aW9uc19zaGFyZWRbc2hhcmVkLnNoYXJlZE5hbWVdO1xuICAgICAgICAgICAgaWYgKCFzaGFyZUluZm9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgbm8gdmVyc2lvbiwgcHJlbG9hZCBhbGwgc2hhcmVkXG4gICAgICAgICAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gc2hhcmVkLnZlcnNpb24gPyBzaGFyZUluZm9zLmZpbmQoKHMpPT5zLnZlcnNpb24gPT09IHNoYXJlZC52ZXJzaW9uKSA6IHNoYXJlSW5mb3M7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcnJheVNoYXJlSW5mbyA9IGFycmF5T3B0aW9ucyhzaGFyZWRPcHRpb25zKTtcbiAgICAgICAgICAgIGFycmF5U2hhcmVJbmZvLmZvckVhY2goKHMpPT57XG4gICAgICAgICAgICAgICAgY29sbGVjdFNoYXJlZEFzc2V0cyhzLCBzaGFyZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBuZWVkUHJlbG9hZEpzQXNzZXRzID0ganNBc3NldHMuZmlsdGVyKChhc3NldCk9PiFsb2FkZWRTaGFyZWRKc0Fzc2V0cy5oYXMoYXNzZXQpKTtcbiAgICBjb25zdCBuZWVkUHJlbG9hZENzc0Fzc2V0cyA9IGNzc0Fzc2V0cy5maWx0ZXIoKGFzc2V0KT0+IWxvYWRlZFNoYXJlZENzc0Fzc2V0cy5oYXMoYXNzZXQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjc3NBc3NldHM6IG5lZWRQcmVsb2FkQ3NzQXNzZXRzLFxuICAgICAgICBqc0Fzc2V0c1dpdGhvdXRFbnRyeTogbmVlZFByZWxvYWRKc0Fzc2V0cyxcbiAgICAgICAgZW50cnlBc3NldHNcbiAgICB9O1xufVxuY29uc3QgZ2VuZXJhdGVQcmVsb2FkQXNzZXRzUGx1Z2luID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ2dlbmVyYXRlLXByZWxvYWQtYXNzZXRzLXBsdWdpbicsXG4gICAgICAgIGFzeW5jIGdlbmVyYXRlUHJlbG9hZEFzc2V0cyAoYXJncykge1xuICAgICAgICAgICAgY29uc3QgeyBvcmlnaW4sIHByZWxvYWRPcHRpb25zLCByZW1vdGVJbmZvLCByZW1vdGUsIGdsb2JhbFNuYXBzaG90LCByZW1vdGVTbmFwc2hvdCB9ID0gYXJncztcbiAgICAgICAgICAgIGlmIChpc1JlbW90ZUluZm9XaXRoRW50cnkocmVtb3RlKSAmJiBpc1B1cmVSZW1vdGVFbnRyeShyZW1vdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY3NzQXNzZXRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAganNBc3NldHNXaXRob3V0RW50cnk6IFtdLFxuICAgICAgICAgICAgICAgICAgICBlbnRyeUFzc2V0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHJlbW90ZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogcmVtb3RlLmVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZUluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcmVtb3RlSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeTogcmVtb3RlLmVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZ2xvYmFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlHbG9iYWxOYW1lOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVTY29wZTogJydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzaWduUmVtb3RlSW5mbyhyZW1vdGVJbmZvLCByZW1vdGVTbmFwc2hvdCk7XG4gICAgICAgICAgICBjb25zdCBhc3NldHMgPSBnZW5lcmF0ZVByZWxvYWRBc3NldHMob3JpZ2luLCBwcmVsb2FkT3B0aW9ucywgcmVtb3RlSW5mbywgZ2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90KTtcbiAgICAgICAgICAgIHJldHVybiBhc3NldHM7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuZnVuY3Rpb24gX2V4dGVuZHMkMygpIHtcbiAgICBfZXh0ZW5kcyQzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzJDMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmNsYXNzIFNuYXBzaG90SGFuZGxlciB7XG4gICAgYXN5bmMgbG9hZFNuYXBzaG90KG1vZHVsZUluZm8pIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLkhvc3RJbnN0YW5jZTtcbiAgICAgICAgY29uc3QgeyBob3N0R2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90LCBnbG9iYWxTbmFwc2hvdCB9ID0gdGhpcy5nZXRHbG9iYWxSZW1vdGVJbmZvKG1vZHVsZUluZm8pO1xuICAgICAgICBjb25zdCB7IHJlbW90ZVNuYXBzaG90OiBnbG9iYWxSZW1vdGVTbmFwc2hvdCwgZ2xvYmFsU25hcHNob3Q6IGdsb2JhbFNuYXBzaG90UmVzIH0gPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5sb2FkU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbW9kdWxlSW5mbyxcbiAgICAgICAgICAgIGhvc3RHbG9iYWxTbmFwc2hvdCxcbiAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90LFxuICAgICAgICAgICAgZ2xvYmFsU25hcHNob3RcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogZ2xvYmFsUmVtb3RlU25hcHNob3QsXG4gICAgICAgICAgICBnbG9iYWxTbmFwc2hvdDogZ2xvYmFsU25hcHNob3RSZXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1saW5lcy1wZXItZnVuY3Rpb25cbiAgICBhc3luYyBsb2FkUmVtb3RlU25hcHNob3RJbmZvKG1vZHVsZUluZm8pIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLkhvc3RJbnN0YW5jZTtcbiAgICAgICAgYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuYmVmb3JlTG9hZFJlbW90ZVNuYXBzaG90LmVtaXQoe1xuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG1vZHVsZUluZm9cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBob3N0U25hcHNob3QgPSBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oe1xuICAgICAgICAgICAgbmFtZTogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgdmVyc2lvbjogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy52ZXJzaW9uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWhvc3RTbmFwc2hvdCkge1xuICAgICAgICAgICAgaG9zdFNuYXBzaG90ID0ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IHRoaXMuSG9zdEluc3RhbmNlLm9wdGlvbnMudmVyc2lvbiB8fCAnJyxcbiAgICAgICAgICAgICAgICByZW1vdGVFbnRyeTogJycsXG4gICAgICAgICAgICAgICAgcmVtb3Rlc0luZm86IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWRkR2xvYmFsU25hcHNob3Qoe1xuICAgICAgICAgICAgICAgIFt0aGlzLkhvc3RJbnN0YW5jZS5vcHRpb25zLm5hbWVdOiBob3N0U25hcHNob3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIGR5bmFtaWMgbG9hZFJlbW90ZSBzY2VuYXJpb3MsIGluY29tcGxldGUgcmVtb3Rlc0luZm8gZGVsaXZlcnkgbWF5IG9jY3VyLiBJbiBzdWNoIGNhc2VzLCB0aGUgcmVtb3Rlc0luZm8gaW4gdGhlIGhvc3QgbmVlZHMgdG8gYmUgY29tcGxldGVkIGluIHRoZSBzbmFwc2hvdCBhdCBydW50aW1lLlxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIHNuYXBzaG90J3MgaW50ZWdyaXR5IGFuZCBoZWxwcyB0aGUgY2hyb21lIHBsdWdpbiBjb3JyZWN0bHkgaWRlbnRpZnkgYWxsIHByb2R1Y2VyIG1vZHVsZXMsIGVuc3VyaW5nIHRoYXQgcHJveHlhYmxlIHByb2R1Y2VyIG1vZHVsZXMgd2lsbCBub3QgYmUgbWlzc2luZy5cbiAgICAgICAgaWYgKGhvc3RTbmFwc2hvdCAmJiAncmVtb3Rlc0luZm8nIGluIGhvc3RTbmFwc2hvdCAmJiAhZ2V0SW5mb1dpdGhvdXRUeXBlKGhvc3RTbmFwc2hvdC5yZW1vdGVzSW5mbywgbW9kdWxlSW5mby5uYW1lKS52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCd2ZXJzaW9uJyBpbiBtb2R1bGVJbmZvIHx8ICdlbnRyeScgaW4gbW9kdWxlSW5mbykge1xuICAgICAgICAgICAgICAgIGhvc3RTbmFwc2hvdC5yZW1vdGVzSW5mbyA9IF9leHRlbmRzJDMoe30sIGhvc3RTbmFwc2hvdCA9PSBudWxsID8gdm9pZCAwIDogaG9zdFNuYXBzaG90LnJlbW90ZXNJbmZvLCB7XG4gICAgICAgICAgICAgICAgICAgIFttb2R1bGVJbmZvLm5hbWVdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbjogJ3ZlcnNpb24nIGluIG1vZHVsZUluZm8gPyBtb2R1bGVJbmZvLnZlcnNpb24gOiBtb2R1bGVJbmZvLmVudHJ5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGhvc3RHbG9iYWxTbmFwc2hvdCwgcmVtb3RlU25hcHNob3QsIGdsb2JhbFNuYXBzaG90IH0gPSB0aGlzLmdldEdsb2JhbFJlbW90ZUluZm8obW9kdWxlSW5mbyk7XG4gICAgICAgIGNvbnN0IHsgcmVtb3RlU25hcHNob3Q6IGdsb2JhbFJlbW90ZVNuYXBzaG90LCBnbG9iYWxTbmFwc2hvdDogZ2xvYmFsU25hcHNob3RSZXMgfSA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmxvYWRTbmFwc2hvdC5lbWl0KHtcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtb2R1bGVJbmZvLFxuICAgICAgICAgICAgaG9zdEdsb2JhbFNuYXBzaG90LFxuICAgICAgICAgICAgcmVtb3RlU25hcHNob3QsXG4gICAgICAgICAgICBnbG9iYWxTbmFwc2hvdFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZ2xvYmFsIHNuYXBzaG90IGluY2x1ZGVzIG1hbmlmZXN0IG9yIG1vZHVsZSBpbmZvIGluY2x1ZGVzIG1hbmlmZXN0XG4gICAgICAgIGlmIChnbG9iYWxSZW1vdGVTbmFwc2hvdCkge1xuICAgICAgICAgICAgaWYgKGlzTWFuaWZlc3RQcm92aWRlcihnbG9iYWxSZW1vdGVTbmFwc2hvdCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGVTbmFwc2hvdCA9IGF3YWl0IHRoaXMuZ2V0TWFuaWZlc3RKc29uKGdsb2JhbFJlbW90ZVNuYXBzaG90LnJlbW90ZUVudHJ5LCBtb2R1bGVJbmZvLCB7fSk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgICAgICAgICAgICAgICBjb25zdCBnbG9iYWxTbmFwc2hvdFJlcyA9IHNldEdsb2JhbFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyhfZXh0ZW5kcyQzKHt9LCBtb2R1bGVJbmZvLCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBnbG9iYWwgcmVtb3RlIG1heSBiZSBvdmVycmlkZGVuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlZm9yZSwgc2V0IHRoZSBzbmFwc2hvdCBrZXkgdG8gdGhlIGdsb2JhbCBhZGRyZXNzIG9mIHRoZSBhY3R1YWwgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICBlbnRyeTogZ2xvYmFsUmVtb3RlU25hcHNob3QucmVtb3RlRW50cnlcbiAgICAgICAgICAgICAgICB9KSwgbW9kdWxlU25hcHNob3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiBtb2R1bGVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU25hcHNob3Q6IGdsb2JhbFNuYXBzaG90UmVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZW1vdGVTbmFwc2hvdDogcmVtb3RlU25hcHNob3RSZXMgfSA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmxvYWRSZW1vdGVTbmFwc2hvdC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3Q6IGdsb2JhbFJlbW90ZVNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiAnZ2xvYmFsJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiByZW1vdGVTbmFwc2hvdFJlcyxcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU25hcHNob3Q6IGdsb2JhbFNuYXBzaG90UmVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1JlbW90ZUluZm9XaXRoRW50cnkobW9kdWxlSW5mbykpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgZnJvbSBtYW5pZmVzdC5qc29uIGFuZCBtZXJnZSByZW1vdGUgaW5mbyBmcm9tIHJlbW90ZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGVTbmFwc2hvdCA9IGF3YWl0IHRoaXMuZ2V0TWFuaWZlc3RKc29uKG1vZHVsZUluZm8uZW50cnksIG1vZHVsZUluZm8sIHt9KTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgICAgICAgICAgICAgIGNvbnN0IGdsb2JhbFNuYXBzaG90UmVzID0gc2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvKG1vZHVsZUluZm8sIG1vZHVsZVNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlbW90ZVNuYXBzaG90OiByZW1vdGVTbmFwc2hvdFJlcyB9ID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUubG9hZFJlbW90ZVNuYXBzaG90LmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB0aGlzLkhvc3RJbnN0YW5jZS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogbW9kdWxlU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgIGZyb206ICdnbG9iYWwnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3Q6IHJlbW90ZVNuYXBzaG90UmVzLFxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxTbmFwc2hvdDogZ2xvYmFsU25hcHNob3RSZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvcihgXG4gICAgICAgICAgQ2Fubm90IGdldCByZW1vdGVTbmFwc2hvdCB3aXRoIHRoZSBuYW1lOiAnJHttb2R1bGVJbmZvLm5hbWV9JywgdmVyc2lvbjogJyR7bW9kdWxlSW5mby52ZXJzaW9ufScgZnJvbSBfX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvLiBUaGUgZm9sbG93aW5nIHJlYXNvbnMgbWF5IGJlIGNhdXNpbmcgdGhlIHByb2JsZW06XFxuXG4gICAgICAgICAgMS4gVGhlIERlcGxveSBwbGF0Zm9ybSBkaWQgbm90IGRlbGl2ZXIgdGhlIGNvcnJlY3QgZGF0YS4gWW91IGNhbiB1c2UgX19GRURFUkFUSU9OX18ubW9kdWxlSW5mbyB0byBjaGVjayB0aGUgcmVtb3RlSW5mby5cXG5cbiAgICAgICAgICAyLiBUaGUgcmVtb3RlICcke21vZHVsZUluZm8ubmFtZX0nIHZlcnNpb24gJyR7bW9kdWxlSW5mby52ZXJzaW9ufScgaXMgbm90IHJlbGVhc2VkLlxcblxuICAgICAgICAgIFRoZSB0cmFuc2Zvcm1lZCBtb2R1bGUgaW5mbzogJHtKU09OLnN0cmluZ2lmeShnbG9iYWxTbmFwc2hvdFJlcyl9XG4gICAgICAgIGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldEdsb2JhbFJlbW90ZUluZm8obW9kdWxlSW5mbykge1xuICAgICAgICBjb25zdCBob3N0R2xvYmFsU25hcHNob3QgPSBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oe1xuICAgICAgICAgICAgbmFtZTogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgdmVyc2lvbjogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy52ZXJzaW9uXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBnZXQgcmVtb3RlIGRldGFpbCBpbmZvIGZyb20gZ2xvYmFsXG4gICAgICAgIGNvbnN0IGdsb2JhbFJlbW90ZUluZm8gPSBob3N0R2xvYmFsU25hcHNob3QgJiYgJ3JlbW90ZXNJbmZvJyBpbiBob3N0R2xvYmFsU25hcHNob3QgJiYgaG9zdEdsb2JhbFNuYXBzaG90LnJlbW90ZXNJbmZvICYmIGdldEluZm9XaXRob3V0VHlwZShob3N0R2xvYmFsU25hcHNob3QucmVtb3Rlc0luZm8sIG1vZHVsZUluZm8ubmFtZSkudmFsdWU7XG4gICAgICAgIGlmIChnbG9iYWxSZW1vdGVJbmZvICYmIGdsb2JhbFJlbW90ZUluZm8ubWF0Y2hlZFZlcnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaG9zdEdsb2JhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgIGdsb2JhbFNuYXBzaG90OiBnZXRHbG9iYWxTbmFwc2hvdCgpLFxuICAgICAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBtb2R1bGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246IGdsb2JhbFJlbW90ZUluZm8ubWF0Y2hlZFZlcnNpb25cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG9zdEdsb2JhbFNuYXBzaG90OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBnbG9iYWxTbmFwc2hvdDogZ2V0R2xvYmFsU25hcHNob3QoKSxcbiAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oe1xuICAgICAgICAgICAgICAgIG5hbWU6IG1vZHVsZUluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAndmVyc2lvbicgaW4gbW9kdWxlSW5mbyA/IG1vZHVsZUluZm8udmVyc2lvbiA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWFuaWZlc3RKc29uKG1hbmlmZXN0VXJsLCBtb2R1bGVJbmZvLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZ2V0TWFuaWZlc3QgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgbGV0IG1hbmlmZXN0SnNvbiA9IHRoaXMubWFuaWZlc3RDYWNoZS5nZXQobWFuaWZlc3RVcmwpO1xuICAgICAgICAgICAgaWYgKG1hbmlmZXN0SnNvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdEpzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXMgPSBhd2FpdCB0aGlzLmxvYWRlckhvb2subGlmZWN5Y2xlLmZldGNoLmVtaXQobWFuaWZlc3RVcmwsIHt9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcyB8fCAhKHJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBmZXRjaChtYW5pZmVzdFVybCwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYW5pZmVzdEpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICAgICAgICAgIGFzc2VydChtYW5pZmVzdEpzb24ubWV0YURhdGEgJiYgbWFuaWZlc3RKc29uLmV4cG9zZXMgJiYgbWFuaWZlc3RKc29uLnNoYXJlZCwgYCR7bWFuaWZlc3RVcmx9IGlzIG5vdCBhIGZlZGVyYXRpb24gbWFuaWZlc3RgKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0Q2FjaGUuc2V0KG1hbmlmZXN0VXJsLCBtYW5pZmVzdEpzb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdEpzb247XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihgRmFpbGVkIHRvIGdldCBtYW5pZmVzdEpzb24gZm9yICR7bW9kdWxlSW5mby5uYW1lfS4gVGhlIG1hbmlmZXN0IFVSTCBpcyAke21hbmlmZXN0VXJsfS4gUGxlYXNlIGVuc3VyZSB0aGF0IHRoZSBtYW5pZmVzdFVybCBpcyBhY2Nlc3NpYmxlLlxuICAgICAgICAgIFxcbiBFcnJvciBtZXNzYWdlOlxuICAgICAgICAgIFxcbiAke2Vycn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXN5bmNMb2FkUHJvY2VzcyA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICBjb25zdCBtYW5pZmVzdEpzb24gPSBhd2FpdCBnZXRNYW5pZmVzdCgpO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlU25hcHNob3QgPSBnZW5lcmF0ZVNuYXBzaG90RnJvbU1hbmlmZXN0KG1hbmlmZXN0SnNvbiwge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IG1hbmlmZXN0VXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVtb3RlU25hcHNob3Q6IHJlbW90ZVNuYXBzaG90UmVzIH0gPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5sb2FkUmVtb3RlU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3B0aW9uczogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtb2R1bGVJbmZvLFxuICAgICAgICAgICAgICAgIG1hbmlmZXN0SnNvbixcbiAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICBtYW5pZmVzdFVybCxcbiAgICAgICAgICAgICAgICBmcm9tOiAnbWFuaWZlc3QnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZW1vdGVTbmFwc2hvdFJlcztcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLm1hbmlmZXN0TG9hZGluZ1ttYW5pZmVzdFVybF0pIHtcbiAgICAgICAgICAgIHRoaXMubWFuaWZlc3RMb2FkaW5nW21hbmlmZXN0VXJsXSA9IGFzeW5jTG9hZFByb2Nlc3MoKS50aGVuKChyZXMpPT5yZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hbmlmZXN0TG9hZGluZ1ttYW5pZmVzdFVybF07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKEhvc3RJbnN0YW5jZSl7XG4gICAgICAgIHRoaXMubG9hZGluZ0hvc3RTbmFwc2hvdCA9IG51bGw7XG4gICAgICAgIHRoaXMubWFuaWZlc3RDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5ob29rcyA9IG5ldyBQbHVnaW5TeXN0ZW0oe1xuICAgICAgICAgICAgYmVmb3JlTG9hZFJlbW90ZVNuYXBzaG90OiBuZXcgQXN5bmNIb29rKCdiZWZvcmVMb2FkUmVtb3RlU25hcHNob3QnKSxcbiAgICAgICAgICAgIGxvYWRTbmFwc2hvdDogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vaygnbG9hZEdsb2JhbFNuYXBzaG90JyksXG4gICAgICAgICAgICBsb2FkUmVtb3RlU25hcHNob3Q6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2xvYWRSZW1vdGVTbmFwc2hvdCcpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hbmlmZXN0TG9hZGluZyA9IEdsb2JhbC5fX0ZFREVSQVRJT05fXy5fX01BTklGRVNUX0xPQURJTkdfXztcbiAgICAgICAgdGhpcy5Ib3N0SW5zdGFuY2UgPSBIb3N0SW5zdGFuY2U7XG4gICAgICAgIHRoaXMubG9hZGVySG9vayA9IEhvc3RJbnN0YW5jZS5sb2FkZXJIb29rO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMkMigpIHtcbiAgICBfZXh0ZW5kcyQyID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzJDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG4gICAgZm9yKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jbGFzcyBTaGFyZWRIYW5kbGVyIHtcbiAgICAvLyByZWdpc3RlciBzaGFyZWQgaW4gc2hhcmVTY29wZU1hcFxuICAgIHJlZ2lzdGVyU2hhcmVkKGdsb2JhbE9wdGlvbnMsIHVzZXJPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgc2hhcmVJbmZvcywgc2hhcmVkIH0gPSBmb3JtYXRTaGFyZUNvbmZpZ3MoZ2xvYmFsT3B0aW9ucywgdXNlck9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzaGFyZWRLZXlzID0gT2JqZWN0LmtleXMoc2hhcmVJbmZvcyk7XG4gICAgICAgIHNoYXJlZEtleXMuZm9yRWFjaCgoc2hhcmVkS2V5KT0+e1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFscyA9IHNoYXJlSW5mb3Nbc2hhcmVkS2V5XTtcbiAgICAgICAgICAgIHNoYXJlZFZhbHMuZm9yRWFjaCgoc2hhcmVkVmFsKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRTaGFyZWQgPSBnZXRSZWdpc3RlcmVkU2hhcmUodGhpcy5zaGFyZVNjb3BlTWFwLCBzaGFyZWRLZXksIHNoYXJlZFZhbCwgdGhpcy5ob29rcy5saWZlY3ljbGUucmVzb2x2ZVNoYXJlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2lzdGVyZWRTaGFyZWQgJiYgc2hhcmVkVmFsICYmIHNoYXJlZFZhbC5saWIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTaGFyZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGtnTmFtZTogc2hhcmVkS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGliOiBzaGFyZWRWYWwubGliLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBzaGFyZWRWYWwuZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkOiBzaGFyZWRWYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB1c2VyT3B0aW9ucy5uYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNoYXJlSW5mb3MsXG4gICAgICAgICAgICBzaGFyZWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgbG9hZFNoYXJlKHBrZ05hbWUsIGV4dHJhT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXMgdGhlIGZvbGxvd2luZyBzdGVwczpcbiAgICAgICAgLy8gMS4gQ2hlY2tzIGlmIHRoZSBjdXJyZW50bHkgbG9hZGVkIHNoYXJlIGFscmVhZHkgZXhpc3RzLCBpZiBub3QsIGl0IHRocm93cyBhbiBlcnJvclxuICAgICAgICAvLyAyLiBTZWFyY2hlcyBnbG9iYWxseSBmb3IgYSBtYXRjaGluZyBzaGFyZSwgaWYgZm91bmQsIGl0IHVzZXMgaXQgZGlyZWN0bHlcbiAgICAgICAgLy8gMy4gSWYgbm90IGZvdW5kLCBpdCByZXRyaWV2ZXMgaXQgZnJvbSB0aGUgY3VycmVudCBzaGFyZSBhbmQgc3RvcmVzIHRoZSBvYnRhaW5lZCBzaGFyZSBnbG9iYWxseS5cbiAgICAgICAgY29uc3Qgc2hhcmVJbmZvID0gZ2V0VGFyZ2V0U2hhcmVkT3B0aW9ucyh7XG4gICAgICAgICAgICBwa2dOYW1lLFxuICAgICAgICAgICAgZXh0cmFPcHRpb25zLFxuICAgICAgICAgICAgc2hhcmVJbmZvczogaG9zdC5vcHRpb25zLnNoYXJlZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNoYXJlSW5mbyA9PSBudWxsID8gdm9pZCAwIDogc2hhcmVJbmZvLnNjb3BlKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChzaGFyZUluZm8uc2NvcGUubWFwKGFzeW5jIChzaGFyZVNjb3BlKT0+e1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaW5pdGlhbGl6ZVNoYXJpbmcoc2hhcmVTY29wZSwgc2hhcmVJbmZvLnN0cmF0ZWd5KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvYWRTaGFyZVJlcyA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZUxvYWRTaGFyZS5lbWl0KHtcbiAgICAgICAgICAgIHBrZ05hbWUsXG4gICAgICAgICAgICBzaGFyZUluZm8sXG4gICAgICAgICAgICBzaGFyZWQ6IGhvc3Qub3B0aW9ucy5zaGFyZWQsXG4gICAgICAgICAgICBvcmlnaW46IGhvc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgc2hhcmVJbmZvOiBzaGFyZUluZm9SZXMgfSA9IGxvYWRTaGFyZVJlcztcbiAgICAgICAgLy8gQXNzZXJ0IHRoYXQgc2hhcmVJbmZvUmVzIGV4aXN0cywgaWYgbm90LCB0aHJvdyBhbiBlcnJvclxuICAgICAgICBhc3NlcnQoc2hhcmVJbmZvUmVzLCBgQ2Fubm90IGZpbmQgJHtwa2dOYW1lfSBTaGFyZSBpbiB0aGUgJHtob3N0Lm9wdGlvbnMubmFtZX0uIFBsZWFzZSBlbnN1cmUgdGhhdCB0aGUgJHtwa2dOYW1lfSBTaGFyZSBwYXJhbWV0ZXJzIGhhdmUgYmVlbiBpbmplY3RlZGApO1xuICAgICAgICAvLyBSZXRyaWV2ZSBmcm9tIGNhY2hlXG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRTaGFyZWQgPSBnZXRSZWdpc3RlcmVkU2hhcmUodGhpcy5zaGFyZVNjb3BlTWFwLCBwa2dOYW1lLCBzaGFyZUluZm9SZXMsIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSk7XG4gICAgICAgIGNvbnN0IGFkZFVzZUluID0gKHNoYXJlZCk9PntcbiAgICAgICAgICAgIGlmICghc2hhcmVkLnVzZUluKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkLnVzZUluID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRVbmlxdWVJdGVtKHNoYXJlZC51c2VJbiwgaG9zdC5vcHRpb25zLm5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocmVnaXN0ZXJlZFNoYXJlZCAmJiByZWdpc3RlcmVkU2hhcmVkLmxpYikge1xuICAgICAgICAgICAgYWRkVXNlSW4ocmVnaXN0ZXJlZFNoYXJlZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFNoYXJlZC5saWI7XG4gICAgICAgIH0gZWxzZSBpZiAocmVnaXN0ZXJlZFNoYXJlZCAmJiByZWdpc3RlcmVkU2hhcmVkLmxvYWRpbmcgJiYgIXJlZ2lzdGVyZWRTaGFyZWQubG9hZGVkKSB7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gYXdhaXQgcmVnaXN0ZXJlZFNoYXJlZC5sb2FkaW5nO1xuICAgICAgICAgICAgcmVnaXN0ZXJlZFNoYXJlZC5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFyZWdpc3RlcmVkU2hhcmVkLmxpYikge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRTaGFyZWQubGliID0gZmFjdG9yeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFVzZUluKHJlZ2lzdGVyZWRTaGFyZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVnaXN0ZXJlZFNoYXJlZCkge1xuICAgICAgICAgICAgY29uc3QgYXN5bmNMb2FkUHJvY2VzcyA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IGF3YWl0IHJlZ2lzdGVyZWRTaGFyZWQuZ2V0KCk7XG4gICAgICAgICAgICAgICAgc2hhcmVJbmZvUmVzLmxpYiA9IGZhY3Rvcnk7XG4gICAgICAgICAgICAgICAgc2hhcmVJbmZvUmVzLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWRkVXNlSW4oc2hhcmVJbmZvUmVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnU2hhcmVkID0gZ2V0UmVnaXN0ZXJlZFNoYXJlKHRoaXMuc2hhcmVTY29wZU1hcCwgcGtnTmFtZSwgc2hhcmVJbmZvUmVzLCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5yZXNvbHZlU2hhcmUpO1xuICAgICAgICAgICAgICAgIGlmIChnU2hhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdTaGFyZWQubGliID0gZmFjdG9yeTtcbiAgICAgICAgICAgICAgICAgICAgZ1NoYXJlZC5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBsb2FkaW5nID0gYXN5bmNMb2FkUHJvY2VzcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRTaGFyZWQoe1xuICAgICAgICAgICAgICAgIHBrZ05hbWUsXG4gICAgICAgICAgICAgICAgbG9hZGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaGFyZWQ6IHJlZ2lzdGVyZWRTaGFyZWQsXG4gICAgICAgICAgICAgICAgZnJvbTogaG9zdC5vcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgbGliOiBudWxsLFxuICAgICAgICAgICAgICAgIGxvYWRpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZXh0cmFPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBleHRyYU9wdGlvbnMuY3VzdG9tU2hhcmVJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXN5bmNMb2FkUHJvY2VzcyA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IGF3YWl0IHNoYXJlSW5mb1Jlcy5nZXQoKTtcbiAgICAgICAgICAgICAgICBzaGFyZUluZm9SZXMubGliID0gZmFjdG9yeTtcbiAgICAgICAgICAgICAgICBzaGFyZUluZm9SZXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhZGRVc2VJbihzaGFyZUluZm9SZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdTaGFyZWQgPSBnZXRSZWdpc3RlcmVkU2hhcmUodGhpcy5zaGFyZVNjb3BlTWFwLCBwa2dOYW1lLCBzaGFyZUluZm9SZXMsIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdTaGFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ1NoYXJlZC5saWIgPSBmYWN0b3J5O1xuICAgICAgICAgICAgICAgICAgICBnU2hhcmVkLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvYWRpbmcgPSBhc3luY0xvYWRQcm9jZXNzKCk7XG4gICAgICAgICAgICB0aGlzLnNldFNoYXJlZCh7XG4gICAgICAgICAgICAgICAgcGtnTmFtZSxcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNoYXJlZDogc2hhcmVJbmZvUmVzLFxuICAgICAgICAgICAgICAgIGZyb206IGhvc3Qub3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgIGxpYjogbnVsbCxcbiAgICAgICAgICAgICAgICBsb2FkaW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsb2FkaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGluaXRpYWxpemVzIHRoZSBzaGFyaW5nIHNlcXVlbmNlIChleGVjdXRlZCBvbmx5IG9uY2UgcGVyIHNoYXJlIHNjb3BlKS5cbiAgICogSXQgYWNjZXB0cyBvbmUgYXJndW1lbnQsIHRoZSBuYW1lIG9mIHRoZSBzaGFyZSBzY29wZS5cbiAgICogSWYgdGhlIHNoYXJlIHNjb3BlIGRvZXMgbm90IGV4aXN0LCBpdCBjcmVhdGVzIG9uZS5cbiAgICovIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgaW5pdGlhbGl6ZVNoYXJpbmcoc2hhcmVTY29wZU5hbWUgPSBERUZBVUxUX1NDT1BFLCBzdHJhdGVneSkge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHNoYXJlU2NvcGUgPSB0aGlzLnNoYXJlU2NvcGVNYXA7XG4gICAgICAgIGNvbnN0IGhvc3ROYW1lID0gaG9zdC5vcHRpb25zLm5hbWU7XG4gICAgICAgIC8vIENyZWF0ZXMgYSBuZXcgc2hhcmUgc2NvcGUgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmICghc2hhcmVTY29wZVtzaGFyZVNjb3BlTmFtZV0pIHtcbiAgICAgICAgICAgIHNoYXJlU2NvcGVbc2hhcmVTY29wZU5hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhlY3V0ZXMgYWxsIGluaXRpYWxpemF0aW9uIHNuaXBwZXRzIGZyb20gYWxsIGFjY2Vzc2libGUgbW9kdWxlc1xuICAgICAgICBjb25zdCBzY29wZSA9IHNoYXJlU2NvcGVbc2hhcmVTY29wZU5hbWVdO1xuICAgICAgICBjb25zdCByZWdpc3RlciA9IChuYW1lLCBzaGFyZWQpPT57XG4gICAgICAgICAgICB2YXIgX2FjdGl2ZVZlcnNpb25fc2hhcmVDb25maWc7XG4gICAgICAgICAgICBjb25zdCB7IHZlcnNpb24sIGVhZ2VyIH0gPSBzaGFyZWQ7XG4gICAgICAgICAgICBzY29wZVtuYW1lXSA9IHNjb3BlW25hbWVdIHx8IHt9O1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbnMgPSBzY29wZVtuYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVZlcnNpb24gPSB2ZXJzaW9uc1t2ZXJzaW9uXTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVZlcnNpb25FYWdlciA9IEJvb2xlYW4oYWN0aXZlVmVyc2lvbiAmJiAoYWN0aXZlVmVyc2lvbi5lYWdlciB8fCAoKF9hY3RpdmVWZXJzaW9uX3NoYXJlQ29uZmlnID0gYWN0aXZlVmVyc2lvbi5zaGFyZUNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hY3RpdmVWZXJzaW9uX3NoYXJlQ29uZmlnLmVhZ2VyKSkpO1xuICAgICAgICAgICAgaWYgKCFhY3RpdmVWZXJzaW9uIHx8IGFjdGl2ZVZlcnNpb24uc3RyYXRlZ3kgIT09ICdsb2FkZWQtZmlyc3QnICYmICFhY3RpdmVWZXJzaW9uLmxvYWRlZCAmJiAoQm9vbGVhbighZWFnZXIpICE9PSAhYWN0aXZlVmVyc2lvbkVhZ2VyID8gZWFnZXIgOiBob3N0TmFtZSA+IGFjdGl2ZVZlcnNpb24uZnJvbSkpIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uc1t2ZXJzaW9uXSA9IHNoYXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgY29uc3QgaW5pdEZuID0gKG1vZCk9Pm1vZCAmJiBtb2QuaW5pdCAmJiBtb2QuaW5pdChzaGFyZVNjb3BlW3NoYXJlU2NvcGVOYW1lXSk7XG4gICAgICAgIGNvbnN0IGluaXRSZW1vdGVNb2R1bGUgPSBhc3luYyAoa2V5KT0+e1xuICAgICAgICAgICAgY29uc3QgeyBtb2R1bGUgfSA9IGF3YWl0IGhvc3QucmVtb3RlSGFuZGxlci5nZXRSZW1vdGVNb2R1bGVBbmRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBpZDoga2V5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtb2R1bGUuZ2V0RW50cnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IG1vZHVsZS5nZXRFbnRyeSgpO1xuICAgICAgICAgICAgICAgIGlmICghbW9kdWxlLmluaXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpbml0Rm4oZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUuaW5pdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5rZXlzKGhvc3Qub3B0aW9ucy5zaGFyZWQpLmZvckVhY2goKHNoYXJlTmFtZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZEFyciA9IGhvc3Qub3B0aW9ucy5zaGFyZWRbc2hhcmVOYW1lXTtcbiAgICAgICAgICAgIHNoYXJlZEFyci5mb3JFYWNoKChzaGFyZWQpPT57XG4gICAgICAgICAgICAgICAgaWYgKHNoYXJlZC5zY29wZS5pbmNsdWRlcyhzaGFyZVNjb3BlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXIoc2hhcmVOYW1lLCBzaGFyZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0cmF0ZWd5ID09PSAndmVyc2lvbi1maXJzdCcpIHtcbiAgICAgICAgICAgIGhvc3Qub3B0aW9ucy5yZW1vdGVzLmZvckVhY2goKHJlbW90ZSk9PntcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlLnNoYXJlU2NvcGUgPT09IHNoYXJlU2NvcGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goaW5pdFJlbW90ZU1vZHVsZShyZW1vdGUubmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlcztcbiAgICB9XG4gICAgLy8gVGhlIGxpYiBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgYXZhaWxhYmxlIGlmIHRoZSBzaGFyZWQgc2V0IGJ5IGVhZ2VyIG9yIHJ1bnRpbWUgaW5pdCBpcyBzZXQgb3IgdGhlIHNoYXJlZCBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgIC8vIDEuIElmIHRoZSBsb2FkZWQgc2hhcmVkIGFscmVhZHkgZXhpc3RzIGdsb2JhbGx5LCB0aGVuIGl0IHdpbGwgYmUgcmV1c2VkXG4gICAgLy8gMi4gSWYgbGliIGV4aXN0cyBpbiBsb2NhbCBzaGFyZWQsIGl0IHdpbGwgYmUgdXNlZCBkaXJlY3RseVxuICAgIC8vIDMuIElmIHRoZSBsb2NhbCBnZXQgcmV0dXJucyBzb21ldGhpbmcgb3RoZXIgdGhhbiBQcm9taXNlLCB0aGVuIGl0IHdpbGwgYmUgdXNlZCBkaXJlY3RseVxuICAgIGxvYWRTaGFyZVN5bmMocGtnTmFtZSwgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgaG9zdCB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2hhcmVJbmZvID0gZ2V0VGFyZ2V0U2hhcmVkT3B0aW9ucyh7XG4gICAgICAgICAgICBwa2dOYW1lLFxuICAgICAgICAgICAgZXh0cmFPcHRpb25zLFxuICAgICAgICAgICAgc2hhcmVJbmZvczogaG9zdC5vcHRpb25zLnNoYXJlZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNoYXJlSW5mbyA9PSBudWxsID8gdm9pZCAwIDogc2hhcmVJbmZvLnNjb3BlKSB7XG4gICAgICAgICAgICBzaGFyZUluZm8uc2NvcGUuZm9yRWFjaCgoc2hhcmVTY29wZSk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVTaGFyaW5nKHNoYXJlU2NvcGUsIHNoYXJlSW5mby5zdHJhdGVneSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWdpc3RlcmVkU2hhcmVkID0gZ2V0UmVnaXN0ZXJlZFNoYXJlKHRoaXMuc2hhcmVTY29wZU1hcCwgcGtnTmFtZSwgc2hhcmVJbmZvLCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5yZXNvbHZlU2hhcmUpO1xuICAgICAgICBjb25zdCBhZGRVc2VJbiA9IChzaGFyZWQpPT57XG4gICAgICAgICAgICBpZiAoIXNoYXJlZC51c2VJbikge1xuICAgICAgICAgICAgICAgIHNoYXJlZC51c2VJbiA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkVW5pcXVlSXRlbShzaGFyZWQudXNlSW4sIGhvc3Qub3B0aW9ucy5uYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRTaGFyZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVnaXN0ZXJlZFNoYXJlZC5saWIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhZGRVc2VJbihyZWdpc3RlcmVkU2hhcmVkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2lzdGVyZWRTaGFyZWQubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRTaGFyZWQubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2lzdGVyZWRTaGFyZWQuZnJvbSA9PT0gaG9zdC5vcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlSW5mby5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWdpc3RlcmVkU2hhcmVkLmxpYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVnaXN0ZXJlZFNoYXJlZC5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGUgPSByZWdpc3RlcmVkU2hhcmVkLmdldCgpO1xuICAgICAgICAgICAgICAgIGlmICghKG1vZHVsZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFVzZUluKHJlZ2lzdGVyZWRTaGFyZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNoYXJlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwa2dOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogaG9zdC5vcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaWI6IG1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZDogcmVnaXN0ZXJlZFNoYXJlZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXJlSW5mby5saWIpIHtcbiAgICAgICAgICAgIGlmICghc2hhcmVJbmZvLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIHNoYXJlSW5mby5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNoYXJlSW5mby5saWI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXJlSW5mby5nZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IHNoYXJlSW5mby5nZXQoKTtcbiAgICAgICAgICAgIGlmIChtb2R1bGUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgICAgVGhlIGxvYWRTaGFyZVN5bmMgZnVuY3Rpb24gd2FzIHVuYWJsZSB0byBsb2FkICR7cGtnTmFtZX0uIFRoZSAke3BrZ05hbWV9IGNvdWxkIG5vdCBiZSBmb3VuZCBpbiAke2hvc3Qub3B0aW9ucy5uYW1lfS5cbiAgICAgICAgUG9zc2libGUgcmVhc29ucyBmb3IgZmFpbHVyZTogXFxuXG4gICAgICAgIDEuIFRoZSAke3BrZ05hbWV9IHNoYXJlIHdhcyByZWdpc3RlcmVkIHdpdGggdGhlICdnZXQnIGF0dHJpYnV0ZSwgYnV0IGxvYWRTaGFyZSB3YXMgbm90IHVzZWQgYmVmb3JlaGFuZC5cXG5cbiAgICAgICAgMi4gVGhlICR7cGtnTmFtZX0gc2hhcmUgd2FzIG5vdCByZWdpc3RlcmVkIHdpdGggdGhlICdsaWInIGF0dHJpYnV0ZS5cXG5cbiAgICAgIGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hhcmVJbmZvLmxpYiA9IG1vZHVsZTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2hhcmVkKHtcbiAgICAgICAgICAgICAgICBwa2dOYW1lLFxuICAgICAgICAgICAgICAgIGxvYWRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmcm9tOiBob3N0Lm9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgICAgICBsaWI6IHNoYXJlSW5mby5saWIsXG4gICAgICAgICAgICAgICAgc2hhcmVkOiBzaGFyZUluZm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNoYXJlSW5mby5saWI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgICAgVGhlIGxvYWRTaGFyZVN5bmMgZnVuY3Rpb24gd2FzIHVuYWJsZSB0byBsb2FkICR7cGtnTmFtZX0uIFRoZSAke3BrZ05hbWV9IGNvdWxkIG5vdCBiZSBmb3VuZCBpbiAke2hvc3Qub3B0aW9ucy5uYW1lfS5cbiAgICAgICAgUG9zc2libGUgcmVhc29ucyBmb3IgZmFpbHVyZTogXFxuXG4gICAgICAgIDEuIFRoZSAke3BrZ05hbWV9IHNoYXJlIHdhcyByZWdpc3RlcmVkIHdpdGggdGhlICdnZXQnIGF0dHJpYnV0ZSwgYnV0IGxvYWRTaGFyZSB3YXMgbm90IHVzZWQgYmVmb3JlaGFuZC5cXG5cbiAgICAgICAgMi4gVGhlICR7cGtnTmFtZX0gc2hhcmUgd2FzIG5vdCByZWdpc3RlcmVkIHdpdGggdGhlICdsaWInIGF0dHJpYnV0ZS5cXG5cbiAgICAgIGApO1xuICAgIH1cbiAgICBpbml0U2hhcmVTY29wZU1hcChzY29wZU5hbWUsIHNoYXJlU2NvcGUpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnNoYXJlU2NvcGVNYXBbc2NvcGVOYW1lXSA9IHNoYXJlU2NvcGU7XG4gICAgICAgIHRoaXMuaG9va3MubGlmZWN5Y2xlLmluaXRDb250YWluZXJTaGFyZVNjb3BlTWFwLmVtaXQoe1xuICAgICAgICAgICAgc2hhcmVTY29wZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGhvc3Qub3B0aW9ucyxcbiAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0U2hhcmVkKHsgcGtnTmFtZSwgc2hhcmVkLCBmcm9tLCBsaWIsIGxvYWRpbmcsIGxvYWRlZCwgZ2V0IH0pIHtcbiAgICAgICAgY29uc3QgeyB2ZXJzaW9uLCBzY29wZSA9ICdkZWZhdWx0JyB9ID0gc2hhcmVkLCBzaGFyZUluZm8gPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShzaGFyZWQsIFtcbiAgICAgICAgICAgIFwidmVyc2lvblwiLFxuICAgICAgICAgICAgXCJzY29wZVwiXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBzY29wZXMgPSBBcnJheS5pc0FycmF5KHNjb3BlKSA/IHNjb3BlIDogW1xuICAgICAgICAgICAgc2NvcGVcbiAgICAgICAgXTtcbiAgICAgICAgc2NvcGVzLmZvckVhY2goKHNjKT0+e1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNoYXJlU2NvcGVNYXBbc2NdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwW3NjXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2hhcmVTY29wZU1hcFtzY11bcGtnTmFtZV1bdmVyc2lvbl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdW3ZlcnNpb25dID0gX2V4dGVuZHMkMih7XG4gICAgICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgICAgICBzY29wZTogW1xuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCdcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LCBzaGFyZUluZm8sIHtcbiAgICAgICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICAgICAgbG9hZGVkLFxuICAgICAgICAgICAgICAgIGxvYWRpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVTY29wZU1hcFtzY11bcGtnTmFtZV1bdmVyc2lvbl0uZ2V0ID0gZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3NldEdsb2JhbFNoYXJlU2NvcGVNYXAoaG9zdE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZ2xvYmFsU2hhcmVTY29wZU1hcCA9IGdldEdsb2JhbFNoYXJlU2NvcGUoKTtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGhvc3RPcHRpb25zLmlkIHx8IGhvc3RPcHRpb25zLm5hbWU7XG4gICAgICAgIGlmIChpZGVudGlmaWVyICYmICFnbG9iYWxTaGFyZVNjb3BlTWFwW2lkZW50aWZpZXJdKSB7XG4gICAgICAgICAgICBnbG9iYWxTaGFyZVNjb3BlTWFwW2lkZW50aWZpZXJdID0gdGhpcy5zaGFyZVNjb3BlTWFwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGhvc3Qpe1xuICAgICAgICB0aGlzLmhvb2tzID0gbmV3IFBsdWdpblN5c3RlbSh7XG4gICAgICAgICAgICBhZnRlclJlc29sdmU6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2FmdGVyUmVzb2x2ZScpLFxuICAgICAgICAgICAgYmVmb3JlTG9hZFNoYXJlOiBuZXcgQXN5bmNXYXRlcmZhbGxIb29rKCdiZWZvcmVMb2FkU2hhcmUnKSxcbiAgICAgICAgICAgIC8vIG5vdCB1c2VkIHlldFxuICAgICAgICAgICAgbG9hZFNoYXJlOiBuZXcgQXN5bmNIb29rKCksXG4gICAgICAgICAgICByZXNvbHZlU2hhcmU6IG5ldyBTeW5jV2F0ZXJmYWxsSG9vaygncmVzb2x2ZVNoYXJlJyksXG4gICAgICAgICAgICAvLyBtYXliZSB3aWxsIGNoYW5nZSwgdGVtcG9yYXJpbHkgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgICAgICAgICBpbml0Q29udGFpbmVyU2hhcmVTY29wZU1hcDogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vaygnaW5pdENvbnRhaW5lcicpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnNoYXJlU2NvcGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5fc2V0R2xvYmFsU2hhcmVTY29wZU1hcChob3N0Lm9wdGlvbnMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMkMSgpIHtcbiAgICBfZXh0ZW5kcyQxID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmNsYXNzIFJlbW90ZUhhbmRsZXIge1xuICAgIGZvcm1hdEFuZFJlZ2lzdGVyUmVtb3RlKGdsb2JhbE9wdGlvbnMsIHVzZXJPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHVzZXJSZW1vdGVzID0gdXNlck9wdGlvbnMucmVtb3RlcyB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHVzZXJSZW1vdGVzLnJlZHVjZSgocmVzLCByZW1vdGUpPT57XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyUmVtb3RlKHJlbW90ZSwgcmVzLCB7XG4gICAgICAgICAgICAgICAgZm9yY2U6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIGdsb2JhbE9wdGlvbnMucmVtb3Rlcyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGluZXMtcGVyLWZ1bmN0aW9uXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9tZW1iZXItb3JkZXJpbmdcbiAgICBhc3luYyBsb2FkUmVtb3RlKGlkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgaG9zdCB9ID0gdGhpcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbG9hZEZhY3RvcnkgPSB0cnVlIH0gPSBvcHRpb25zIHx8IHtcbiAgICAgICAgICAgICAgICBsb2FkRmFjdG9yeTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIDEuIFZhbGlkYXRlIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSByZXRyaWV2ZWQgbW9kdWxlLiBUaGVyZSBhcmUgdHdvIG1vZHVsZSByZXF1ZXN0IG1ldGhvZHM6IHBrZ05hbWUgKyBleHBvc2UgYW5kIGFsaWFzICsgZXhwb3NlLlxuICAgICAgICAgICAgLy8gMi4gUmVxdWVzdCB0aGUgc25hcHNob3QgaW5mb3JtYXRpb24gb2YgdGhlIGN1cnJlbnQgaG9zdCBhbmQgZ2xvYmFsbHkgc3RvcmUgdGhlIG9idGFpbmVkIHNuYXBzaG90IGluZm9ybWF0aW9uLiBUaGUgcmV0cmlldmVkIG1vZHVsZSBpbmZvcm1hdGlvbiBpcyBwYXJ0aWFsbHkgb2ZmbGluZSBhbmQgcGFydGlhbGx5IG9ubGluZS4gVGhlIG9ubGluZSBtb2R1bGUgaW5mb3JtYXRpb24gd2lsbCByZXRyaWV2ZSB0aGUgbW9kdWxlcyB1c2VkIG9ubGluZS5cbiAgICAgICAgICAgIC8vIDMuIFJldHJpZXZlIHRoZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvZiB0aGUgY3VycmVudCBtb2R1bGUgZnJvbSBnbG9iYWwgKHJlbW90ZUVudHJ5IGFkZHJlc3MsIGV4cG9zZSByZXNvdXJjZSBhZGRyZXNzKVxuICAgICAgICAgICAgLy8gNC4gQWZ0ZXIgcmV0cmlldmluZyByZW1vdGVFbnRyeSwgY2FsbCB0aGUgaW5pdCBvZiB0aGUgbW9kdWxlLCBhbmQgdGhlbiByZXRyaWV2ZSB0aGUgZXhwb3J0ZWQgY29udGVudCBvZiB0aGUgbW9kdWxlIHRocm91Z2ggZ2V0XG4gICAgICAgICAgICAvLyBpZDogcGtnTmFtZShAZmVkZXJhdGlvbi9hcHAxKSArIGV4cG9zZShidXR0b24pID0gQGZlZGVyYXRpb24vYXBwMS9idXR0b25cbiAgICAgICAgICAgIC8vIGlkOiBhbGlhcyhhcHAxKSArIGV4cG9zZShidXR0b24pID0gYXBwMS9idXR0b25cbiAgICAgICAgICAgIC8vIGlkOiBhbGlhcyhhcHAxL3V0aWxzKSArIGV4cG9zZShsb2FkYXNoL3NvcnQpID0gYXBwMS91dGlscy9sb2FkYXNoL3NvcnRcbiAgICAgICAgICAgIGNvbnN0IHsgbW9kdWxlLCBtb2R1bGVPcHRpb25zLCByZW1vdGVNYXRjaEluZm8gfSA9IGF3YWl0IHRoaXMuZ2V0UmVtb3RlTW9kdWxlQW5kT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBwa2dOYW1lT3JBbGlhcywgcmVtb3RlLCBleHBvc2UsIGlkOiBpZFJlcyB9ID0gcmVtb3RlTWF0Y2hJbmZvO1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlT3JGYWN0b3J5ID0gYXdhaXQgbW9kdWxlLmdldChleHBvc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlV3JhcHBlciA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLm9uTG9hZC5lbWl0KHtcbiAgICAgICAgICAgICAgICBpZDogaWRSZXMsXG4gICAgICAgICAgICAgICAgcGtnTmFtZU9yQWxpYXMsXG4gICAgICAgICAgICAgICAgZXhwb3NlLFxuICAgICAgICAgICAgICAgIGV4cG9zZU1vZHVsZTogbG9hZEZhY3RvcnkgPyBtb2R1bGVPckZhY3RvcnkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZXhwb3NlTW9kdWxlRmFjdG9yeTogbG9hZEZhY3RvcnkgPyB1bmRlZmluZWQgOiBtb2R1bGVPckZhY3RvcnksXG4gICAgICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG1vZHVsZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbW9kdWxlSW5zdGFuY2U6IG1vZHVsZSxcbiAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVXcmFwcGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVdyYXBwZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlT3JGYWN0b3J5O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgeyBmcm9tID0gJ3J1bnRpbWUnIH0gPSBvcHRpb25zIHx8IHtcbiAgICAgICAgICAgICAgICBmcm9tOiAncnVudGltZSdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmYWlsT3ZlciA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmVycm9yTG9hZFJlbW90ZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgIGxpZmVjeWNsZTogJ29uTG9hZCcsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBob3N0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghZmFpbE92ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWlsT3ZlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZ1xuICAgIGFzeW5jIHByZWxvYWRSZW1vdGUocHJlbG9hZE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5iZWZvcmVQcmVsb2FkUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgcHJlbG9hZE9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zOiBob3N0Lm9wdGlvbnMsXG4gICAgICAgICAgICBvcmlnaW46IGhvc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByZWxvYWRPcHMgPSBmb3JtYXRQcmVsb2FkQXJncyhob3N0Lm9wdGlvbnMucmVtb3RlcywgcHJlbG9hZE9wdGlvbnMpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcmVsb2FkT3BzLm1hcChhc3luYyAob3BzKT0+e1xuICAgICAgICAgICAgY29uc3QgeyByZW1vdGUgfSA9IG9wcztcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUluZm8gPSBnZXRSZW1vdGVJbmZvKHJlbW90ZSk7XG4gICAgICAgICAgICBjb25zdCB7IGdsb2JhbFNuYXBzaG90LCByZW1vdGVTbmFwc2hvdCB9ID0gYXdhaXQgaG9zdC5zbmFwc2hvdEhhbmRsZXIubG9hZFJlbW90ZVNuYXBzaG90SW5mbyhyZW1vdGUpO1xuICAgICAgICAgICAgY29uc3QgYXNzZXRzID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuZ2VuZXJhdGVQcmVsb2FkQXNzZXRzLmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbjogaG9zdCxcbiAgICAgICAgICAgICAgICBwcmVsb2FkT3B0aW9uczogb3BzLFxuICAgICAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgICAgICByZW1vdGVJbmZvLFxuICAgICAgICAgICAgICAgIGdsb2JhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghYXNzZXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlbG9hZEFzc2V0cyhyZW1vdGVJbmZvLCBob3N0LCBhc3NldHMpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVtb3RlcyhyZW1vdGVzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgaG9zdCB9ID0gdGhpcztcbiAgICAgICAgcmVtb3Rlcy5mb3JFYWNoKChyZW1vdGUpPT57XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyUmVtb3RlKHJlbW90ZSwgaG9zdC5vcHRpb25zLnJlbW90ZXMsIHtcbiAgICAgICAgICAgICAgICBmb3JjZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5mb3JjZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZW1vdGVNb2R1bGVBbmRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGlkIH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgbG9hZFJlbW90ZUFyZ3M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2FkUmVtb3RlQXJncyA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZVJlcXVlc3QuZW1pdCh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogaG9zdC5vcHRpb25zLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2FkUmVtb3RlQXJncyA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmVycm9yTG9hZFJlbW90ZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBob3N0Lm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBob3N0LFxuICAgICAgICAgICAgICAgIGZyb206ICdydW50aW1lJyxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBsaWZlY3ljbGU6ICdiZWZvcmVSZXF1ZXN0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWxvYWRSZW1vdGVBcmdzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpZDogaWRSZXMgfSA9IGxvYWRSZW1vdGVBcmdzO1xuICAgICAgICBjb25zdCByZW1vdGVTcGxpdEluZm8gPSBtYXRjaFJlbW90ZVdpdGhOYW1lQW5kRXhwb3NlKGhvc3Qub3B0aW9ucy5yZW1vdGVzLCBpZFJlcyk7XG4gICAgICAgIGFzc2VydChyZW1vdGVTcGxpdEluZm8sIGBcbiAgICAgICAgVW5hYmxlIHRvIGxvY2F0ZSAke2lkUmVzfSBpbiAke2hvc3Qub3B0aW9ucy5uYW1lfS4gUG90ZW50aWFsIHJlYXNvbnMgZm9yIGZhaWx1cmUgaW5jbHVkZTpcXG5cbiAgICAgICAgMS4gJHtpZFJlc30gd2FzIG5vdCBpbmNsdWRlZCBpbiB0aGUgJ3JlbW90ZXMnIHBhcmFtZXRlciBvZiAke2hvc3Qub3B0aW9ucy5uYW1lIHx8ICd0aGUgaG9zdCd9LlxcblxuICAgICAgICAyLiAke2lkUmVzfSBjb3VsZCBub3QgYmUgZm91bmQgaW4gdGhlICdyZW1vdGVzJyBvZiAke2hvc3Qub3B0aW9ucy5uYW1lfSB3aXRoIGVpdGhlciAnbmFtZScgb3IgJ2FsaWFzJyBhdHRyaWJ1dGVzLlxuICAgICAgICAzLiAke2lkUmVzfSBpcyBub3Qgb25saW5lLCBpbmplY3RlZCwgb3IgbG9hZGVkLlxuICAgICAgICA0LiAke2lkUmVzfSAgY2Fubm90IGJlIGFjY2Vzc2VkIG9uIHRoZSBleHBlY3RlZC5cbiAgICAgICAgNS4gVGhlICdiZWZvcmVSZXF1ZXN0JyBob29rIHdhcyBwcm92aWRlZCBidXQgZGlkIG5vdCByZXR1cm4gdGhlIGNvcnJlY3QgJ3JlbW90ZUluZm8nIHdoZW4gYXR0ZW1wdGluZyB0byBsb2FkICR7aWRSZXN9LlxuICAgICAgYCk7XG4gICAgICAgIGNvbnN0IHsgcmVtb3RlOiByYXdSZW1vdGUgfSA9IHJlbW90ZVNwbGl0SW5mbztcbiAgICAgICAgY29uc3QgcmVtb3RlSW5mbyA9IGdldFJlbW90ZUluZm8ocmF3UmVtb3RlKTtcbiAgICAgICAgY29uc3QgbWF0Y2hJbmZvID0gYXdhaXQgaG9zdC5zaGFyZWRIYW5kbGVyLmhvb2tzLmxpZmVjeWNsZS5hZnRlclJlc29sdmUuZW1pdChfZXh0ZW5kcyQxKHtcbiAgICAgICAgICAgIGlkOiBpZFJlc1xuICAgICAgICB9LCByZW1vdGVTcGxpdEluZm8sIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IGhvc3Qub3B0aW9ucyxcbiAgICAgICAgICAgIG9yaWdpbjogaG9zdCxcbiAgICAgICAgICAgIHJlbW90ZUluZm9cbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB7IHJlbW90ZSwgZXhwb3NlIH0gPSBtYXRjaEluZm87XG4gICAgICAgIGFzc2VydChyZW1vdGUgJiYgZXhwb3NlLCBgVGhlICdiZWZvcmVSZXF1ZXN0JyBob29rIHdhcyBleGVjdXRlZCwgYnV0IGl0IGZhaWxlZCB0byByZXR1cm4gdGhlIGNvcnJlY3QgJ3JlbW90ZScgYW5kICdleHBvc2UnIHZhbHVlcyB3aGlsZSBsb2FkaW5nICR7aWRSZXN9LmApO1xuICAgICAgICBsZXQgbW9kdWxlID0gaG9zdC5tb2R1bGVDYWNoZS5nZXQocmVtb3RlLm5hbWUpO1xuICAgICAgICBjb25zdCBtb2R1bGVPcHRpb25zID0ge1xuICAgICAgICAgICAgaG9zdDogaG9zdCxcbiAgICAgICAgICAgIHJlbW90ZUluZm9cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICAgIG1vZHVsZSA9IG5ldyBNb2R1bGUobW9kdWxlT3B0aW9ucyk7XG4gICAgICAgICAgICBob3N0Lm1vZHVsZUNhY2hlLnNldChyZW1vdGUubmFtZSwgbW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICAgICAgbW9kdWxlT3B0aW9ucyxcbiAgICAgICAgICAgIHJlbW90ZU1hdGNoSW5mbzogbWF0Y2hJbmZvXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVtb3RlKHJlbW90ZSwgdGFyZ2V0UmVtb3Rlcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBub3JtYWxpemVSZW1vdGUgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKHJlbW90ZS5hbGlhcykge1xuICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIGlmIGFsaWFzIGVxdWFscyB0aGUgcHJlZml4IG9mIHJlbW90ZS5uYW1lIGFuZCByZW1vdGUuYWxpYXMsIGlmIHNvLCB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIC8vIEFzIG11bHRpLWxldmVsIHBhdGggcmVmZXJlbmNlcyBjYW5ub3QgZ3VhcmFudGVlIHVuaXF1ZSBuYW1lcywgYWxpYXMgYmVpbmcgYSBwcmVmaXggb2YgcmVtb3RlLm5hbWUgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmRFcXVhbCA9IHRhcmdldFJlbW90ZXMuZmluZCgoaXRlbSk9PntcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVtX2FsaWFzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3RlLmFsaWFzICYmIChpdGVtLm5hbWUuc3RhcnRzV2l0aChyZW1vdGUuYWxpYXMpIHx8ICgoX2l0ZW1fYWxpYXMgPSBpdGVtLmFsaWFzKSA9PSBudWxsID8gdm9pZCAwIDogX2l0ZW1fYWxpYXMuc3RhcnRzV2l0aChyZW1vdGUuYWxpYXMpKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KCFmaW5kRXF1YWwsIGBUaGUgYWxpYXMgJHtyZW1vdGUuYWxpYXN9IG9mIHJlbW90ZSAke3JlbW90ZS5uYW1lfSBpcyBub3QgYWxsb3dlZCB0byBiZSB0aGUgcHJlZml4IG9mICR7ZmluZEVxdWFsICYmIGZpbmRFcXVhbC5uYW1lfSBuYW1lIG9yIGFsaWFzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdGhlIHJlbW90ZSBlbnRyeSB0byBhIGNvbXBsZXRlIHBhdGhcbiAgICAgICAgICAgIGlmICgnZW50cnknIGluIHJlbW90ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Jyb3dzZXJFbnYoKSAmJiAhcmVtb3RlLmVudHJ5LnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGUuZW50cnkgPSBuZXcgVVJMKHJlbW90ZS5lbnRyeSwgd2luZG93LmxvY2F0aW9uLm9yaWdpbikuaHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlbW90ZS5zaGFyZVNjb3BlKSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlLnNoYXJlU2NvcGUgPSBERUZBVUxUX1NDT1BFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZW1vdGUudHlwZSkge1xuICAgICAgICAgICAgICAgIHJlbW90ZS50eXBlID0gREVGQVVMVF9SRU1PVEVfVFlQRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFJlbW90ZSA9IHRhcmdldFJlbW90ZXMuZmluZCgoaXRlbSk9Pml0ZW0ubmFtZSA9PT0gcmVtb3RlLm5hbWUpO1xuICAgICAgICBpZiAoIXJlZ2lzdGVyZWRSZW1vdGUpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZVJlbW90ZSgpO1xuICAgICAgICAgICAgdGFyZ2V0UmVtb3Rlcy5wdXNoKHJlbW90ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICBgVGhlIHJlbW90ZSBcIiR7cmVtb3RlLm5hbWV9XCIgaXMgYWxyZWFkeSByZWdpc3RlcmVkLmAsXG4gICAgICAgICAgICAgICAgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yY2UpID8gJ0hvcGUgeW91IGhhdmUga25vd24gdGhhdCBPVkVSUklERSBpdCBtYXkgaGF2ZSBzb21lIHVuZXhwZWN0ZWQgZXJyb3JzJyA6ICdJZiB5b3Ugd2FudCB0byBtZXJnZSB0aGUgcmVtb3RlLCB5b3UgY2FuIHNldCBcImZvcmNlOiB0cnVlXCIuJ1xuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZvcmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHJlZ2lzdGVyZWQgcmVtb3RlXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVSZW1vdGUocmVnaXN0ZXJlZFJlbW90ZSk7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplUmVtb3RlKCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0UmVtb3Rlcy5wdXNoKHJlbW90ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YXJuJDEobWVzc2FnZXMuam9pbignICcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVSZW1vdGUocmVtb3RlKSB7XG4gICAgICAgIGNvbnN0IHsgaG9zdCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBuYW1lIH0gPSByZW1vdGU7XG4gICAgICAgIGNvbnN0IHJlbW90ZUluZGV4ID0gaG9zdC5vcHRpb25zLnJlbW90ZXMuZmluZEluZGV4KChpdGVtKT0+aXRlbS5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgaWYgKHJlbW90ZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgaG9zdC5vcHRpb25zLnJlbW90ZXMuc3BsaWNlKHJlbW90ZUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2FkZWRNb2R1bGUgPSBob3N0Lm1vZHVsZUNhY2hlLmdldChyZW1vdGUubmFtZSk7XG4gICAgICAgIGlmIChsb2FkZWRNb2R1bGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUluZm8gPSBsb2FkZWRNb2R1bGUucmVtb3RlSW5mbztcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHJlbW90ZUluZm8uZW50cnlHbG9iYWxOYW1lO1xuICAgICAgICAgICAgaWYgKGdsb2JhbFRoaXNba2V5XSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBnbG9iYWxUaGlzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZW1vdGVFbnRyeVVuaXF1ZUtleSA9IGdldFJlbW90ZUVudHJ5VW5pcXVlS2V5KGxvYWRlZE1vZHVsZS5yZW1vdGVJbmZvKTtcbiAgICAgICAgICAgIGlmIChnbG9iYWxMb2FkaW5nW3JlbW90ZUVudHJ5VW5pcXVlS2V5XSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBnbG9iYWxMb2FkaW5nW3JlbW90ZUVudHJ5VW5pcXVlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlbGV0ZSB1biBsb2FkZWQgc2hhcmVkIGFuZCBpbnN0YW5jZVxuICAgICAgICAgICAgbGV0IHJlbW90ZUluc0lkID0gcmVtb3RlSW5mby5idWlsZFZlcnNpb24gPyBjb21wb3NlS2V5V2l0aFNlcGFyYXRvcihyZW1vdGVJbmZvLm5hbWUsIHJlbW90ZUluZm8uYnVpbGRWZXJzaW9uKSA6IHJlbW90ZUluZm8ubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUluc0luZGV4ID0gZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX0lOU1RBTkNFU19fLmZpbmRJbmRleCgoaW5zKT0+e1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVJbmZvLmJ1aWxkVmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zLm9wdGlvbnMuaWQgPT09IHJlbW90ZUluc0lkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnMubmFtZSA9PT0gcmVtb3RlSW5zSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVtb3RlSW5zSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3RlSW5zID0gZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX0lOU1RBTkNFU19fW3JlbW90ZUluc0luZGV4XTtcbiAgICAgICAgICAgICAgICByZW1vdGVJbnNJZCA9IHJlbW90ZUlucy5vcHRpb25zLmlkIHx8IHJlbW90ZUluc0lkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdsb2JhbFNoYXJlU2NvcGVNYXAgPSBnZXRHbG9iYWxTaGFyZVNjb3BlKCk7XG4gICAgICAgICAgICAgICAgbGV0IGlzQWxsU2hhcmVkTm90VXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbmVlZERlbGV0ZUtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhnbG9iYWxTaGFyZVNjb3BlTWFwKS5mb3JFYWNoKChpbnN0SWQpPT57XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGdsb2JhbFNoYXJlU2NvcGVNYXBbaW5zdElkXSkuZm9yRWFjaCgoc2hhcmVTY29wZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGdsb2JhbFNoYXJlU2NvcGVNYXBbaW5zdElkXVtzaGFyZVNjb3BlXSkuZm9yRWFjaCgoc2hhcmVOYW1lKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGdsb2JhbFNoYXJlU2NvcGVNYXBbaW5zdElkXVtzaGFyZVNjb3BlXVtzaGFyZU5hbWVdKS5mb3JFYWNoKChzaGFyZVZlcnNpb24pPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYXJlZCA9IGdsb2JhbFNoYXJlU2NvcGVNYXBbaW5zdElkXVtzaGFyZVNjb3BlXVtzaGFyZU5hbWVdW3NoYXJlVmVyc2lvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFyZWQuZnJvbSA9PT0gcmVtb3RlSW5mby5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkLmxvYWRlZCB8fCBzaGFyZWQubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZC51c2VJbiA9IHNoYXJlZC51c2VJbi5maWx0ZXIoKHVzZWRIb3N0TmFtZSk9PnVzZWRIb3N0TmFtZSAhPT0gcmVtb3RlSW5mby5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkLnVzZUluLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FsbFNoYXJlZE5vdFVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkRGVsZXRlS2V5cy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlU2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkRGVsZXRlS2V5cy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlVmVyc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWxsU2hhcmVkTm90VXNlZCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVJbnMuc2hhcmVTY29wZU1hcCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZ2xvYmFsU2hhcmVTY29wZU1hcFtyZW1vdGVJbnNJZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5lZWREZWxldGVLZXlzLmZvckVhY2goKFtpbnNJZCwgc2hhcmVTY29wZSwgc2hhcmVOYW1lLCBzaGFyZVZlcnNpb25dKT0+e1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2dsb2JhbFNoYXJlU2NvcGVNYXBfaW5zSWRfc2hhcmVTY29wZV9zaGFyZU5hbWUsIF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkX3NoYXJlU2NvcGUsIF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkO1xuICAgICAgICAgICAgICAgICAgICAoX2dsb2JhbFNoYXJlU2NvcGVNYXBfaW5zSWQgPSBnbG9iYWxTaGFyZVNjb3BlTWFwW2luc0lkXSkgPT0gbnVsbCA/IHRydWUgOiAoX2dsb2JhbFNoYXJlU2NvcGVNYXBfaW5zSWRfc2hhcmVTY29wZSA9IF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkW3NoYXJlU2NvcGVdKSA9PSBudWxsID8gdHJ1ZSA6IChfZ2xvYmFsU2hhcmVTY29wZU1hcF9pbnNJZF9zaGFyZVNjb3BlX3NoYXJlTmFtZSA9IF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkX3NoYXJlU2NvcGVbc2hhcmVOYW1lXSkgPT0gbnVsbCA/IHRydWUgOiBkZWxldGUgX2dsb2JhbFNoYXJlU2NvcGVNYXBfaW5zSWRfc2hhcmVTY29wZV9zaGFyZU5hbWVbc2hhcmVWZXJzaW9uXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fSU5TVEFOQ0VTX18uc3BsaWNlKHJlbW90ZUluc0luZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvc3QubW9kdWxlQ2FjaGUuZGVsZXRlKHJlbW90ZS5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihob3N0KXtcbiAgICAgICAgdGhpcy5ob29rcyA9IG5ldyBQbHVnaW5TeXN0ZW0oe1xuICAgICAgICAgICAgYmVmb3JlUmVxdWVzdDogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vaygnYmVmb3JlUmVxdWVzdCcpLFxuICAgICAgICAgICAgb25Mb2FkOiBuZXcgQXN5bmNIb29rKCdvbkxvYWQnKSxcbiAgICAgICAgICAgIGhhbmRsZVByZWxvYWRNb2R1bGU6IG5ldyBTeW5jSG9vaygnaGFuZGxlUHJlbG9hZE1vZHVsZScpLFxuICAgICAgICAgICAgZXJyb3JMb2FkUmVtb3RlOiBuZXcgQXN5bmNIb29rKCdlcnJvckxvYWRSZW1vdGUnKSxcbiAgICAgICAgICAgIGJlZm9yZVByZWxvYWRSZW1vdGU6IG5ldyBBc3luY0hvb2soKSxcbiAgICAgICAgICAgIGdlbmVyYXRlUHJlbG9hZEFzc2V0czogbmV3IEFzeW5jSG9vaygnZ2VuZXJhdGVQcmVsb2FkQXNzZXRzJyksXG4gICAgICAgICAgICAvLyBub3QgdXNlZCB5ZXRcbiAgICAgICAgICAgIGFmdGVyUHJlbG9hZFJlbW90ZTogbmV3IEFzeW5jSG9vaygpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2Upe1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmNsYXNzIEZlZGVyYXRpb25Ib3N0IHtcbiAgICBpbml0T3B0aW9ucyh1c2VyT3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyUGx1Z2lucyh1c2VyT3B0aW9ucy5wbHVnaW5zKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZm9ybWF0T3B0aW9ucyh0aGlzLm9wdGlvbnMsIHVzZXJPcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRTaGFyZShwa2dOYW1lLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmVkSGFuZGxlci5sb2FkU2hhcmUocGtnTmFtZSwgZXh0cmFPcHRpb25zKTtcbiAgICB9XG4gICAgLy8gVGhlIGxpYiBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgYXZhaWxhYmxlIGlmIHRoZSBzaGFyZWQgc2V0IGJ5IGVhZ2VyIG9yIHJ1bnRpbWUgaW5pdCBpcyBzZXQgb3IgdGhlIHNoYXJlZCBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgIC8vIDEuIElmIHRoZSBsb2FkZWQgc2hhcmVkIGFscmVhZHkgZXhpc3RzIGdsb2JhbGx5LCB0aGVuIGl0IHdpbGwgYmUgcmV1c2VkXG4gICAgLy8gMi4gSWYgbGliIGV4aXN0cyBpbiBsb2NhbCBzaGFyZWQsIGl0IHdpbGwgYmUgdXNlZCBkaXJlY3RseVxuICAgIC8vIDMuIElmIHRoZSBsb2NhbCBnZXQgcmV0dXJucyBzb21ldGhpbmcgb3RoZXIgdGhhbiBQcm9taXNlLCB0aGVuIGl0IHdpbGwgYmUgdXNlZCBkaXJlY3RseVxuICAgIGxvYWRTaGFyZVN5bmMocGtnTmFtZSwgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXJlZEhhbmRsZXIubG9hZFNoYXJlU3luYyhwa2dOYW1lLCBleHRyYU9wdGlvbnMpO1xuICAgIH1cbiAgICBpbml0aWFsaXplU2hhcmluZyhzaGFyZVNjb3BlTmFtZSA9IERFRkFVTFRfU0NPUEUsIHN0cmF0ZWd5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXJlZEhhbmRsZXIuaW5pdGlhbGl6ZVNoYXJpbmcoc2hhcmVTY29wZU5hbWUsIHN0cmF0ZWd5KTtcbiAgICB9XG4gICAgaW5pdFJhd0NvbnRhaW5lcihuYW1lLCB1cmwsIGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCByZW1vdGVJbmZvID0gZ2V0UmVtb3RlSW5mbyh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZW50cnk6IHVybFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gbmV3IE1vZHVsZSh7XG4gICAgICAgICAgICBob3N0OiB0aGlzLFxuICAgICAgICAgICAgcmVtb3RlSW5mb1xuICAgICAgICB9KTtcbiAgICAgICAgbW9kdWxlLnJlbW90ZUVudHJ5RXhwb3J0cyA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5tb2R1bGVDYWNoZS5zZXQobmFtZSwgbW9kdWxlKTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1saW5lcy1wZXItZnVuY3Rpb25cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZ1xuICAgIGFzeW5jIGxvYWRSZW1vdGUoaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlSGFuZGxlci5sb2FkUmVtb3RlKGlkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9tZW1iZXItb3JkZXJpbmdcbiAgICBhc3luYyBwcmVsb2FkUmVtb3RlKHByZWxvYWRPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZUhhbmRsZXIucHJlbG9hZFJlbW90ZShwcmVsb2FkT3B0aW9ucyk7XG4gICAgfVxuICAgIGluaXRTaGFyZVNjb3BlTWFwKHNjb3BlTmFtZSwgc2hhcmVTY29wZSkge1xuICAgICAgICB0aGlzLnNoYXJlZEhhbmRsZXIuaW5pdFNoYXJlU2NvcGVNYXAoc2NvcGVOYW1lLCBzaGFyZVNjb3BlKTtcbiAgICB9XG4gICAgZm9ybWF0T3B0aW9ucyhnbG9iYWxPcHRpb25zLCB1c2VyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHNoYXJlZCB9ID0gZm9ybWF0U2hhcmVDb25maWdzKGdsb2JhbE9wdGlvbnMsIHVzZXJPcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyB1c2VyT3B0aW9uczogdXNlck9wdGlvbnNSZXMsIG9wdGlvbnM6IGdsb2JhbE9wdGlvbnNSZXMgfSA9IHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZUluaXQuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW46IHRoaXMsXG4gICAgICAgICAgICB1c2VyT3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnM6IGdsb2JhbE9wdGlvbnMsXG4gICAgICAgICAgICBzaGFyZUluZm86IHNoYXJlZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVtb3RlcyA9IHRoaXMucmVtb3RlSGFuZGxlci5mb3JtYXRBbmRSZWdpc3RlclJlbW90ZShnbG9iYWxPcHRpb25zUmVzLCB1c2VyT3B0aW9uc1Jlcyk7XG4gICAgICAgIGNvbnN0IHsgc2hhcmVkOiBoYW5kbGVkU2hhcmVkIH0gPSB0aGlzLnNoYXJlZEhhbmRsZXIucmVnaXN0ZXJTaGFyZWQoZ2xvYmFsT3B0aW9uc1JlcywgdXNlck9wdGlvbnNSZXMpO1xuICAgICAgICBjb25zdCBwbHVnaW5zID0gW1xuICAgICAgICAgICAgLi4uZ2xvYmFsT3B0aW9uc1Jlcy5wbHVnaW5zXG4gICAgICAgIF07XG4gICAgICAgIGlmICh1c2VyT3B0aW9uc1Jlcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICB1c2VyT3B0aW9uc1Jlcy5wbHVnaW5zLmZvckVhY2goKHBsdWdpbik9PntcbiAgICAgICAgICAgICAgICBpZiAoIXBsdWdpbnMuaW5jbHVkZXMocGx1Z2luKSkge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zUmVzID0gX2V4dGVuZHMoe30sIGdsb2JhbE9wdGlvbnMsIHVzZXJPcHRpb25zLCB7XG4gICAgICAgICAgICBwbHVnaW5zLFxuICAgICAgICAgICAgcmVtb3RlcyxcbiAgICAgICAgICAgIHNoYXJlZDogaGFuZGxlZFNoYXJlZFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ob29rcy5saWZlY3ljbGUuaW5pdC5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbjogdGhpcyxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNSZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zUmVzO1xuICAgIH1cbiAgICByZWdpc3RlclBsdWdpbnMocGx1Z2lucykge1xuICAgICAgICBjb25zdCBwbHVnaW5SZXMgPSByZWdpc3RlclBsdWdpbnMkMShwbHVnaW5zLCBbXG4gICAgICAgICAgICB0aGlzLmhvb2tzLFxuICAgICAgICAgICAgdGhpcy5yZW1vdGVIYW5kbGVyLmhvb2tzLFxuICAgICAgICAgICAgdGhpcy5zaGFyZWRIYW5kbGVyLmhvb2tzLFxuICAgICAgICAgICAgdGhpcy5zbmFwc2hvdEhhbmRsZXIuaG9va3MsXG4gICAgICAgICAgICB0aGlzLmxvYWRlckhvb2tcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIE1lcmdlIHBsdWdpblxuICAgICAgICB0aGlzLm9wdGlvbnMucGx1Z2lucyA9IHRoaXMub3B0aW9ucy5wbHVnaW5zLnJlZHVjZSgocmVzLCBwbHVnaW4pPT57XG4gICAgICAgICAgICBpZiAoIXBsdWdpbikgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIGlmIChyZXMgJiYgIXJlcy5maW5kKChpdGVtKT0+aXRlbS5uYW1lID09PSBwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwgcGx1Z2luUmVzIHx8IFtdKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJSZW1vdGVzKHJlbW90ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlSGFuZGxlci5yZWdpc3RlclJlbW90ZXMocmVtb3Rlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHVzZXJPcHRpb25zKXtcbiAgICAgICAgdGhpcy5ob29rcyA9IG5ldyBQbHVnaW5TeXN0ZW0oe1xuICAgICAgICAgICAgYmVmb3JlSW5pdDogbmV3IFN5bmNXYXRlcmZhbGxIb29rKCdiZWZvcmVJbml0JyksXG4gICAgICAgICAgICBpbml0OiBuZXcgU3luY0hvb2soKSxcbiAgICAgICAgICAgIC8vIG1heWJlIHdpbGwgY2hhbmdlLCB0ZW1wb3JhcmlseSBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgICAgICAgIGJlZm9yZUluaXRDb250YWluZXI6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2JlZm9yZUluaXRDb250YWluZXInKSxcbiAgICAgICAgICAgIC8vIG1heWJlIHdpbGwgY2hhbmdlLCB0ZW1wb3JhcmlseSBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgICAgICAgIGluaXRDb250YWluZXI6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2luaXRDb250YWluZXInKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCIwLjEuMTVcIjtcbiAgICAgICAgdGhpcy5tb2R1bGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sb2FkZXJIb29rID0gbmV3IFBsdWdpblN5c3RlbSh7XG4gICAgICAgICAgICAvLyBGSVhNRTogbWF5IG5vdCBiZSBzdWl0YWJsZSAsIG5vdCBvcGVuIHRvIHRoZSBwdWJsaWMgeWV0XG4gICAgICAgICAgICBnZXRNb2R1bGVJbmZvOiBuZXcgU3luY0hvb2soKSxcbiAgICAgICAgICAgIGNyZWF0ZVNjcmlwdDogbmV3IFN5bmNIb29rKCksXG4gICAgICAgICAgICBjcmVhdGVMaW5rOiBuZXcgU3luY0hvb2soKSxcbiAgICAgICAgICAgIC8vIG9ubHkgd29yayBmb3IgbWFuaWZlc3QgLCBzbyBub3Qgb3BlbiB0byB0aGUgcHVibGljIHlldFxuICAgICAgICAgICAgZmV0Y2g6IG5ldyBBc3luY0hvb2soJ2ZldGNoJylcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoZSBkZXRhaWxzIG9mIHRoZSBvcHRpb25zXG4gICAgICAgIC8vIEluaXRpYWxpemUgb3B0aW9ucyB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgaWQ6IGdldEJ1aWxkZXJJZCgpLFxuICAgICAgICAgICAgbmFtZTogdXNlck9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgICAgICBzbmFwc2hvdFBsdWdpbigpLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlUHJlbG9hZEFzc2V0c1BsdWdpbigpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcmVtb3RlczogW10sXG4gICAgICAgICAgICBzaGFyZWQ6IHt9LFxuICAgICAgICAgICAgaW5Ccm93c2VyOiBpc0Jyb3dzZXJFbnYkMSgpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmFtZSA9IHVzZXJPcHRpb25zLm5hbWU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgICAgICB0aGlzLnNuYXBzaG90SGFuZGxlciA9IG5ldyBTbmFwc2hvdEhhbmRsZXIodGhpcyk7XG4gICAgICAgIHRoaXMuc2hhcmVkSGFuZGxlciA9IG5ldyBTaGFyZWRIYW5kbGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW90ZUhhbmRsZXIgPSBuZXcgUmVtb3RlSGFuZGxlcih0aGlzKTtcbiAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwID0gdGhpcy5zaGFyZWRIYW5kbGVyLnNoYXJlU2NvcGVNYXA7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJQbHVnaW5zKFtcbiAgICAgICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLnBsdWdpbnMsXG4gICAgICAgICAgICAuLi51c2VyT3B0aW9ucy5wbHVnaW5zIHx8IFtdXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmZvcm1hdE9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIHVzZXJPcHRpb25zKTtcbiAgICB9XG59XG5cbmxldCBGZWRlcmF0aW9uSW5zdGFuY2UgPSBudWxsO1xuZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgLy8gUmV0cmlldmUgdGhlIHNhbWUgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBuYW1lXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2Uob3B0aW9ucy5uYW1lLCBvcHRpb25zLnZlcnNpb24pO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gUmV0cmlldmUgZGVidWcgY29uc3RydWN0b3JcbiAgICAgICAgY29uc3QgRmVkZXJhdGlvbkNvbnN0cnVjdG9yID0gZ2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yKCkgfHwgRmVkZXJhdGlvbkhvc3Q7XG4gICAgICAgIEZlZGVyYXRpb25JbnN0YW5jZSA9IG5ldyBGZWRlcmF0aW9uQ29uc3RydWN0b3Iob3B0aW9ucyk7XG4gICAgICAgIHNldEdsb2JhbEZlZGVyYXRpb25JbnN0YW5jZShGZWRlcmF0aW9uSW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gRmVkZXJhdGlvbkluc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIG9wdGlvbnNcbiAgICAgICAgaW5zdGFuY2UuaW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmICghRmVkZXJhdGlvbkluc3RhbmNlKSB7XG4gICAgICAgICAgICBGZWRlcmF0aW9uSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9hZFJlbW90ZSguLi5hcmdzKSB7XG4gICAgYXNzZXJ0KEZlZGVyYXRpb25JbnN0YW5jZSwgJ1BsZWFzZSBjYWxsIGluaXQgZmlyc3QnKTtcbiAgICBjb25zdCBsb2FkUmVtb3RlMSA9IEZlZGVyYXRpb25JbnN0YW5jZS5sb2FkUmVtb3RlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgcmV0dXJuIGxvYWRSZW1vdGUxLmFwcGx5KEZlZGVyYXRpb25JbnN0YW5jZSwgYXJncyk7XG59XG5mdW5jdGlvbiBsb2FkU2hhcmUoLi4uYXJncykge1xuICAgIGFzc2VydChGZWRlcmF0aW9uSW5zdGFuY2UsICdQbGVhc2UgY2FsbCBpbml0IGZpcnN0Jyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICBjb25zdCBsb2FkU2hhcmUxID0gRmVkZXJhdGlvbkluc3RhbmNlLmxvYWRTaGFyZTtcbiAgICByZXR1cm4gbG9hZFNoYXJlMS5hcHBseShGZWRlcmF0aW9uSW5zdGFuY2UsIGFyZ3MpO1xufVxuZnVuY3Rpb24gbG9hZFNoYXJlU3luYyguLi5hcmdzKSB7XG4gICAgYXNzZXJ0KEZlZGVyYXRpb25JbnN0YW5jZSwgJ1BsZWFzZSBjYWxsIGluaXQgZmlyc3QnKTtcbiAgICBjb25zdCBsb2FkU2hhcmVTeW5jMSA9IEZlZGVyYXRpb25JbnN0YW5jZS5sb2FkU2hhcmVTeW5jO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgcmV0dXJuIGxvYWRTaGFyZVN5bmMxLmFwcGx5KEZlZGVyYXRpb25JbnN0YW5jZSwgYXJncyk7XG59XG5mdW5jdGlvbiBwcmVsb2FkUmVtb3RlKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoRmVkZXJhdGlvbkluc3RhbmNlLCAnUGxlYXNlIGNhbGwgaW5pdCBmaXJzdCcpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgcmV0dXJuIEZlZGVyYXRpb25JbnN0YW5jZS5wcmVsb2FkUmVtb3RlLmFwcGx5KEZlZGVyYXRpb25JbnN0YW5jZSwgYXJncyk7XG59XG5mdW5jdGlvbiByZWdpc3RlclJlbW90ZXMoLi4uYXJncykge1xuICAgIGFzc2VydChGZWRlcmF0aW9uSW5zdGFuY2UsICdQbGVhc2UgY2FsbCBpbml0IGZpcnN0Jyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICByZXR1cm4gRmVkZXJhdGlvbkluc3RhbmNlLnJlZ2lzdGVyUmVtb3Rlcy5hcHBseShGZWRlcmF0aW9uSW5zdGFuY2UsIGFyZ3MpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoRmVkZXJhdGlvbkluc3RhbmNlLCAnUGxlYXNlIGNhbGwgaW5pdCBmaXJzdCcpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgcmV0dXJuIEZlZGVyYXRpb25JbnN0YW5jZS5yZWdpc3RlclBsdWdpbnMuYXBwbHkoRmVkZXJhdGlvbkluc3RhbmNlLCBhcmdzKTtcbn1cbi8vIEluamVjdCBmb3IgZGVidWdcbnNldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvcihGZWRlcmF0aW9uSG9zdCk7XG5cbmV4cG9ydCB7IEZlZGVyYXRpb25Ib3N0LCBnZXRSZW1vdGVFbnRyeSwgZ2V0UmVtb3RlSW5mbywgaW5pdCwgbG9hZFJlbW90ZSwgbG9hZFNoYXJlLCBsb2FkU2hhcmVTeW5jLCBwcmVsb2FkUmVtb3RlLCByZWdpc3RlclBsdWdpbnMsIHJlZ2lzdGVyUmVtb3RlcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@module-federation/runtime/dist/index.esm.js\n");

/***/ }),

/***/ "../../node_modules/@module-federation/runtime/dist/share.esm.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@module-federation/runtime/dist/share.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ getBuilderId),\n/* harmony export */   B: () => (/* binding */ isBrowserEnv),\n/* harmony export */   C: () => (/* binding */ setGlobalFederationConstructor),\n/* harmony export */   D: () => (/* binding */ DEFAULT_REMOTE_TYPE),\n/* harmony export */   E: () => (/* binding */ getGlobalFederationInstance),\n/* harmony export */   F: () => (/* binding */ getGlobalFederationConstructor),\n/* harmony export */   G: () => (/* binding */ Global),\n/* harmony export */   H: () => (/* binding */ setGlobalFederationInstance),\n/* harmony export */   I: () => (/* binding */ registerGlobalPlugins),\n/* harmony export */   J: () => (/* binding */ nativeGlobal),\n/* harmony export */   K: () => (/* binding */ resetFederationGlobalInfo),\n/* harmony export */   L: () => (/* binding */ getTargetSnapshotInfoByModuleInfo),\n/* harmony export */   a: () => (/* binding */ globalLoading),\n/* harmony export */   b: () => (/* binding */ DEFAULT_SCOPE),\n/* harmony export */   c: () => (/* binding */ getRemoteEntryExports),\n/* harmony export */   d: () => (/* binding */ assert),\n/* harmony export */   e: () => (/* binding */ getFMId),\n/* harmony export */   f: () => (/* binding */ error),\n/* harmony export */   g: () => (/* binding */ getGlobalHostPlugins),\n/* harmony export */   h: () => (/* binding */ isPlainObject),\n/* harmony export */   i: () => (/* binding */ isObject),\n/* harmony export */   j: () => (/* binding */ isRemoteInfoWithEntry),\n/* harmony export */   k: () => (/* binding */ isPureRemoteEntry),\n/* harmony export */   l: () => (/* binding */ getInfoWithoutType),\n/* harmony export */   m: () => (/* binding */ getPreloaded),\n/* harmony export */   n: () => (/* binding */ setPreloaded),\n/* harmony export */   o: () => (/* binding */ getRegisteredShare),\n/* harmony export */   p: () => (/* binding */ arrayOptions),\n/* harmony export */   q: () => (/* binding */ getGlobalSnapshotInfoByModuleInfo),\n/* harmony export */   r: () => (/* binding */ addGlobalSnapshot),\n/* harmony export */   s: () => (/* binding */ safeToString),\n/* harmony export */   t: () => (/* binding */ setGlobalSnapshotInfoByModuleInfo),\n/* harmony export */   u: () => (/* binding */ getGlobalSnapshot),\n/* harmony export */   v: () => (/* binding */ formatShareConfigs),\n/* harmony export */   w: () => (/* binding */ warn),\n/* harmony export */   x: () => (/* binding */ getTargetSharedOptions),\n/* harmony export */   y: () => (/* binding */ getGlobalShareScope),\n/* harmony export */   z: () => (/* binding */ addUniqueItem)\n/* harmony export */ });\nfunction getBuilderId() {\n    //@ts-ignore\n    return  true ? \"moduleAppB:1.0.0\" : 0;\n}\nfunction isDebugMode() {\n    return Boolean(\"\");\n}\nfunction isBrowserEnv() {\n    return typeof window !== 'undefined';\n}\n\nconst LOG_CATEGORY = '[ Federation Runtime ]';\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction assert(condition, msg) {\n    if (!condition) {\n        error(msg);\n    }\n}\nfunction error(msg) {\n    if (msg instanceof Error) {\n        msg.message = `${LOG_CATEGORY}: ${msg.message}`;\n        throw msg;\n    }\n    throw new Error(`${LOG_CATEGORY}: ${msg}`);\n}\nfunction warn(msg) {\n    if (msg instanceof Error) {\n        msg.message = `${LOG_CATEGORY}: ${msg.message}`;\n        console.warn(msg);\n    } else {\n        console.warn(`${LOG_CATEGORY}: ${msg}`);\n    }\n}\n\nfunction addUniqueItem(arr, item) {\n    if (arr.findIndex((name)=>name === item) === -1) {\n        arr.push(item);\n    }\n    return arr;\n}\nfunction getFMId(remoteInfo) {\n    if ('version' in remoteInfo && remoteInfo.version) {\n        return `${remoteInfo.name}:${remoteInfo.version}`;\n    } else if ('entry' in remoteInfo && remoteInfo.entry) {\n        return `${remoteInfo.name}:${remoteInfo.entry}`;\n    } else {\n        return `${remoteInfo.name}`;\n    }\n}\nfunction isRemoteInfoWithEntry(remote) {\n    return typeof remote.entry !== 'undefined';\n}\nfunction isPureRemoteEntry(remote) {\n    return !remote.entry.includes('.json') && remote.entry.includes('.js');\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction safeToString(info) {\n    try {\n        return JSON.stringify(info, null, 2);\n    } catch (e) {\n        return '';\n    }\n}\nfunction isObject(val) {\n    return val && typeof val === 'object';\n}\nconst objectToString = Object.prototype.toString;\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isPlainObject(val) {\n    return objectToString.call(val) === '[object Object]';\n}\nfunction arrayOptions(options) {\n    return Array.isArray(options) ? options : [\n        options\n    ];\n}\n\nfunction _extends$1() {\n    _extends$1 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$1.apply(this, arguments);\n}\nfunction _object_without_properties_loose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nconst nativeGlobal = (()=>{\n    try {\n        return new Function('return this')();\n    } catch (e) {\n        return globalThis;\n    }\n})();\nconst Global = nativeGlobal;\nfunction definePropertyGlobalVal(target, key, val) {\n    Object.defineProperty(target, key, {\n        value: val,\n        configurable: false,\n        writable: true\n    });\n}\nfunction includeOwnProperty(target, key) {\n    return Object.hasOwnProperty.call(target, key);\n}\n// This section is to prevent encapsulation by certain microfrontend frameworks. Due to reuse policies, sandbox escapes.\n// The sandbox in the microfrontend does not replicate the value of 'configurable'.\n// If there is no loading content on the global object, this section defines the loading object.\nif (!includeOwnProperty(globalThis, '__GLOBAL_LOADING_REMOTE_ENTRY__')) {\n    definePropertyGlobalVal(globalThis, '__GLOBAL_LOADING_REMOTE_ENTRY__', {});\n}\nconst globalLoading = globalThis.__GLOBAL_LOADING_REMOTE_ENTRY__;\nfunction setGlobalDefaultVal(target) {\n    var _target___FEDERATION__, _target___FEDERATION__1, _target___FEDERATION__2, _target___FEDERATION__3, _target___FEDERATION__4, _target___FEDERATION__5;\n    if (includeOwnProperty(target, '__VMOK__') && !includeOwnProperty(target, '__FEDERATION__')) {\n        definePropertyGlobalVal(target, '__FEDERATION__', target.__VMOK__);\n    }\n    if (!includeOwnProperty(target, '__FEDERATION__')) {\n        definePropertyGlobalVal(target, '__FEDERATION__', {\n            __GLOBAL_PLUGIN__: [],\n            __INSTANCES__: [],\n            moduleInfo: {},\n            __SHARE__: {},\n            __MANIFEST_LOADING__: {},\n            __PRELOADED_MAP__: new Map()\n        });\n        definePropertyGlobalVal(target, '__VMOK__', target.__FEDERATION__);\n    }\n    var ___GLOBAL_PLUGIN__;\n    (___GLOBAL_PLUGIN__ = (_target___FEDERATION__ = target.__FEDERATION__).__GLOBAL_PLUGIN__) != null ? ___GLOBAL_PLUGIN__ : _target___FEDERATION__.__GLOBAL_PLUGIN__ = [];\n    var ___INSTANCES__;\n    (___INSTANCES__ = (_target___FEDERATION__1 = target.__FEDERATION__).__INSTANCES__) != null ? ___INSTANCES__ : _target___FEDERATION__1.__INSTANCES__ = [];\n    var _moduleInfo;\n    (_moduleInfo = (_target___FEDERATION__2 = target.__FEDERATION__).moduleInfo) != null ? _moduleInfo : _target___FEDERATION__2.moduleInfo = {};\n    var ___SHARE__;\n    (___SHARE__ = (_target___FEDERATION__3 = target.__FEDERATION__).__SHARE__) != null ? ___SHARE__ : _target___FEDERATION__3.__SHARE__ = {};\n    var ___MANIFEST_LOADING__;\n    (___MANIFEST_LOADING__ = (_target___FEDERATION__4 = target.__FEDERATION__).__MANIFEST_LOADING__) != null ? ___MANIFEST_LOADING__ : _target___FEDERATION__4.__MANIFEST_LOADING__ = {};\n    var ___PRELOADED_MAP__;\n    (___PRELOADED_MAP__ = (_target___FEDERATION__5 = target.__FEDERATION__).__PRELOADED_MAP__) != null ? ___PRELOADED_MAP__ : _target___FEDERATION__5.__PRELOADED_MAP__ = new Map();\n}\nsetGlobalDefaultVal(globalThis);\nsetGlobalDefaultVal(nativeGlobal);\nfunction resetFederationGlobalInfo() {\n    globalThis.__FEDERATION__.__GLOBAL_PLUGIN__ = [];\n    globalThis.__FEDERATION__.__INSTANCES__ = [];\n    globalThis.__FEDERATION__.moduleInfo = {};\n    globalThis.__FEDERATION__.__SHARE__ = {};\n    globalThis.__FEDERATION__.__MANIFEST_LOADING__ = {};\n}\nfunction getGlobalFederationInstance(name, version) {\n    const buildId = getBuilderId();\n    return globalThis.__FEDERATION__.__INSTANCES__.find((GMInstance)=>{\n        if (buildId && GMInstance.options.id === getBuilderId()) {\n            return true;\n        }\n        if (GMInstance.options.name === name && !GMInstance.options.version && !version) {\n            return true;\n        }\n        if (GMInstance.options.name === name && version && GMInstance.options.version === version) {\n            return true;\n        }\n        return false;\n    });\n}\nfunction setGlobalFederationInstance(FederationInstance) {\n    globalThis.__FEDERATION__.__INSTANCES__.push(FederationInstance);\n}\nfunction getGlobalFederationConstructor() {\n    return globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__;\n}\nfunction setGlobalFederationConstructor(FederationConstructor, isDebug = isDebugMode()) {\n    if (isDebug) {\n        globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__ = FederationConstructor;\n        globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR_VERSION__ = \"0.1.15\";\n    }\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction getInfoWithoutType(target, key) {\n    if (typeof key === 'string') {\n        const keyRes = target[key];\n        if (keyRes) {\n            return {\n                value: target[key],\n                key: key\n            };\n        } else {\n            const targetKeys = Object.keys(target);\n            for (const targetKey of targetKeys){\n                const [targetTypeOrName, _] = targetKey.split(':');\n                const nKey = `${targetTypeOrName}:${key}`;\n                const typeWithKeyRes = target[nKey];\n                if (typeWithKeyRes) {\n                    return {\n                        value: typeWithKeyRes,\n                        key: nKey\n                    };\n                }\n            }\n            return {\n                value: undefined,\n                key: key\n            };\n        }\n    } else {\n        throw new Error('key must be string');\n    }\n}\nconst getGlobalSnapshot = ()=>nativeGlobal.__FEDERATION__.moduleInfo;\nconst getTargetSnapshotInfoByModuleInfo = (moduleInfo, snapshot)=>{\n    // Check if the remote is included in the hostSnapshot\n    const moduleKey = getFMId(moduleInfo);\n    const getModuleInfo = getInfoWithoutType(snapshot, moduleKey).value;\n    // The remoteSnapshot might not include a version\n    if (getModuleInfo && !getModuleInfo.version && 'version' in moduleInfo && moduleInfo['version']) {\n        getModuleInfo.version = moduleInfo['version'];\n    }\n    if (getModuleInfo) {\n        return getModuleInfo;\n    }\n    // If the remote is not included in the hostSnapshot, deploy a micro app snapshot\n    if ('version' in moduleInfo && moduleInfo['version']) {\n        const { version } = moduleInfo, resModuleInfo = _object_without_properties_loose(moduleInfo, [\n            \"version\"\n        ]);\n        const moduleKeyWithoutVersion = getFMId(resModuleInfo);\n        const getModuleInfoWithoutVersion = getInfoWithoutType(nativeGlobal.__FEDERATION__.moduleInfo, moduleKeyWithoutVersion).value;\n        if ((getModuleInfoWithoutVersion == null ? void 0 : getModuleInfoWithoutVersion.version) === version) {\n            return getModuleInfoWithoutVersion;\n        }\n    }\n    return;\n};\nconst getGlobalSnapshotInfoByModuleInfo = (moduleInfo)=>getTargetSnapshotInfoByModuleInfo(moduleInfo, nativeGlobal.__FEDERATION__.moduleInfo);\nconst setGlobalSnapshotInfoByModuleInfo = (remoteInfo, moduleDetailInfo)=>{\n    const moduleKey = getFMId(remoteInfo);\n    nativeGlobal.__FEDERATION__.moduleInfo[moduleKey] = moduleDetailInfo;\n    return nativeGlobal.__FEDERATION__.moduleInfo;\n};\nconst addGlobalSnapshot = (moduleInfos)=>{\n    nativeGlobal.__FEDERATION__.moduleInfo = _extends$1({}, nativeGlobal.__FEDERATION__.moduleInfo, moduleInfos);\n    return ()=>{\n        const keys = Object.keys(moduleInfos);\n        for (const key of keys){\n            delete nativeGlobal.__FEDERATION__.moduleInfo[key];\n        }\n    };\n};\nconst getRemoteEntryExports = (name, globalName)=>{\n    const remoteEntryKey = globalName || `__FEDERATION_${name}:custom__`;\n    const entryExports = globalThis[remoteEntryKey];\n    return {\n        remoteEntryKey,\n        entryExports\n    };\n};\n// This function is used to register global plugins.\n// It iterates over the provided plugins and checks if they are already registered.\n// If a plugin is not registered, it is added to the global plugins.\n// If a plugin is already registered, a warning message is logged.\nconst registerGlobalPlugins = (plugins)=>{\n    const { __GLOBAL_PLUGIN__ } = nativeGlobal.__FEDERATION__;\n    plugins.forEach((plugin)=>{\n        if (__GLOBAL_PLUGIN__.findIndex((p)=>p.name === plugin.name) === -1) {\n            __GLOBAL_PLUGIN__.push(plugin);\n        } else {\n            warn(`The plugin ${plugin.name} has been registered.`);\n        }\n    });\n};\nconst getGlobalHostPlugins = ()=>nativeGlobal.__FEDERATION__.__GLOBAL_PLUGIN__;\nconst getPreloaded = (id)=>globalThis.__FEDERATION__.__PRELOADED_MAP__.get(id);\nconst setPreloaded = (id)=>globalThis.__FEDERATION__.__PRELOADED_MAP__.set(id, true);\n\nconst DEFAULT_SCOPE = 'default';\nconst DEFAULT_REMOTE_TYPE = 'global';\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\n// those constants are based on https://www.rubydoc.info/gems/semantic_range/3.0.0/SemanticRange#BUILDIDENTIFIER-constant\n// Copyright (c)\n// vite-plugin-federation is licensed under Mulan PSL v2.\n// You can use this software according to the terms and conditions of the Mulan PSL v2.\n// You may obtain a copy of Mulan PSL v2 at:\n//      http://license.coscl.org.cn/MulanPSL2\n// THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\n// See the Mulan PSL v2 for more details.\nconst buildIdentifier = '[0-9A-Za-z-]+';\nconst build = `(?:\\\\+(${buildIdentifier}(?:\\\\.${buildIdentifier})*))`;\nconst numericIdentifier = '0|[1-9]\\\\d*';\nconst numericIdentifierLoose = '[0-9]+';\nconst nonNumericIdentifier = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\nconst preReleaseIdentifierLoose = `(?:${numericIdentifierLoose}|${nonNumericIdentifier})`;\nconst preReleaseLoose = `(?:-?(${preReleaseIdentifierLoose}(?:\\\\.${preReleaseIdentifierLoose})*))`;\nconst preReleaseIdentifier = `(?:${numericIdentifier}|${nonNumericIdentifier})`;\nconst preRelease = `(?:-(${preReleaseIdentifier}(?:\\\\.${preReleaseIdentifier})*))`;\nconst xRangeIdentifier = `${numericIdentifier}|x|X|\\\\*`;\nconst xRangePlain = `[v=\\\\s]*(${xRangeIdentifier})(?:\\\\.(${xRangeIdentifier})(?:\\\\.(${xRangeIdentifier})(?:${preRelease})?${build}?)?)?`;\nconst hyphenRange = `^\\\\s*(${xRangePlain})\\\\s+-\\\\s+(${xRangePlain})\\\\s*$`;\nconst mainVersionLoose = `(${numericIdentifierLoose})\\\\.(${numericIdentifierLoose})\\\\.(${numericIdentifierLoose})`;\nconst loosePlain = `[v=\\\\s]*${mainVersionLoose}${preReleaseLoose}?${build}?`;\nconst gtlt = '((?:<|>)?=?)';\nconst comparatorTrim = `(\\\\s*)${gtlt}\\\\s*(${loosePlain}|${xRangePlain})`;\nconst loneTilde = '(?:~>?)';\nconst tildeTrim = `(\\\\s*)${loneTilde}\\\\s+`;\nconst loneCaret = '(?:\\\\^)';\nconst caretTrim = `(\\\\s*)${loneCaret}\\\\s+`;\nconst star = '(<|>)?=?\\\\s*\\\\*';\nconst caret = `^${loneCaret}${xRangePlain}$`;\nconst mainVersion = `(${numericIdentifier})\\\\.(${numericIdentifier})\\\\.(${numericIdentifier})`;\nconst fullPlain = `v?${mainVersion}${preRelease}?${build}?`;\nconst tilde = `^${loneTilde}${xRangePlain}$`;\nconst xRange = `^${gtlt}\\\\s*${xRangePlain}$`;\nconst comparator = `^${gtlt}\\\\s*(${fullPlain})$|^$`;\n// copy from semver package\nconst gte0 = '^\\\\s*>=\\\\s*0.0.0\\\\s*$';\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\nfunction parseRegex(source) {\n    return new RegExp(source);\n}\nfunction isXVersion(version) {\n    return !version || version.toLowerCase() === 'x' || version === '*';\n}\nfunction pipe(...fns) {\n    return (x)=>fns.reduce((v, f)=>f(v), x);\n}\nfunction extractComparator(comparatorString) {\n    return comparatorString.match(parseRegex(comparator));\n}\nfunction combineVersion(major, minor, patch, preRelease) {\n    const mainVersion = `${major}.${minor}.${patch}`;\n    if (preRelease) {\n        return `${mainVersion}-${preRelease}`;\n    }\n    return mainVersion;\n}\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\nfunction parseHyphen(range) {\n    return range.replace(parseRegex(hyphenRange), (_range, from, fromMajor, fromMinor, fromPatch, _fromPreRelease, _fromBuild, to, toMajor, toMinor, toPatch, toPreRelease)=>{\n        if (isXVersion(fromMajor)) {\n            from = '';\n        } else if (isXVersion(fromMinor)) {\n            from = `>=${fromMajor}.0.0`;\n        } else if (isXVersion(fromPatch)) {\n            from = `>=${fromMajor}.${fromMinor}.0`;\n        } else {\n            from = `>=${from}`;\n        }\n        if (isXVersion(toMajor)) {\n            to = '';\n        } else if (isXVersion(toMinor)) {\n            to = `<${Number(toMajor) + 1}.0.0-0`;\n        } else if (isXVersion(toPatch)) {\n            to = `<${toMajor}.${Number(toMinor) + 1}.0-0`;\n        } else if (toPreRelease) {\n            to = `<=${toMajor}.${toMinor}.${toPatch}-${toPreRelease}`;\n        } else {\n            to = `<=${to}`;\n        }\n        return `${from} ${to}`.trim();\n    });\n}\nfunction parseComparatorTrim(range) {\n    return range.replace(parseRegex(comparatorTrim), '$1$2$3');\n}\nfunction parseTildeTrim(range) {\n    return range.replace(parseRegex(tildeTrim), '$1~');\n}\nfunction parseCaretTrim(range) {\n    return range.replace(parseRegex(caretTrim), '$1^');\n}\nfunction parseCarets(range) {\n    return range.trim().split(/\\s+/).map((rangeVersion)=>rangeVersion.replace(parseRegex(caret), (_, major, minor, patch, preRelease)=>{\n            if (isXVersion(major)) {\n                return '';\n            } else if (isXVersion(minor)) {\n                return `>=${major}.0.0 <${Number(major) + 1}.0.0-0`;\n            } else if (isXVersion(patch)) {\n                if (major === '0') {\n                    return `>=${major}.${minor}.0 <${major}.${Number(minor) + 1}.0-0`;\n                } else {\n                    return `>=${major}.${minor}.0 <${Number(major) + 1}.0.0-0`;\n                }\n            } else if (preRelease) {\n                if (major === '0') {\n                    if (minor === '0') {\n                        return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${minor}.${Number(patch) + 1}-0`;\n                    } else {\n                        return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${Number(minor) + 1}.0-0`;\n                    }\n                } else {\n                    return `>=${major}.${minor}.${patch}-${preRelease} <${Number(major) + 1}.0.0-0`;\n                }\n            } else {\n                if (major === '0') {\n                    if (minor === '0') {\n                        return `>=${major}.${minor}.${patch} <${major}.${minor}.${Number(patch) + 1}-0`;\n                    } else {\n                        return `>=${major}.${minor}.${patch} <${major}.${Number(minor) + 1}.0-0`;\n                    }\n                }\n                return `>=${major}.${minor}.${patch} <${Number(major) + 1}.0.0-0`;\n            }\n        })).join(' ');\n}\nfunction parseTildes(range) {\n    return range.trim().split(/\\s+/).map((rangeVersion)=>rangeVersion.replace(parseRegex(tilde), (_, major, minor, patch, preRelease)=>{\n            if (isXVersion(major)) {\n                return '';\n            } else if (isXVersion(minor)) {\n                return `>=${major}.0.0 <${Number(major) + 1}.0.0-0`;\n            } else if (isXVersion(patch)) {\n                return `>=${major}.${minor}.0 <${major}.${Number(minor) + 1}.0-0`;\n            } else if (preRelease) {\n                return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${Number(minor) + 1}.0-0`;\n            }\n            return `>=${major}.${minor}.${patch} <${major}.${Number(minor) + 1}.0-0`;\n        })).join(' ');\n}\nfunction parseXRanges(range) {\n    return range.split(/\\s+/).map((rangeVersion)=>rangeVersion.trim().replace(parseRegex(xRange), (ret, gtlt, major, minor, patch, preRelease)=>{\n            const isXMajor = isXVersion(major);\n            const isXMinor = isXMajor || isXVersion(minor);\n            const isXPatch = isXMinor || isXVersion(patch);\n            if (gtlt === '=' && isXPatch) {\n                gtlt = '';\n            }\n            preRelease = '';\n            if (isXMajor) {\n                if (gtlt === '>' || gtlt === '<') {\n                    // nothing is allowed\n                    return '<0.0.0-0';\n                } else {\n                    // nothing is forbidden\n                    return '*';\n                }\n            } else if (gtlt && isXPatch) {\n                // replace X with 0\n                if (isXMinor) {\n                    minor = 0;\n                }\n                patch = 0;\n                if (gtlt === '>') {\n                    // >1 => >=2.0.0\n                    // >1.2 => >=1.3.0\n                    gtlt = '>=';\n                    if (isXMinor) {\n                        major = Number(major) + 1;\n                        minor = 0;\n                        patch = 0;\n                    } else {\n                        minor = Number(minor) + 1;\n                        patch = 0;\n                    }\n                } else if (gtlt === '<=') {\n                    // <=0.7.x is actually <0.8.0, since any 0.7.x should pass\n                    // Similarly, <=7.x is actually <8.0.0, etc.\n                    gtlt = '<';\n                    if (isXMinor) {\n                        major = Number(major) + 1;\n                    } else {\n                        minor = Number(minor) + 1;\n                    }\n                }\n                if (gtlt === '<') {\n                    preRelease = '-0';\n                }\n                return `${gtlt + major}.${minor}.${patch}${preRelease}`;\n            } else if (isXMinor) {\n                return `>=${major}.0.0${preRelease} <${Number(major) + 1}.0.0-0`;\n            } else if (isXPatch) {\n                return `>=${major}.${minor}.0${preRelease} <${major}.${Number(minor) + 1}.0-0`;\n            }\n            return ret;\n        })).join(' ');\n}\nfunction parseStar(range) {\n    return range.trim().replace(parseRegex(star), '');\n}\nfunction parseGTE0(comparatorString) {\n    return comparatorString.trim().replace(parseRegex(gte0), '');\n}\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\n// Copyright (c)\n// vite-plugin-federation is licensed under Mulan PSL v2.\n// You can use this software according to the terms and conditions of the Mulan PSL v2.\n// You may obtain a copy of Mulan PSL v2 at:\n//      http://license.coscl.org.cn/MulanPSL2\n// THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\n// See the Mulan PSL v2 for more details.\nfunction compareAtom(rangeAtom, versionAtom) {\n    rangeAtom = Number(rangeAtom) || rangeAtom;\n    versionAtom = Number(versionAtom) || versionAtom;\n    if (rangeAtom > versionAtom) {\n        return 1;\n    }\n    if (rangeAtom === versionAtom) {\n        return 0;\n    }\n    return -1;\n}\nfunction comparePreRelease(rangeAtom, versionAtom) {\n    const { preRelease: rangePreRelease } = rangeAtom;\n    const { preRelease: versionPreRelease } = versionAtom;\n    if (rangePreRelease === undefined && Boolean(versionPreRelease)) {\n        return 1;\n    }\n    if (Boolean(rangePreRelease) && versionPreRelease === undefined) {\n        return -1;\n    }\n    if (rangePreRelease === undefined && versionPreRelease === undefined) {\n        return 0;\n    }\n    for(let i = 0, n = rangePreRelease.length; i <= n; i++){\n        const rangeElement = rangePreRelease[i];\n        const versionElement = versionPreRelease[i];\n        if (rangeElement === versionElement) {\n            continue;\n        }\n        if (rangeElement === undefined && versionElement === undefined) {\n            return 0;\n        }\n        if (!rangeElement) {\n            return 1;\n        }\n        if (!versionElement) {\n            return -1;\n        }\n        return compareAtom(rangeElement, versionElement);\n    }\n    return 0;\n}\nfunction compareVersion(rangeAtom, versionAtom) {\n    return compareAtom(rangeAtom.major, versionAtom.major) || compareAtom(rangeAtom.minor, versionAtom.minor) || compareAtom(rangeAtom.patch, versionAtom.patch) || comparePreRelease(rangeAtom, versionAtom);\n}\nfunction eq(rangeAtom, versionAtom) {\n    return rangeAtom.version === versionAtom.version;\n}\nfunction compare(rangeAtom, versionAtom) {\n    switch(rangeAtom.operator){\n        case '':\n        case '=':\n            return eq(rangeAtom, versionAtom);\n        case '>':\n            return compareVersion(rangeAtom, versionAtom) < 0;\n        case '>=':\n            return eq(rangeAtom, versionAtom) || compareVersion(rangeAtom, versionAtom) < 0;\n        case '<':\n            return compareVersion(rangeAtom, versionAtom) > 0;\n        case '<=':\n            return eq(rangeAtom, versionAtom) || compareVersion(rangeAtom, versionAtom) > 0;\n        case undefined:\n            {\n                // mean * or x -> all versions\n                return true;\n            }\n        default:\n            return false;\n    }\n}\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\nfunction parseComparatorString(range) {\n    return pipe(// handle caret\n    // ^ --> * (any, kinda silly)\n    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n    // ^1.2.3 --> >=1.2.3 <2.0.0-0\n    // ^1.2.0 --> >=1.2.0 <2.0.0-0\n    parseCarets, // handle tilde\n    // ~, ~> --> * (any, kinda silly)\n    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n    parseTildes, parseXRanges, parseStar)(range);\n}\nfunction parseRange(range) {\n    return pipe(// handle hyphenRange\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    parseHyphen, // handle trim comparator\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    parseComparatorTrim, // handle trim tilde\n    // `~ 1.2.3` => `~1.2.3`\n    parseTildeTrim, // handle trim caret\n    // `^ 1.2.3` => `^1.2.3`\n    parseCaretTrim)(range.trim()).split(/\\s+/).join(' ');\n}\nfunction satisfy(version, range) {\n    if (!version) {\n        return false;\n    }\n    const parsedRange = parseRange(range);\n    const parsedComparator = parsedRange.split(' ').map((rangeVersion)=>parseComparatorString(rangeVersion)).join(' ');\n    const comparators = parsedComparator.split(/\\s+/).map((comparator)=>parseGTE0(comparator));\n    const extractedVersion = extractComparator(version);\n    if (!extractedVersion) {\n        return false;\n    }\n    const [, versionOperator, , versionMajor, versionMinor, versionPatch, versionPreRelease] = extractedVersion;\n    const versionAtom = {\n        operator: versionOperator,\n        version: combineVersion(versionMajor, versionMinor, versionPatch, versionPreRelease),\n        major: versionMajor,\n        minor: versionMinor,\n        patch: versionPatch,\n        preRelease: versionPreRelease == null ? void 0 : versionPreRelease.split('.')\n    };\n    for (const comparator of comparators){\n        const extractedComparator = extractComparator(comparator);\n        if (!extractedComparator) {\n            return false;\n        }\n        const [, rangeOperator, , rangeMajor, rangeMinor, rangePatch, rangePreRelease] = extractedComparator;\n        const rangeAtom = {\n            operator: rangeOperator,\n            version: combineVersion(rangeMajor, rangeMinor, rangePatch, rangePreRelease),\n            major: rangeMajor,\n            minor: rangeMinor,\n            patch: rangePatch,\n            preRelease: rangePreRelease == null ? void 0 : rangePreRelease.split('.')\n        };\n        if (!compare(rangeAtom, versionAtom)) {\n            return false; // early return\n        }\n    }\n    return true;\n}\n\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction formatShare(shareArgs, from, name) {\n    let get;\n    if ('get' in shareArgs) {\n        // eslint-disable-next-line prefer-destructuring\n        get = shareArgs.get;\n    } else if ('lib' in shareArgs) {\n        get = ()=>Promise.resolve(shareArgs.lib);\n    } else {\n        get = ()=>Promise.resolve(()=>{\n                throw new Error(`Can not get shared '${name}'!`);\n            });\n    }\n    var _shareArgs_version, _shareArgs_scope;\n    return _extends({\n        deps: [],\n        useIn: [],\n        from,\n        loading: null\n    }, shareArgs, {\n        shareConfig: _extends({\n            requiredVersion: `^${shareArgs.version}`,\n            singleton: false,\n            eager: false,\n            strictVersion: false\n        }, shareArgs.shareConfig),\n        get,\n        loaded: 'lib' in shareArgs ? true : undefined,\n        version: (_shareArgs_version = shareArgs.version) != null ? _shareArgs_version : '0',\n        scope: Array.isArray(shareArgs.scope) ? shareArgs.scope : [\n            (_shareArgs_scope = shareArgs.scope) != null ? _shareArgs_scope : 'default'\n        ],\n        strategy: shareArgs.strategy || 'version-first'\n    });\n}\nfunction formatShareConfigs(globalOptions, userOptions) {\n    const shareArgs = userOptions.shared || {};\n    const from = userOptions.name;\n    const shareInfos = Object.keys(shareArgs).reduce((res, pkgName)=>{\n        const arrayShareArgs = arrayOptions(shareArgs[pkgName]);\n        res[pkgName] = res[pkgName] || [];\n        arrayShareArgs.forEach((shareConfig)=>{\n            res[pkgName].push(formatShare(shareConfig, from, pkgName));\n        });\n        return res;\n    }, {});\n    const shared = _extends({}, globalOptions.shared);\n    Object.keys(shareInfos).forEach((shareKey)=>{\n        if (!shared[shareKey]) {\n            shared[shareKey] = shareInfos[shareKey];\n        } else {\n            shareInfos[shareKey].forEach((newUserSharedOptions)=>{\n                const isSameVersion = shared[shareKey].find((sharedVal)=>sharedVal.version === newUserSharedOptions.version);\n                if (!isSameVersion) {\n                    shared[shareKey].push(newUserSharedOptions);\n                }\n            });\n        }\n    });\n    return {\n        shared,\n        shareInfos\n    };\n}\nfunction versionLt(a, b) {\n    const transformInvalidVersion = (version)=>{\n        const isNumberVersion = !Number.isNaN(Number(version));\n        if (isNumberVersion) {\n            const splitArr = version.split('.');\n            let validVersion = version;\n            for(let i = 0; i < 3 - splitArr.length; i++){\n                validVersion += '.0';\n            }\n            return validVersion;\n        }\n        return version;\n    };\n    if (satisfy(transformInvalidVersion(a), `<=${transformInvalidVersion(b)}`)) {\n        return true;\n    } else {\n        return false;\n    }\n}\nconst findVersion = (shareVersionMap, cb)=>{\n    const callback = cb || function(prev, cur) {\n        return versionLt(prev, cur);\n    };\n    return Object.keys(shareVersionMap).reduce((prev, cur)=>{\n        if (!prev) {\n            return cur;\n        }\n        if (callback(prev, cur)) {\n            return cur;\n        }\n        // default version is '0' https://github.com/webpack/webpack/blob/main/lib/sharing/ProvideSharedModule.js#L136\n        if (prev === '0') {\n            return cur;\n        }\n        return prev;\n    }, 0);\n};\nconst isLoaded = (shared)=>{\n    return Boolean(shared.loaded) || typeof shared.lib === 'function';\n};\nfunction findSingletonVersionOrderByVersion(shareScopeMap, scope, pkgName) {\n    const versions = shareScopeMap[scope][pkgName];\n    const callback = function(prev, cur) {\n        return !isLoaded(versions[prev]) && versionLt(prev, cur);\n    };\n    return findVersion(shareScopeMap[scope][pkgName], callback);\n}\nfunction findSingletonVersionOrderByLoaded(shareScopeMap, scope, pkgName) {\n    const versions = shareScopeMap[scope][pkgName];\n    const callback = function(prev, cur) {\n        if (isLoaded(versions[cur])) {\n            if (isLoaded(versions[prev])) {\n                return Boolean(versionLt(prev, cur));\n            } else {\n                return true;\n            }\n        }\n        if (isLoaded(versions[prev])) {\n            return false;\n        }\n        return versionLt(prev, cur);\n    };\n    return findVersion(shareScopeMap[scope][pkgName], callback);\n}\nfunction getFindShareFunction(strategy) {\n    if (strategy === 'loaded-first') {\n        return findSingletonVersionOrderByLoaded;\n    }\n    return findSingletonVersionOrderByVersion;\n}\nfunction getRegisteredShare(localShareScopeMap, pkgName, shareInfo, resolveShare) {\n    if (!localShareScopeMap) {\n        return;\n    }\n    const { shareConfig, scope = DEFAULT_SCOPE, strategy } = shareInfo;\n    const scopes = Array.isArray(scope) ? scope : [\n        scope\n    ];\n    for (const sc of scopes){\n        if (shareConfig && localShareScopeMap[sc] && localShareScopeMap[sc][pkgName]) {\n            const { requiredVersion } = shareConfig;\n            const findShareFunction = getFindShareFunction(strategy);\n            const maxOrSingletonVersion = findShareFunction(localShareScopeMap, sc, pkgName);\n            //@ts-ignore\n            const defaultResolver = ()=>{\n                if (shareConfig.singleton) {\n                    if (typeof requiredVersion === 'string' && !satisfy(maxOrSingletonVersion, requiredVersion)) {\n                        const msg = `Version ${maxOrSingletonVersion} from ${maxOrSingletonVersion && localShareScopeMap[sc][pkgName][maxOrSingletonVersion].from} of shared singleton module ${pkgName} does not satisfy the requirement of ${shareInfo.from} which needs ${requiredVersion})`;\n                        if (shareConfig.strictVersion) {\n                            error(msg);\n                        } else {\n                            warn(msg);\n                        }\n                    }\n                    return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];\n                } else {\n                    if (requiredVersion === false || requiredVersion === '*') {\n                        return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];\n                    }\n                    if (satisfy(maxOrSingletonVersion, requiredVersion)) {\n                        return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];\n                    }\n                    for (const [versionKey, versionValue] of Object.entries(localShareScopeMap[sc][pkgName])){\n                        if (satisfy(versionKey, requiredVersion)) {\n                            return versionValue;\n                        }\n                    }\n                }\n            };\n            const params = {\n                shareScopeMap: localShareScopeMap,\n                scope: sc,\n                pkgName,\n                version: maxOrSingletonVersion,\n                GlobalFederation: Global.__FEDERATION__,\n                resolver: defaultResolver\n            };\n            const resolveShared = resolveShare.emit(params) || params;\n            return resolveShared.resolver();\n        }\n    }\n}\nfunction getGlobalShareScope() {\n    return Global.__FEDERATION__.__SHARE__;\n}\nfunction getTargetSharedOptions(options) {\n    const { pkgName, extraOptions, shareInfos } = options;\n    const defaultResolver = (sharedOptions)=>{\n        if (!sharedOptions) {\n            return undefined;\n        }\n        const shareVersionMap = {};\n        sharedOptions.forEach((shared)=>{\n            shareVersionMap[shared.version] = shared;\n        });\n        const callback = function(prev, cur) {\n            return !isLoaded(shareVersionMap[prev]) && versionLt(prev, cur);\n        };\n        const maxVersion = findVersion(shareVersionMap, callback);\n        return shareVersionMap[maxVersion];\n    };\n    var _extraOptions_resolver;\n    const resolver = (_extraOptions_resolver = extraOptions == null ? void 0 : extraOptions.resolver) != null ? _extraOptions_resolver : defaultResolver;\n    return Object.assign({}, resolver(shareInfos[pkgName]), extraOptions == null ? void 0 : extraOptions.customShareInfo);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi9ydW50aW1lL2Rpc3Qvc2hhcmUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLFdBQVcsS0FBa0QsR0FBRyxrQkFBMkIsR0FBRyxDQUFFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhLElBQUksWUFBWTtBQUN0RDtBQUNBO0FBQ0EsdUJBQXVCLGFBQWEsSUFBSSxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhLElBQUksWUFBWTtBQUN0RDtBQUNBLE1BQU07QUFDTix3QkFBd0IsYUFBYSxJQUFJLElBQUk7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQixHQUFHLG1CQUFtQjtBQUN4RCxNQUFNO0FBQ04sa0JBQWtCLGdCQUFnQixHQUFHLGlCQUFpQjtBQUN0RCxNQUFNO0FBQ04sa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx1QkFBdUIsT0FBTyxzRkFBc0YsNkJBQTZCLFNBQVMsc0NBQXNDLGdCQUFnQixjQUFjLGdCQUFnQjtBQUM3UjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRXM2QiIsInNvdXJjZXMiOlsid2VicGFjazovL21vZHVsZUFwcEIvLi4vLi4vbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi9ydW50aW1lL2Rpc3Qvc2hhcmUuZXNtLmpzP2FjNzYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZ2V0QnVpbGRlcklkKCkge1xuICAgIC8vQHRzLWlnbm9yZVxuICAgIHJldHVybiB0eXBlb2YgRkVERVJBVElPTl9CVUlMRF9JREVOVElGSUVSICE9PSAndW5kZWZpbmVkJyA/IEZFREVSQVRJT05fQlVJTERfSURFTlRJRklFUiA6ICcnO1xufVxuZnVuY3Rpb24gaXNEZWJ1Z01vZGUoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oXCJcIik7XG59XG5mdW5jdGlvbiBpc0Jyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xufVxuXG5jb25zdCBMT0dfQ0FURUdPUlkgPSAnWyBGZWRlcmF0aW9uIFJ1bnRpbWUgXSc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgZXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgICBpZiAobXNnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbXNnLm1lc3NhZ2UgPSBgJHtMT0dfQ0FURUdPUll9OiAke21zZy5tZXNzYWdlfWA7XG4gICAgICAgIHRocm93IG1zZztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke0xPR19DQVRFR09SWX06ICR7bXNnfWApO1xufVxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICBpZiAobXNnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbXNnLm1lc3NhZ2UgPSBgJHtMT0dfQ0FURUdPUll9OiAke21zZy5tZXNzYWdlfWA7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgJHtMT0dfQ0FURUdPUll9OiAke21zZ31gKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZFVuaXF1ZUl0ZW0oYXJyLCBpdGVtKSB7XG4gICAgaWYgKGFyci5maW5kSW5kZXgoKG5hbWUpPT5uYW1lID09PSBpdGVtKSA9PT0gLTEpIHtcbiAgICAgICAgYXJyLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBnZXRGTUlkKHJlbW90ZUluZm8pIHtcbiAgICBpZiAoJ3ZlcnNpb24nIGluIHJlbW90ZUluZm8gJiYgcmVtb3RlSW5mby52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBgJHtyZW1vdGVJbmZvLm5hbWV9OiR7cmVtb3RlSW5mby52ZXJzaW9ufWA7XG4gICAgfSBlbHNlIGlmICgnZW50cnknIGluIHJlbW90ZUluZm8gJiYgcmVtb3RlSW5mby5lbnRyeSkge1xuICAgICAgICByZXR1cm4gYCR7cmVtb3RlSW5mby5uYW1lfToke3JlbW90ZUluZm8uZW50cnl9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7cmVtb3RlSW5mby5uYW1lfWA7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNSZW1vdGVJbmZvV2l0aEVudHJ5KHJlbW90ZSkge1xuICAgIHJldHVybiB0eXBlb2YgcmVtb3RlLmVudHJ5ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzUHVyZVJlbW90ZUVudHJ5KHJlbW90ZSkge1xuICAgIHJldHVybiAhcmVtb3RlLmVudHJ5LmluY2x1ZGVzKCcuanNvbicpICYmIHJlbW90ZS5lbnRyeS5pbmNsdWRlcygnLmpzJyk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gc2FmZVRvU3RyaW5nKGluZm8pIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5mbywgbnVsbCwgMik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gICAgcmV0dXJuIHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICAgIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuZnVuY3Rpb24gYXJyYXlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvcHRpb25zKSA/IG9wdGlvbnMgOiBbXG4gICAgICAgIG9wdGlvbnNcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcyQxKCkge1xuICAgIF9leHRlbmRzJDEgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2Upe1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgdmFyIGtleSwgaTtcbiAgICBmb3IoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmNvbnN0IG5hdGl2ZUdsb2JhbCA9ICgoKT0+e1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIH1cbn0pKCk7XG5jb25zdCBHbG9iYWwgPSBuYXRpdmVHbG9iYWw7XG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eUdsb2JhbFZhbCh0YXJnZXQsIGtleSwgdmFsKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbmNsdWRlT3duUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpO1xufVxuLy8gVGhpcyBzZWN0aW9uIGlzIHRvIHByZXZlbnQgZW5jYXBzdWxhdGlvbiBieSBjZXJ0YWluIG1pY3JvZnJvbnRlbmQgZnJhbWV3b3Jrcy4gRHVlIHRvIHJldXNlIHBvbGljaWVzLCBzYW5kYm94IGVzY2FwZXMuXG4vLyBUaGUgc2FuZGJveCBpbiB0aGUgbWljcm9mcm9udGVuZCBkb2VzIG5vdCByZXBsaWNhdGUgdGhlIHZhbHVlIG9mICdjb25maWd1cmFibGUnLlxuLy8gSWYgdGhlcmUgaXMgbm8gbG9hZGluZyBjb250ZW50IG9uIHRoZSBnbG9iYWwgb2JqZWN0LCB0aGlzIHNlY3Rpb24gZGVmaW5lcyB0aGUgbG9hZGluZyBvYmplY3QuXG5pZiAoIWluY2x1ZGVPd25Qcm9wZXJ0eShnbG9iYWxUaGlzLCAnX19HTE9CQUxfTE9BRElOR19SRU1PVEVfRU5UUllfXycpKSB7XG4gICAgZGVmaW5lUHJvcGVydHlHbG9iYWxWYWwoZ2xvYmFsVGhpcywgJ19fR0xPQkFMX0xPQURJTkdfUkVNT1RFX0VOVFJZX18nLCB7fSk7XG59XG5jb25zdCBnbG9iYWxMb2FkaW5nID0gZ2xvYmFsVGhpcy5fX0dMT0JBTF9MT0FESU5HX1JFTU9URV9FTlRSWV9fO1xuZnVuY3Rpb24gc2V0R2xvYmFsRGVmYXVsdFZhbCh0YXJnZXQpIHtcbiAgICB2YXIgX3RhcmdldF9fX0ZFREVSQVRJT05fXywgX3RhcmdldF9fX0ZFREVSQVRJT05fXzEsIF90YXJnZXRfX19GRURFUkFUSU9OX18yLCBfdGFyZ2V0X19fRkVERVJBVElPTl9fMywgX3RhcmdldF9fX0ZFREVSQVRJT05fXzQsIF90YXJnZXRfX19GRURFUkFUSU9OX181O1xuICAgIGlmIChpbmNsdWRlT3duUHJvcGVydHkodGFyZ2V0LCAnX19WTU9LX18nKSAmJiAhaW5jbHVkZU93blByb3BlcnR5KHRhcmdldCwgJ19fRkVERVJBVElPTl9fJykpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHlHbG9iYWxWYWwodGFyZ2V0LCAnX19GRURFUkFUSU9OX18nLCB0YXJnZXQuX19WTU9LX18pO1xuICAgIH1cbiAgICBpZiAoIWluY2x1ZGVPd25Qcm9wZXJ0eSh0YXJnZXQsICdfX0ZFREVSQVRJT05fXycpKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5R2xvYmFsVmFsKHRhcmdldCwgJ19fRkVERVJBVElPTl9fJywge1xuICAgICAgICAgICAgX19HTE9CQUxfUExVR0lOX186IFtdLFxuICAgICAgICAgICAgX19JTlNUQU5DRVNfXzogW10sXG4gICAgICAgICAgICBtb2R1bGVJbmZvOiB7fSxcbiAgICAgICAgICAgIF9fU0hBUkVfXzoge30sXG4gICAgICAgICAgICBfX01BTklGRVNUX0xPQURJTkdfXzoge30sXG4gICAgICAgICAgICBfX1BSRUxPQURFRF9NQVBfXzogbmV3IE1hcCgpXG4gICAgICAgIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eUdsb2JhbFZhbCh0YXJnZXQsICdfX1ZNT0tfXycsIHRhcmdldC5fX0ZFREVSQVRJT05fXyk7XG4gICAgfVxuICAgIHZhciBfX19HTE9CQUxfUExVR0lOX187XG4gICAgKF9fX0dMT0JBTF9QTFVHSU5fXyA9IChfdGFyZ2V0X19fRkVERVJBVElPTl9fID0gdGFyZ2V0Ll9fRkVERVJBVElPTl9fKS5fX0dMT0JBTF9QTFVHSU5fXykgIT0gbnVsbCA/IF9fX0dMT0JBTF9QTFVHSU5fXyA6IF90YXJnZXRfX19GRURFUkFUSU9OX18uX19HTE9CQUxfUExVR0lOX18gPSBbXTtcbiAgICB2YXIgX19fSU5TVEFOQ0VTX187XG4gICAgKF9fX0lOU1RBTkNFU19fID0gKF90YXJnZXRfX19GRURFUkFUSU9OX18xID0gdGFyZ2V0Ll9fRkVERVJBVElPTl9fKS5fX0lOU1RBTkNFU19fKSAhPSBudWxsID8gX19fSU5TVEFOQ0VTX18gOiBfdGFyZ2V0X19fRkVERVJBVElPTl9fMS5fX0lOU1RBTkNFU19fID0gW107XG4gICAgdmFyIF9tb2R1bGVJbmZvO1xuICAgIChfbW9kdWxlSW5mbyA9IChfdGFyZ2V0X19fRkVERVJBVElPTl9fMiA9IHRhcmdldC5fX0ZFREVSQVRJT05fXykubW9kdWxlSW5mbykgIT0gbnVsbCA/IF9tb2R1bGVJbmZvIDogX3RhcmdldF9fX0ZFREVSQVRJT05fXzIubW9kdWxlSW5mbyA9IHt9O1xuICAgIHZhciBfX19TSEFSRV9fO1xuICAgIChfX19TSEFSRV9fID0gKF90YXJnZXRfX19GRURFUkFUSU9OX18zID0gdGFyZ2V0Ll9fRkVERVJBVElPTl9fKS5fX1NIQVJFX18pICE9IG51bGwgPyBfX19TSEFSRV9fIDogX3RhcmdldF9fX0ZFREVSQVRJT05fXzMuX19TSEFSRV9fID0ge307XG4gICAgdmFyIF9fX01BTklGRVNUX0xPQURJTkdfXztcbiAgICAoX19fTUFOSUZFU1RfTE9BRElOR19fID0gKF90YXJnZXRfX19GRURFUkFUSU9OX180ID0gdGFyZ2V0Ll9fRkVERVJBVElPTl9fKS5fX01BTklGRVNUX0xPQURJTkdfXykgIT0gbnVsbCA/IF9fX01BTklGRVNUX0xPQURJTkdfXyA6IF90YXJnZXRfX19GRURFUkFUSU9OX180Ll9fTUFOSUZFU1RfTE9BRElOR19fID0ge307XG4gICAgdmFyIF9fX1BSRUxPQURFRF9NQVBfXztcbiAgICAoX19fUFJFTE9BREVEX01BUF9fID0gKF90YXJnZXRfX19GRURFUkFUSU9OX181ID0gdGFyZ2V0Ll9fRkVERVJBVElPTl9fKS5fX1BSRUxPQURFRF9NQVBfXykgIT0gbnVsbCA/IF9fX1BSRUxPQURFRF9NQVBfXyA6IF90YXJnZXRfX19GRURFUkFUSU9OX181Ll9fUFJFTE9BREVEX01BUF9fID0gbmV3IE1hcCgpO1xufVxuc2V0R2xvYmFsRGVmYXVsdFZhbChnbG9iYWxUaGlzKTtcbnNldEdsb2JhbERlZmF1bHRWYWwobmF0aXZlR2xvYmFsKTtcbmZ1bmN0aW9uIHJlc2V0RmVkZXJhdGlvbkdsb2JhbEluZm8oKSB7XG4gICAgZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX0dMT0JBTF9QTFVHSU5fXyA9IFtdO1xuICAgIGdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19JTlNUQU5DRVNfXyA9IFtdO1xuICAgIGdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18ubW9kdWxlSW5mbyA9IHt9O1xuICAgIGdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19TSEFSRV9fID0ge307XG4gICAgZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX01BTklGRVNUX0xPQURJTkdfXyA9IHt9O1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsRmVkZXJhdGlvbkluc3RhbmNlKG5hbWUsIHZlcnNpb24pIHtcbiAgICBjb25zdCBidWlsZElkID0gZ2V0QnVpbGRlcklkKCk7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19JTlNUQU5DRVNfXy5maW5kKChHTUluc3RhbmNlKT0+e1xuICAgICAgICBpZiAoYnVpbGRJZCAmJiBHTUluc3RhbmNlLm9wdGlvbnMuaWQgPT09IGdldEJ1aWxkZXJJZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoR01JbnN0YW5jZS5vcHRpb25zLm5hbWUgPT09IG5hbWUgJiYgIUdNSW5zdGFuY2Uub3B0aW9ucy52ZXJzaW9uICYmICF2ZXJzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoR01JbnN0YW5jZS5vcHRpb25zLm5hbWUgPT09IG5hbWUgJiYgdmVyc2lvbiAmJiBHTUluc3RhbmNlLm9wdGlvbnMudmVyc2lvbiA9PT0gdmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0R2xvYmFsRmVkZXJhdGlvbkluc3RhbmNlKEZlZGVyYXRpb25JbnN0YW5jZSkge1xuICAgIGdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19JTlNUQU5DRVNfXy5wdXNoKEZlZGVyYXRpb25JbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxGZWRlcmF0aW9uQ29uc3RydWN0b3IoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19ERUJVR19DT05TVFJVQ1RPUl9fO1xufVxuZnVuY3Rpb24gc2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yKEZlZGVyYXRpb25Db25zdHJ1Y3RvciwgaXNEZWJ1ZyA9IGlzRGVidWdNb2RlKCkpIHtcbiAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgICBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fREVCVUdfQ09OU1RSVUNUT1JfXyA9IEZlZGVyYXRpb25Db25zdHJ1Y3RvcjtcbiAgICAgICAgZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX0RFQlVHX0NPTlNUUlVDVE9SX1ZFUlNJT05fXyA9IFwiMC4xLjE1XCI7XG4gICAgfVxufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmZ1bmN0aW9uIGdldEluZm9XaXRob3V0VHlwZSh0YXJnZXQsIGtleSkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBrZXlSZXMgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKGtleVJlcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0W2tleV0sXG4gICAgICAgICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRLZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFyZ2V0S2V5IG9mIHRhcmdldEtleXMpe1xuICAgICAgICAgICAgICAgIGNvbnN0IFt0YXJnZXRUeXBlT3JOYW1lLCBfXSA9IHRhcmdldEtleS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5LZXkgPSBgJHt0YXJnZXRUeXBlT3JOYW1lfToke2tleX1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVXaXRoS2V5UmVzID0gdGFyZ2V0W25LZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlV2l0aEtleVJlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR5cGVXaXRoS2V5UmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBuS2V5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGtleToga2V5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXkgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICB9XG59XG5jb25zdCBnZXRHbG9iYWxTbmFwc2hvdCA9ICgpPT5uYXRpdmVHbG9iYWwuX19GRURFUkFUSU9OX18ubW9kdWxlSW5mbztcbmNvbnN0IGdldFRhcmdldFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyA9IChtb2R1bGVJbmZvLCBzbmFwc2hvdCk9PntcbiAgICAvLyBDaGVjayBpZiB0aGUgcmVtb3RlIGlzIGluY2x1ZGVkIGluIHRoZSBob3N0U25hcHNob3RcbiAgICBjb25zdCBtb2R1bGVLZXkgPSBnZXRGTUlkKG1vZHVsZUluZm8pO1xuICAgIGNvbnN0IGdldE1vZHVsZUluZm8gPSBnZXRJbmZvV2l0aG91dFR5cGUoc25hcHNob3QsIG1vZHVsZUtleSkudmFsdWU7XG4gICAgLy8gVGhlIHJlbW90ZVNuYXBzaG90IG1pZ2h0IG5vdCBpbmNsdWRlIGEgdmVyc2lvblxuICAgIGlmIChnZXRNb2R1bGVJbmZvICYmICFnZXRNb2R1bGVJbmZvLnZlcnNpb24gJiYgJ3ZlcnNpb24nIGluIG1vZHVsZUluZm8gJiYgbW9kdWxlSW5mb1sndmVyc2lvbiddKSB7XG4gICAgICAgIGdldE1vZHVsZUluZm8udmVyc2lvbiA9IG1vZHVsZUluZm9bJ3ZlcnNpb24nXTtcbiAgICB9XG4gICAgaWYgKGdldE1vZHVsZUluZm8pIHtcbiAgICAgICAgcmV0dXJuIGdldE1vZHVsZUluZm87XG4gICAgfVxuICAgIC8vIElmIHRoZSByZW1vdGUgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBob3N0U25hcHNob3QsIGRlcGxveSBhIG1pY3JvIGFwcCBzbmFwc2hvdFxuICAgIGlmICgndmVyc2lvbicgaW4gbW9kdWxlSW5mbyAmJiBtb2R1bGVJbmZvWyd2ZXJzaW9uJ10pIHtcbiAgICAgICAgY29uc3QgeyB2ZXJzaW9uIH0gPSBtb2R1bGVJbmZvLCByZXNNb2R1bGVJbmZvID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UobW9kdWxlSW5mbywgW1xuICAgICAgICAgICAgXCJ2ZXJzaW9uXCJcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IG1vZHVsZUtleVdpdGhvdXRWZXJzaW9uID0gZ2V0Rk1JZChyZXNNb2R1bGVJbmZvKTtcbiAgICAgICAgY29uc3QgZ2V0TW9kdWxlSW5mb1dpdGhvdXRWZXJzaW9uID0gZ2V0SW5mb1dpdGhvdXRUeXBlKG5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvLCBtb2R1bGVLZXlXaXRob3V0VmVyc2lvbikudmFsdWU7XG4gICAgICAgIGlmICgoZ2V0TW9kdWxlSW5mb1dpdGhvdXRWZXJzaW9uID09IG51bGwgPyB2b2lkIDAgOiBnZXRNb2R1bGVJbmZvV2l0aG91dFZlcnNpb24udmVyc2lvbikgPT09IHZlcnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRNb2R1bGVJbmZvV2l0aG91dFZlcnNpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufTtcbmNvbnN0IGdldEdsb2JhbFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyA9IChtb2R1bGVJbmZvKT0+Z2V0VGFyZ2V0U25hcHNob3RJbmZvQnlNb2R1bGVJbmZvKG1vZHVsZUluZm8sIG5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvKTtcbmNvbnN0IHNldEdsb2JhbFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyA9IChyZW1vdGVJbmZvLCBtb2R1bGVEZXRhaWxJbmZvKT0+e1xuICAgIGNvbnN0IG1vZHVsZUtleSA9IGdldEZNSWQocmVtb3RlSW5mbyk7XG4gICAgbmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm9bbW9kdWxlS2V5XSA9IG1vZHVsZURldGFpbEluZm87XG4gICAgcmV0dXJuIG5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvO1xufTtcbmNvbnN0IGFkZEdsb2JhbFNuYXBzaG90ID0gKG1vZHVsZUluZm9zKT0+e1xuICAgIG5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvID0gX2V4dGVuZHMkMSh7fSwgbmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm8sIG1vZHVsZUluZm9zKTtcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG1vZHVsZUluZm9zKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cyl7XG4gICAgICAgICAgICBkZWxldGUgbmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm9ba2V5XTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuY29uc3QgZ2V0UmVtb3RlRW50cnlFeHBvcnRzID0gKG5hbWUsIGdsb2JhbE5hbWUpPT57XG4gICAgY29uc3QgcmVtb3RlRW50cnlLZXkgPSBnbG9iYWxOYW1lIHx8IGBfX0ZFREVSQVRJT05fJHtuYW1lfTpjdXN0b21fX2A7XG4gICAgY29uc3QgZW50cnlFeHBvcnRzID0gZ2xvYmFsVGhpc1tyZW1vdGVFbnRyeUtleV07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3RlRW50cnlLZXksXG4gICAgICAgIGVudHJ5RXhwb3J0c1xuICAgIH07XG59O1xuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJlZ2lzdGVyIGdsb2JhbCBwbHVnaW5zLlxuLy8gSXQgaXRlcmF0ZXMgb3ZlciB0aGUgcHJvdmlkZWQgcGx1Z2lucyBhbmQgY2hlY2tzIGlmIHRoZXkgYXJlIGFscmVhZHkgcmVnaXN0ZXJlZC5cbi8vIElmIGEgcGx1Z2luIGlzIG5vdCByZWdpc3RlcmVkLCBpdCBpcyBhZGRlZCB0byB0aGUgZ2xvYmFsIHBsdWdpbnMuXG4vLyBJZiBhIHBsdWdpbiBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQsIGEgd2FybmluZyBtZXNzYWdlIGlzIGxvZ2dlZC5cbmNvbnN0IHJlZ2lzdGVyR2xvYmFsUGx1Z2lucyA9IChwbHVnaW5zKT0+e1xuICAgIGNvbnN0IHsgX19HTE9CQUxfUExVR0lOX18gfSA9IG5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXztcbiAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbik9PntcbiAgICAgICAgaWYgKF9fR0xPQkFMX1BMVUdJTl9fLmZpbmRJbmRleCgocCk9PnAubmFtZSA9PT0gcGx1Z2luLm5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgX19HTE9CQUxfUExVR0lOX18ucHVzaChwbHVnaW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FybihgVGhlIHBsdWdpbiAke3BsdWdpbi5uYW1lfSBoYXMgYmVlbiByZWdpc3RlcmVkLmApO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuY29uc3QgZ2V0R2xvYmFsSG9zdFBsdWdpbnMgPSAoKT0+bmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLl9fR0xPQkFMX1BMVUdJTl9fO1xuY29uc3QgZ2V0UHJlbG9hZGVkID0gKGlkKT0+Z2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX1BSRUxPQURFRF9NQVBfXy5nZXQoaWQpO1xuY29uc3Qgc2V0UHJlbG9hZGVkID0gKGlkKT0+Z2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX1BSRUxPQURFRF9NQVBfXy5zZXQoaWQsIHRydWUpO1xuXG5jb25zdCBERUZBVUxUX1NDT1BFID0gJ2RlZmF1bHQnO1xuY29uc3QgREVGQVVMVF9SRU1PVEVfVFlQRSA9ICdnbG9iYWwnO1xuXG4vLyBmb3JrIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL29yaWdpbmpzL3ZpdGUtcGx1Z2luLWZlZGVyYXRpb24vYmxvYi92MS4xLjEyL3BhY2thZ2VzL2xpYi9zcmMvdXRpbHMvc2VtdmVyL2luZGV4LnRzXG4vLyB0aG9zZSBjb25zdGFudHMgYXJlIGJhc2VkIG9uIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3NlbWFudGljX3JhbmdlLzMuMC4wL1NlbWFudGljUmFuZ2UjQlVJTERJREVOVElGSUVSLWNvbnN0YW50XG4vLyBDb3B5cmlnaHQgKGMpXG4vLyB2aXRlLXBsdWdpbi1mZWRlcmF0aW9uIGlzIGxpY2Vuc2VkIHVuZGVyIE11bGFuIFBTTCB2Mi5cbi8vIFlvdSBjYW4gdXNlIHRoaXMgc29mdHdhcmUgYWNjb3JkaW5nIHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB0aGUgTXVsYW4gUFNMIHYyLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIE11bGFuIFBTTCB2MiBhdDpcbi8vICAgICAgaHR0cDovL2xpY2Vuc2UuY29zY2wub3JnLmNuL011bGFuUFNMMlxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBPTiBBTiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPRiBBTlkgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBOT04tSU5GUklOR0VNRU5ULCBNRVJDSEFOVEFCSUxJVFkgT1IgRklUIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS5cbi8vIFNlZSB0aGUgTXVsYW4gUFNMIHYyIGZvciBtb3JlIGRldGFpbHMuXG5jb25zdCBidWlsZElkZW50aWZpZXIgPSAnWzAtOUEtWmEtei1dKyc7XG5jb25zdCBidWlsZCA9IGAoPzpcXFxcKygke2J1aWxkSWRlbnRpZmllcn0oPzpcXFxcLiR7YnVpbGRJZGVudGlmaWVyfSkqKSlgO1xuY29uc3QgbnVtZXJpY0lkZW50aWZpZXIgPSAnMHxbMS05XVxcXFxkKic7XG5jb25zdCBudW1lcmljSWRlbnRpZmllckxvb3NlID0gJ1swLTldKyc7XG5jb25zdCBub25OdW1lcmljSWRlbnRpZmllciA9ICdcXFxcZCpbYS16QS1aLV1bYS16QS1aMC05LV0qJztcbmNvbnN0IHByZVJlbGVhc2VJZGVudGlmaWVyTG9vc2UgPSBgKD86JHtudW1lcmljSWRlbnRpZmllckxvb3NlfXwke25vbk51bWVyaWNJZGVudGlmaWVyfSlgO1xuY29uc3QgcHJlUmVsZWFzZUxvb3NlID0gYCg/Oi0/KCR7cHJlUmVsZWFzZUlkZW50aWZpZXJMb29zZX0oPzpcXFxcLiR7cHJlUmVsZWFzZUlkZW50aWZpZXJMb29zZX0pKikpYDtcbmNvbnN0IHByZVJlbGVhc2VJZGVudGlmaWVyID0gYCg/OiR7bnVtZXJpY0lkZW50aWZpZXJ9fCR7bm9uTnVtZXJpY0lkZW50aWZpZXJ9KWA7XG5jb25zdCBwcmVSZWxlYXNlID0gYCg/Oi0oJHtwcmVSZWxlYXNlSWRlbnRpZmllcn0oPzpcXFxcLiR7cHJlUmVsZWFzZUlkZW50aWZpZXJ9KSopKWA7XG5jb25zdCB4UmFuZ2VJZGVudGlmaWVyID0gYCR7bnVtZXJpY0lkZW50aWZpZXJ9fHh8WHxcXFxcKmA7XG5jb25zdCB4UmFuZ2VQbGFpbiA9IGBbdj1cXFxcc10qKCR7eFJhbmdlSWRlbnRpZmllcn0pKD86XFxcXC4oJHt4UmFuZ2VJZGVudGlmaWVyfSkoPzpcXFxcLigke3hSYW5nZUlkZW50aWZpZXJ9KSg/OiR7cHJlUmVsZWFzZX0pPyR7YnVpbGR9Pyk/KT9gO1xuY29uc3QgaHlwaGVuUmFuZ2UgPSBgXlxcXFxzKigke3hSYW5nZVBsYWlufSlcXFxccystXFxcXHMrKCR7eFJhbmdlUGxhaW59KVxcXFxzKiRgO1xuY29uc3QgbWFpblZlcnNpb25Mb29zZSA9IGAoJHtudW1lcmljSWRlbnRpZmllckxvb3NlfSlcXFxcLigke251bWVyaWNJZGVudGlmaWVyTG9vc2V9KVxcXFwuKCR7bnVtZXJpY0lkZW50aWZpZXJMb29zZX0pYDtcbmNvbnN0IGxvb3NlUGxhaW4gPSBgW3Y9XFxcXHNdKiR7bWFpblZlcnNpb25Mb29zZX0ke3ByZVJlbGVhc2VMb29zZX0/JHtidWlsZH0/YDtcbmNvbnN0IGd0bHQgPSAnKCg/Ojx8Pik/PT8pJztcbmNvbnN0IGNvbXBhcmF0b3JUcmltID0gYChcXFxccyopJHtndGx0fVxcXFxzKigke2xvb3NlUGxhaW59fCR7eFJhbmdlUGxhaW59KWA7XG5jb25zdCBsb25lVGlsZGUgPSAnKD86fj4/KSc7XG5jb25zdCB0aWxkZVRyaW0gPSBgKFxcXFxzKikke2xvbmVUaWxkZX1cXFxccytgO1xuY29uc3QgbG9uZUNhcmV0ID0gJyg/OlxcXFxeKSc7XG5jb25zdCBjYXJldFRyaW0gPSBgKFxcXFxzKikke2xvbmVDYXJldH1cXFxccytgO1xuY29uc3Qgc3RhciA9ICcoPHw+KT89P1xcXFxzKlxcXFwqJztcbmNvbnN0IGNhcmV0ID0gYF4ke2xvbmVDYXJldH0ke3hSYW5nZVBsYWlufSRgO1xuY29uc3QgbWFpblZlcnNpb24gPSBgKCR7bnVtZXJpY0lkZW50aWZpZXJ9KVxcXFwuKCR7bnVtZXJpY0lkZW50aWZpZXJ9KVxcXFwuKCR7bnVtZXJpY0lkZW50aWZpZXJ9KWA7XG5jb25zdCBmdWxsUGxhaW4gPSBgdj8ke21haW5WZXJzaW9ufSR7cHJlUmVsZWFzZX0/JHtidWlsZH0/YDtcbmNvbnN0IHRpbGRlID0gYF4ke2xvbmVUaWxkZX0ke3hSYW5nZVBsYWlufSRgO1xuY29uc3QgeFJhbmdlID0gYF4ke2d0bHR9XFxcXHMqJHt4UmFuZ2VQbGFpbn0kYDtcbmNvbnN0IGNvbXBhcmF0b3IgPSBgXiR7Z3RsdH1cXFxccyooJHtmdWxsUGxhaW59KSR8XiRgO1xuLy8gY29weSBmcm9tIHNlbXZlciBwYWNrYWdlXG5jb25zdCBndGUwID0gJ15cXFxccyo+PVxcXFxzKjAuMC4wXFxcXHMqJCc7XG5cbi8vIGZvcmsgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vb3JpZ2luanMvdml0ZS1wbHVnaW4tZmVkZXJhdGlvbi9ibG9iL3YxLjEuMTIvcGFja2FnZXMvbGliL3NyYy91dGlscy9zZW12ZXIvaW5kZXgudHNcbmZ1bmN0aW9uIHBhcnNlUmVnZXgoc291cmNlKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc291cmNlKTtcbn1cbmZ1bmN0aW9uIGlzWFZlcnNpb24odmVyc2lvbikge1xuICAgIHJldHVybiAhdmVyc2lvbiB8fCB2ZXJzaW9uLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCB2ZXJzaW9uID09PSAnKic7XG59XG5mdW5jdGlvbiBwaXBlKC4uLmZucykge1xuICAgIHJldHVybiAoeCk9PmZucy5yZWR1Y2UoKHYsIGYpPT5mKHYpLCB4KTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RDb21wYXJhdG9yKGNvbXBhcmF0b3JTdHJpbmcpIHtcbiAgICByZXR1cm4gY29tcGFyYXRvclN0cmluZy5tYXRjaChwYXJzZVJlZ2V4KGNvbXBhcmF0b3IpKTtcbn1cbmZ1bmN0aW9uIGNvbWJpbmVWZXJzaW9uKG1ham9yLCBtaW5vciwgcGF0Y2gsIHByZVJlbGVhc2UpIHtcbiAgICBjb25zdCBtYWluVmVyc2lvbiA9IGAke21ham9yfS4ke21pbm9yfS4ke3BhdGNofWA7XG4gICAgaWYgKHByZVJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIGAke21haW5WZXJzaW9ufS0ke3ByZVJlbGVhc2V9YDtcbiAgICB9XG4gICAgcmV0dXJuIG1haW5WZXJzaW9uO1xufVxuXG4vLyBmb3JrIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL29yaWdpbmpzL3ZpdGUtcGx1Z2luLWZlZGVyYXRpb24vYmxvYi92MS4xLjEyL3BhY2thZ2VzL2xpYi9zcmMvdXRpbHMvc2VtdmVyL2luZGV4LnRzXG5mdW5jdGlvbiBwYXJzZUh5cGhlbihyYW5nZSkge1xuICAgIHJldHVybiByYW5nZS5yZXBsYWNlKHBhcnNlUmVnZXgoaHlwaGVuUmFuZ2UpLCAoX3JhbmdlLCBmcm9tLCBmcm9tTWFqb3IsIGZyb21NaW5vciwgZnJvbVBhdGNoLCBfZnJvbVByZVJlbGVhc2UsIF9mcm9tQnVpbGQsIHRvLCB0b01ham9yLCB0b01pbm9yLCB0b1BhdGNoLCB0b1ByZVJlbGVhc2UpPT57XG4gICAgICAgIGlmIChpc1hWZXJzaW9uKGZyb21NYWpvcikpIHtcbiAgICAgICAgICAgIGZyb20gPSAnJztcbiAgICAgICAgfSBlbHNlIGlmIChpc1hWZXJzaW9uKGZyb21NaW5vcikpIHtcbiAgICAgICAgICAgIGZyb20gPSBgPj0ke2Zyb21NYWpvcn0uMC4wYDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1hWZXJzaW9uKGZyb21QYXRjaCkpIHtcbiAgICAgICAgICAgIGZyb20gPSBgPj0ke2Zyb21NYWpvcn0uJHtmcm9tTWlub3J9LjBgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IGA+PSR7ZnJvbX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1hWZXJzaW9uKHRvTWFqb3IpKSB7XG4gICAgICAgICAgICB0byA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKGlzWFZlcnNpb24odG9NaW5vcikpIHtcbiAgICAgICAgICAgIHRvID0gYDwke051bWJlcih0b01ham9yKSArIDF9LjAuMC0wYDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1hWZXJzaW9uKHRvUGF0Y2gpKSB7XG4gICAgICAgICAgICB0byA9IGA8JHt0b01ham9yfS4ke051bWJlcih0b01pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgIH0gZWxzZSBpZiAodG9QcmVSZWxlYXNlKSB7XG4gICAgICAgICAgICB0byA9IGA8PSR7dG9NYWpvcn0uJHt0b01pbm9yfS4ke3RvUGF0Y2h9LSR7dG9QcmVSZWxlYXNlfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0byA9IGA8PSR7dG99YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7ZnJvbX0gJHt0b31gLnRyaW0oKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29tcGFyYXRvclRyaW0ocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2UucmVwbGFjZShwYXJzZVJlZ2V4KGNvbXBhcmF0b3JUcmltKSwgJyQxJDIkMycpO1xufVxuZnVuY3Rpb24gcGFyc2VUaWxkZVRyaW0ocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2UucmVwbGFjZShwYXJzZVJlZ2V4KHRpbGRlVHJpbSksICckMX4nKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FyZXRUcmltKHJhbmdlKSB7XG4gICAgcmV0dXJuIHJhbmdlLnJlcGxhY2UocGFyc2VSZWdleChjYXJldFRyaW0pLCAnJDFeJyk7XG59XG5mdW5jdGlvbiBwYXJzZUNhcmV0cyhyYW5nZSkge1xuICAgIHJldHVybiByYW5nZS50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoKHJhbmdlVmVyc2lvbik9PnJhbmdlVmVyc2lvbi5yZXBsYWNlKHBhcnNlUmVnZXgoY2FyZXQpLCAoXywgbWFqb3IsIG1pbm9yLCBwYXRjaCwgcHJlUmVsZWFzZSk9PntcbiAgICAgICAgICAgIGlmIChpc1hWZXJzaW9uKG1ham9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNYVmVyc2lvbihtaW5vcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uMC4wIDwke051bWJlcihtYWpvcikgKyAxfS4wLjAtMGA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzWFZlcnNpb24ocGF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ham9yID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LjAgPCR7bWFqb3J9LiR7TnVtYmVyKG1pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LjAgPCR7TnVtYmVyKG1ham9yKSArIDF9LjAuMC0wYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZVJlbGVhc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFqb3IgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWlub3IgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9LSR7cHJlUmVsZWFzZX0gPCR7bWFqb3J9LiR7bWlub3J9LiR7TnVtYmVyKHBhdGNoKSArIDF9LTBgO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9LSR7cHJlUmVsZWFzZX0gPCR7bWFqb3J9LiR7TnVtYmVyKG1pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH0tJHtwcmVSZWxlYXNlfSA8JHtOdW1iZXIobWFqb3IpICsgMX0uMC4wLTBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ham9yID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbm9yID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4ke3BhdGNofSA8JHttYWpvcn0uJHttaW5vcn0uJHtOdW1iZXIocGF0Y2gpICsgMX0tMGA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH0gPCR7bWFqb3J9LiR7TnVtYmVyKG1pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9IDwke051bWJlcihtYWpvcikgKyAxfS4wLjAtMGA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKS5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBwYXJzZVRpbGRlcyhyYW5nZSkge1xuICAgIHJldHVybiByYW5nZS50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoKHJhbmdlVmVyc2lvbik9PnJhbmdlVmVyc2lvbi5yZXBsYWNlKHBhcnNlUmVnZXgodGlsZGUpLCAoXywgbWFqb3IsIG1pbm9yLCBwYXRjaCwgcHJlUmVsZWFzZSk9PntcbiAgICAgICAgICAgIGlmIChpc1hWZXJzaW9uKG1ham9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNYVmVyc2lvbihtaW5vcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uMC4wIDwke051bWJlcihtYWpvcikgKyAxfS4wLjAtMGA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzWFZlcnNpb24ocGF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LjAgPCR7bWFqb3J9LiR7TnVtYmVyKG1pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZVJlbGVhc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH0tJHtwcmVSZWxlYXNlfSA8JHttYWpvcn0uJHtOdW1iZXIobWlub3IpICsgMX0uMC0wYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4ke3BhdGNofSA8JHttYWpvcn0uJHtOdW1iZXIobWlub3IpICsgMX0uMC0wYDtcbiAgICAgICAgfSkpLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlWFJhbmdlcyhyYW5nZSkge1xuICAgIHJldHVybiByYW5nZS5zcGxpdCgvXFxzKy8pLm1hcCgocmFuZ2VWZXJzaW9uKT0+cmFuZ2VWZXJzaW9uLnRyaW0oKS5yZXBsYWNlKHBhcnNlUmVnZXgoeFJhbmdlKSwgKHJldCwgZ3RsdCwgbWFqb3IsIG1pbm9yLCBwYXRjaCwgcHJlUmVsZWFzZSk9PntcbiAgICAgICAgICAgIGNvbnN0IGlzWE1ham9yID0gaXNYVmVyc2lvbihtYWpvcik7XG4gICAgICAgICAgICBjb25zdCBpc1hNaW5vciA9IGlzWE1ham9yIHx8IGlzWFZlcnNpb24obWlub3IpO1xuICAgICAgICAgICAgY29uc3QgaXNYUGF0Y2ggPSBpc1hNaW5vciB8fCBpc1hWZXJzaW9uKHBhdGNoKTtcbiAgICAgICAgICAgIGlmIChndGx0ID09PSAnPScgJiYgaXNYUGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBndGx0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVSZWxlYXNlID0gJyc7XG4gICAgICAgICAgICBpZiAoaXNYTWFqb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8MC4wLjAtMCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcqJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGd0bHQgJiYgaXNYUGF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICAgICAgICAgICAgaWYgKGlzWE1pbm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbm9yID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0Y2ggPSAwO1xuICAgICAgICAgICAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAgICAgICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgICAgICAgICAgICAgZ3RsdCA9ICc+PSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1hNaW5vcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFqb3IgPSBOdW1iZXIobWFqb3IpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbm9yID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbm9yID0gTnVtYmVyKG1pbm9yKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGQgcGFzc1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICAgICAgICAgICAgICBndGx0ID0gJzwnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNYTWlub3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ham9yID0gTnVtYmVyKG1ham9yKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5vciA9IE51bWJlcihtaW5vcikgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChndGx0ID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlUmVsZWFzZSA9ICctMCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtndGx0ICsgbWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9JHtwcmVSZWxlYXNlfWA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzWE1pbm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LjAuMCR7cHJlUmVsZWFzZX0gPCR7TnVtYmVyKG1ham9yKSArIDF9LjAuMC0wYDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNYUGF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uJHttaW5vcn0uMCR7cHJlUmVsZWFzZX0gPCR7bWFqb3J9LiR7TnVtYmVyKG1pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KSkuam9pbignICcpO1xufVxuZnVuY3Rpb24gcGFyc2VTdGFyKHJhbmdlKSB7XG4gICAgcmV0dXJuIHJhbmdlLnRyaW0oKS5yZXBsYWNlKHBhcnNlUmVnZXgoc3RhciksICcnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlR1RFMChjb21wYXJhdG9yU3RyaW5nKSB7XG4gICAgcmV0dXJuIGNvbXBhcmF0b3JTdHJpbmcudHJpbSgpLnJlcGxhY2UocGFyc2VSZWdleChndGUwKSwgJycpO1xufVxuXG4vLyBmb3JrIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL29yaWdpbmpzL3ZpdGUtcGx1Z2luLWZlZGVyYXRpb24vYmxvYi92MS4xLjEyL3BhY2thZ2VzL2xpYi9zcmMvdXRpbHMvc2VtdmVyL2luZGV4LnRzXG4vLyBDb3B5cmlnaHQgKGMpXG4vLyB2aXRlLXBsdWdpbi1mZWRlcmF0aW9uIGlzIGxpY2Vuc2VkIHVuZGVyIE11bGFuIFBTTCB2Mi5cbi8vIFlvdSBjYW4gdXNlIHRoaXMgc29mdHdhcmUgYWNjb3JkaW5nIHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB0aGUgTXVsYW4gUFNMIHYyLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIE11bGFuIFBTTCB2MiBhdDpcbi8vICAgICAgaHR0cDovL2xpY2Vuc2UuY29zY2wub3JnLmNuL011bGFuUFNMMlxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBPTiBBTiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPRiBBTlkgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBOT04tSU5GUklOR0VNRU5ULCBNRVJDSEFOVEFCSUxJVFkgT1IgRklUIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS5cbi8vIFNlZSB0aGUgTXVsYW4gUFNMIHYyIGZvciBtb3JlIGRldGFpbHMuXG5mdW5jdGlvbiBjb21wYXJlQXRvbShyYW5nZUF0b20sIHZlcnNpb25BdG9tKSB7XG4gICAgcmFuZ2VBdG9tID0gTnVtYmVyKHJhbmdlQXRvbSkgfHwgcmFuZ2VBdG9tO1xuICAgIHZlcnNpb25BdG9tID0gTnVtYmVyKHZlcnNpb25BdG9tKSB8fCB2ZXJzaW9uQXRvbTtcbiAgICBpZiAocmFuZ2VBdG9tID4gdmVyc2lvbkF0b20pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChyYW5nZUF0b20gPT09IHZlcnNpb25BdG9tKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBjb21wYXJlUHJlUmVsZWFzZShyYW5nZUF0b20sIHZlcnNpb25BdG9tKSB7XG4gICAgY29uc3QgeyBwcmVSZWxlYXNlOiByYW5nZVByZVJlbGVhc2UgfSA9IHJhbmdlQXRvbTtcbiAgICBjb25zdCB7IHByZVJlbGVhc2U6IHZlcnNpb25QcmVSZWxlYXNlIH0gPSB2ZXJzaW9uQXRvbTtcbiAgICBpZiAocmFuZ2VQcmVSZWxlYXNlID09PSB1bmRlZmluZWQgJiYgQm9vbGVhbih2ZXJzaW9uUHJlUmVsZWFzZSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChCb29sZWFuKHJhbmdlUHJlUmVsZWFzZSkgJiYgdmVyc2lvblByZVJlbGVhc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChyYW5nZVByZVJlbGVhc2UgPT09IHVuZGVmaW5lZCAmJiB2ZXJzaW9uUHJlUmVsZWFzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmb3IobGV0IGkgPSAwLCBuID0gcmFuZ2VQcmVSZWxlYXNlLmxlbmd0aDsgaSA8PSBuOyBpKyspe1xuICAgICAgICBjb25zdCByYW5nZUVsZW1lbnQgPSByYW5nZVByZVJlbGVhc2VbaV07XG4gICAgICAgIGNvbnN0IHZlcnNpb25FbGVtZW50ID0gdmVyc2lvblByZVJlbGVhc2VbaV07XG4gICAgICAgIGlmIChyYW5nZUVsZW1lbnQgPT09IHZlcnNpb25FbGVtZW50KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFuZ2VFbGVtZW50ID09PSB1bmRlZmluZWQgJiYgdmVyc2lvbkVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYW5nZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmVyc2lvbkVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGFyZUF0b20ocmFuZ2VFbGVtZW50LCB2ZXJzaW9uRWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY29tcGFyZVZlcnNpb24ocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkge1xuICAgIHJldHVybiBjb21wYXJlQXRvbShyYW5nZUF0b20ubWFqb3IsIHZlcnNpb25BdG9tLm1ham9yKSB8fCBjb21wYXJlQXRvbShyYW5nZUF0b20ubWlub3IsIHZlcnNpb25BdG9tLm1pbm9yKSB8fCBjb21wYXJlQXRvbShyYW5nZUF0b20ucGF0Y2gsIHZlcnNpb25BdG9tLnBhdGNoKSB8fCBjb21wYXJlUHJlUmVsZWFzZShyYW5nZUF0b20sIHZlcnNpb25BdG9tKTtcbn1cbmZ1bmN0aW9uIGVxKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pIHtcbiAgICByZXR1cm4gcmFuZ2VBdG9tLnZlcnNpb24gPT09IHZlcnNpb25BdG9tLnZlcnNpb247XG59XG5mdW5jdGlvbiBjb21wYXJlKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pIHtcbiAgICBzd2l0Y2gocmFuZ2VBdG9tLm9wZXJhdG9yKXtcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICByZXR1cm4gZXEocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSk7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVWZXJzaW9uKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pIDwgMDtcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgcmV0dXJuIGVxKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pIHx8IGNvbXBhcmVWZXJzaW9uKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pIDwgMDtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVZlcnNpb24ocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkgPiAwO1xuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICByZXR1cm4gZXEocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkgfHwgY29tcGFyZVZlcnNpb24ocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkgPiAwO1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBtZWFuICogb3IgeCAtPiBhbGwgdmVyc2lvbnNcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGZvcmsgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vb3JpZ2luanMvdml0ZS1wbHVnaW4tZmVkZXJhdGlvbi9ibG9iL3YxLjEuMTIvcGFja2FnZXMvbGliL3NyYy91dGlscy9zZW12ZXIvaW5kZXgudHNcbmZ1bmN0aW9uIHBhcnNlQ29tcGFyYXRvclN0cmluZyhyYW5nZSkge1xuICAgIHJldHVybiBwaXBlKC8vIGhhbmRsZSBjYXJldFxuICAgIC8vIF4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4gICAgLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuICAgIC8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuICAgIC8vIF4xLjIsIF4xLjIueCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuICAgIC8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjAtMFxuICAgIC8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuICAgIHBhcnNlQ2FyZXRzLCAvLyBoYW5kbGUgdGlsZGVcbiAgICAvLyB+LCB+PiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbiAgICAvLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbiAgICAvLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMC0wXG4gICAgLy8gfjEuMiwgfjEuMi54LCB+PjEuMiwgfj4xLjIueCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuICAgIC8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjAtMFxuICAgIC8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuICAgIHBhcnNlVGlsZGVzLCBwYXJzZVhSYW5nZXMsIHBhcnNlU3RhcikocmFuZ2UpO1xufVxuZnVuY3Rpb24gcGFyc2VSYW5nZShyYW5nZSkge1xuICAgIHJldHVybiBwaXBlKC8vIGhhbmRsZSBoeXBoZW5SYW5nZVxuICAgIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YFxuICAgIHBhcnNlSHlwaGVuLCAvLyBoYW5kbGUgdHJpbSBjb21wYXJhdG9yXG4gICAgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG4gICAgcGFyc2VDb21wYXJhdG9yVHJpbSwgLy8gaGFuZGxlIHRyaW0gdGlsZGVcbiAgICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgICBwYXJzZVRpbGRlVHJpbSwgLy8gaGFuZGxlIHRyaW0gY2FyZXRcbiAgICAvLyBgXiAxLjIuM2AgPT4gYF4xLjIuM2BcbiAgICBwYXJzZUNhcmV0VHJpbSkocmFuZ2UudHJpbSgpKS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIHNhdGlzZnkodmVyc2lvbiwgcmFuZ2UpIHtcbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRSYW5nZSA9IHBhcnNlUmFuZ2UocmFuZ2UpO1xuICAgIGNvbnN0IHBhcnNlZENvbXBhcmF0b3IgPSBwYXJzZWRSYW5nZS5zcGxpdCgnICcpLm1hcCgocmFuZ2VWZXJzaW9uKT0+cGFyc2VDb21wYXJhdG9yU3RyaW5nKHJhbmdlVmVyc2lvbikpLmpvaW4oJyAnKTtcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHBhcnNlZENvbXBhcmF0b3Iuc3BsaXQoL1xccysvKS5tYXAoKGNvbXBhcmF0b3IpPT5wYXJzZUdURTAoY29tcGFyYXRvcikpO1xuICAgIGNvbnN0IGV4dHJhY3RlZFZlcnNpb24gPSBleHRyYWN0Q29tcGFyYXRvcih2ZXJzaW9uKTtcbiAgICBpZiAoIWV4dHJhY3RlZFZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBbLCB2ZXJzaW9uT3BlcmF0b3IsICwgdmVyc2lvbk1ham9yLCB2ZXJzaW9uTWlub3IsIHZlcnNpb25QYXRjaCwgdmVyc2lvblByZVJlbGVhc2VdID0gZXh0cmFjdGVkVmVyc2lvbjtcbiAgICBjb25zdCB2ZXJzaW9uQXRvbSA9IHtcbiAgICAgICAgb3BlcmF0b3I6IHZlcnNpb25PcGVyYXRvcixcbiAgICAgICAgdmVyc2lvbjogY29tYmluZVZlcnNpb24odmVyc2lvbk1ham9yLCB2ZXJzaW9uTWlub3IsIHZlcnNpb25QYXRjaCwgdmVyc2lvblByZVJlbGVhc2UpLFxuICAgICAgICBtYWpvcjogdmVyc2lvbk1ham9yLFxuICAgICAgICBtaW5vcjogdmVyc2lvbk1pbm9yLFxuICAgICAgICBwYXRjaDogdmVyc2lvblBhdGNoLFxuICAgICAgICBwcmVSZWxlYXNlOiB2ZXJzaW9uUHJlUmVsZWFzZSA9PSBudWxsID8gdm9pZCAwIDogdmVyc2lvblByZVJlbGVhc2Uuc3BsaXQoJy4nKVxuICAgIH07XG4gICAgZm9yIChjb25zdCBjb21wYXJhdG9yIG9mIGNvbXBhcmF0b3JzKXtcbiAgICAgICAgY29uc3QgZXh0cmFjdGVkQ29tcGFyYXRvciA9IGV4dHJhY3RDb21wYXJhdG9yKGNvbXBhcmF0b3IpO1xuICAgICAgICBpZiAoIWV4dHJhY3RlZENvbXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbLCByYW5nZU9wZXJhdG9yLCAsIHJhbmdlTWFqb3IsIHJhbmdlTWlub3IsIHJhbmdlUGF0Y2gsIHJhbmdlUHJlUmVsZWFzZV0gPSBleHRyYWN0ZWRDb21wYXJhdG9yO1xuICAgICAgICBjb25zdCByYW5nZUF0b20gPSB7XG4gICAgICAgICAgICBvcGVyYXRvcjogcmFuZ2VPcGVyYXRvcixcbiAgICAgICAgICAgIHZlcnNpb246IGNvbWJpbmVWZXJzaW9uKHJhbmdlTWFqb3IsIHJhbmdlTWlub3IsIHJhbmdlUGF0Y2gsIHJhbmdlUHJlUmVsZWFzZSksXG4gICAgICAgICAgICBtYWpvcjogcmFuZ2VNYWpvcixcbiAgICAgICAgICAgIG1pbm9yOiByYW5nZU1pbm9yLFxuICAgICAgICAgICAgcGF0Y2g6IHJhbmdlUGF0Y2gsXG4gICAgICAgICAgICBwcmVSZWxlYXNlOiByYW5nZVByZVJlbGVhc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJhbmdlUHJlUmVsZWFzZS5zcGxpdCgnLicpXG4gICAgICAgIH07XG4gICAgICAgIGlmICghY29tcGFyZShyYW5nZUF0b20sIHZlcnNpb25BdG9tKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBlYXJseSByZXR1cm5cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2Upe1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNoYXJlKHNoYXJlQXJncywgZnJvbSwgbmFtZSkge1xuICAgIGxldCBnZXQ7XG4gICAgaWYgKCdnZXQnIGluIHNoYXJlQXJncykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgZ2V0ID0gc2hhcmVBcmdzLmdldDtcbiAgICB9IGVsc2UgaWYgKCdsaWInIGluIHNoYXJlQXJncykge1xuICAgICAgICBnZXQgPSAoKT0+UHJvbWlzZS5yZXNvbHZlKHNoYXJlQXJncy5saWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldCA9ICgpPT5Qcm9taXNlLnJlc29sdmUoKCk9PntcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgZ2V0IHNoYXJlZCAnJHtuYW1lfSchYCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIF9zaGFyZUFyZ3NfdmVyc2lvbiwgX3NoYXJlQXJnc19zY29wZTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBkZXBzOiBbXSxcbiAgICAgICAgdXNlSW46IFtdLFxuICAgICAgICBmcm9tLFxuICAgICAgICBsb2FkaW5nOiBudWxsXG4gICAgfSwgc2hhcmVBcmdzLCB7XG4gICAgICAgIHNoYXJlQ29uZmlnOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICByZXF1aXJlZFZlcnNpb246IGBeJHtzaGFyZUFyZ3MudmVyc2lvbn1gLFxuICAgICAgICAgICAgc2luZ2xldG9uOiBmYWxzZSxcbiAgICAgICAgICAgIGVhZ2VyOiBmYWxzZSxcbiAgICAgICAgICAgIHN0cmljdFZlcnNpb246IGZhbHNlXG4gICAgICAgIH0sIHNoYXJlQXJncy5zaGFyZUNvbmZpZyksXG4gICAgICAgIGdldCxcbiAgICAgICAgbG9hZGVkOiAnbGliJyBpbiBzaGFyZUFyZ3MgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgICAgICB2ZXJzaW9uOiAoX3NoYXJlQXJnc192ZXJzaW9uID0gc2hhcmVBcmdzLnZlcnNpb24pICE9IG51bGwgPyBfc2hhcmVBcmdzX3ZlcnNpb24gOiAnMCcsXG4gICAgICAgIHNjb3BlOiBBcnJheS5pc0FycmF5KHNoYXJlQXJncy5zY29wZSkgPyBzaGFyZUFyZ3Muc2NvcGUgOiBbXG4gICAgICAgICAgICAoX3NoYXJlQXJnc19zY29wZSA9IHNoYXJlQXJncy5zY29wZSkgIT0gbnVsbCA/IF9zaGFyZUFyZ3Nfc2NvcGUgOiAnZGVmYXVsdCdcbiAgICAgICAgXSxcbiAgICAgICAgc3RyYXRlZ3k6IHNoYXJlQXJncy5zdHJhdGVneSB8fCAndmVyc2lvbi1maXJzdCdcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNoYXJlQ29uZmlncyhnbG9iYWxPcHRpb25zLCB1c2VyT3B0aW9ucykge1xuICAgIGNvbnN0IHNoYXJlQXJncyA9IHVzZXJPcHRpb25zLnNoYXJlZCB8fCB7fTtcbiAgICBjb25zdCBmcm9tID0gdXNlck9wdGlvbnMubmFtZTtcbiAgICBjb25zdCBzaGFyZUluZm9zID0gT2JqZWN0LmtleXMoc2hhcmVBcmdzKS5yZWR1Y2UoKHJlcywgcGtnTmFtZSk9PntcbiAgICAgICAgY29uc3QgYXJyYXlTaGFyZUFyZ3MgPSBhcnJheU9wdGlvbnMoc2hhcmVBcmdzW3BrZ05hbWVdKTtcbiAgICAgICAgcmVzW3BrZ05hbWVdID0gcmVzW3BrZ05hbWVdIHx8IFtdO1xuICAgICAgICBhcnJheVNoYXJlQXJncy5mb3JFYWNoKChzaGFyZUNvbmZpZyk9PntcbiAgICAgICAgICAgIHJlc1twa2dOYW1lXS5wdXNoKGZvcm1hdFNoYXJlKHNoYXJlQ29uZmlnLCBmcm9tLCBwa2dOYW1lKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBzaGFyZWQgPSBfZXh0ZW5kcyh7fSwgZ2xvYmFsT3B0aW9ucy5zaGFyZWQpO1xuICAgIE9iamVjdC5rZXlzKHNoYXJlSW5mb3MpLmZvckVhY2goKHNoYXJlS2V5KT0+e1xuICAgICAgICBpZiAoIXNoYXJlZFtzaGFyZUtleV0pIHtcbiAgICAgICAgICAgIHNoYXJlZFtzaGFyZUtleV0gPSBzaGFyZUluZm9zW3NoYXJlS2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNoYXJlSW5mb3Nbc2hhcmVLZXldLmZvckVhY2goKG5ld1VzZXJTaGFyZWRPcHRpb25zKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzU2FtZVZlcnNpb24gPSBzaGFyZWRbc2hhcmVLZXldLmZpbmQoKHNoYXJlZFZhbCk9PnNoYXJlZFZhbC52ZXJzaW9uID09PSBuZXdVc2VyU2hhcmVkT3B0aW9ucy52ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzU2FtZVZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVkW3NoYXJlS2V5XS5wdXNoKG5ld1VzZXJTaGFyZWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNoYXJlZCxcbiAgICAgICAgc2hhcmVJbmZvc1xuICAgIH07XG59XG5mdW5jdGlvbiB2ZXJzaW9uTHQoYSwgYikge1xuICAgIGNvbnN0IHRyYW5zZm9ybUludmFsaWRWZXJzaW9uID0gKHZlcnNpb24pPT57XG4gICAgICAgIGNvbnN0IGlzTnVtYmVyVmVyc2lvbiA9ICFOdW1iZXIuaXNOYU4oTnVtYmVyKHZlcnNpb24pKTtcbiAgICAgICAgaWYgKGlzTnVtYmVyVmVyc2lvbikge1xuICAgICAgICAgICAgY29uc3Qgc3BsaXRBcnIgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBsZXQgdmFsaWRWZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCAzIC0gc3BsaXRBcnIubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIHZhbGlkVmVyc2lvbiArPSAnLjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkVmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICB9O1xuICAgIGlmIChzYXRpc2Z5KHRyYW5zZm9ybUludmFsaWRWZXJzaW9uKGEpLCBgPD0ke3RyYW5zZm9ybUludmFsaWRWZXJzaW9uKGIpfWApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBmaW5kVmVyc2lvbiA9IChzaGFyZVZlcnNpb25NYXAsIGNiKT0+e1xuICAgIGNvbnN0IGNhbGxiYWNrID0gY2IgfHwgZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uTHQocHJldiwgY3VyKTtcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzaGFyZVZlcnNpb25NYXApLnJlZHVjZSgocHJldiwgY3VyKT0+e1xuICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKHByZXYsIGN1cikpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmYXVsdCB2ZXJzaW9uIGlzICcwJyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2Jsb2IvbWFpbi9saWIvc2hhcmluZy9Qcm92aWRlU2hhcmVkTW9kdWxlLmpzI0wxMzZcbiAgICAgICAgaWYgKHByZXYgPT09ICcwJykge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldjtcbiAgICB9LCAwKTtcbn07XG5jb25zdCBpc0xvYWRlZCA9IChzaGFyZWQpPT57XG4gICAgcmV0dXJuIEJvb2xlYW4oc2hhcmVkLmxvYWRlZCkgfHwgdHlwZW9mIHNoYXJlZC5saWIgPT09ICdmdW5jdGlvbic7XG59O1xuZnVuY3Rpb24gZmluZFNpbmdsZXRvblZlcnNpb25PcmRlckJ5VmVyc2lvbihzaGFyZVNjb3BlTWFwLCBzY29wZSwgcGtnTmFtZSkge1xuICAgIGNvbnN0IHZlcnNpb25zID0gc2hhcmVTY29wZU1hcFtzY29wZV1bcGtnTmFtZV07XG4gICAgY29uc3QgY2FsbGJhY2sgPSBmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICAgICAgcmV0dXJuICFpc0xvYWRlZCh2ZXJzaW9uc1twcmV2XSkgJiYgdmVyc2lvbkx0KHByZXYsIGN1cik7XG4gICAgfTtcbiAgICByZXR1cm4gZmluZFZlcnNpb24oc2hhcmVTY29wZU1hcFtzY29wZV1bcGtnTmFtZV0sIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGZpbmRTaW5nbGV0b25WZXJzaW9uT3JkZXJCeUxvYWRlZChzaGFyZVNjb3BlTWFwLCBzY29wZSwgcGtnTmFtZSkge1xuICAgIGNvbnN0IHZlcnNpb25zID0gc2hhcmVTY29wZU1hcFtzY29wZV1bcGtnTmFtZV07XG4gICAgY29uc3QgY2FsbGJhY2sgPSBmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICAgICAgaWYgKGlzTG9hZGVkKHZlcnNpb25zW2N1cl0pKSB7XG4gICAgICAgICAgICBpZiAoaXNMb2FkZWQodmVyc2lvbnNbcHJldl0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odmVyc2lvbkx0KHByZXYsIGN1cikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMb2FkZWQodmVyc2lvbnNbcHJldl0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlcnNpb25MdChwcmV2LCBjdXIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZpbmRWZXJzaW9uKHNoYXJlU2NvcGVNYXBbc2NvcGVdW3BrZ05hbWVdLCBjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBnZXRGaW5kU2hhcmVGdW5jdGlvbihzdHJhdGVneSkge1xuICAgIGlmIChzdHJhdGVneSA9PT0gJ2xvYWRlZC1maXJzdCcpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRTaW5nbGV0b25WZXJzaW9uT3JkZXJCeUxvYWRlZDtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmRTaW5nbGV0b25WZXJzaW9uT3JkZXJCeVZlcnNpb247XG59XG5mdW5jdGlvbiBnZXRSZWdpc3RlcmVkU2hhcmUobG9jYWxTaGFyZVNjb3BlTWFwLCBwa2dOYW1lLCBzaGFyZUluZm8sIHJlc29sdmVTaGFyZSkge1xuICAgIGlmICghbG9jYWxTaGFyZVNjb3BlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBzaGFyZUNvbmZpZywgc2NvcGUgPSBERUZBVUxUX1NDT1BFLCBzdHJhdGVneSB9ID0gc2hhcmVJbmZvO1xuICAgIGNvbnN0IHNjb3BlcyA9IEFycmF5LmlzQXJyYXkoc2NvcGUpID8gc2NvcGUgOiBbXG4gICAgICAgIHNjb3BlXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IHNjIG9mIHNjb3Blcyl7XG4gICAgICAgIGlmIChzaGFyZUNvbmZpZyAmJiBsb2NhbFNoYXJlU2NvcGVNYXBbc2NdICYmIGxvY2FsU2hhcmVTY29wZU1hcFtzY11bcGtnTmFtZV0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVxdWlyZWRWZXJzaW9uIH0gPSBzaGFyZUNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IGZpbmRTaGFyZUZ1bmN0aW9uID0gZ2V0RmluZFNoYXJlRnVuY3Rpb24oc3RyYXRlZ3kpO1xuICAgICAgICAgICAgY29uc3QgbWF4T3JTaW5nbGV0b25WZXJzaW9uID0gZmluZFNoYXJlRnVuY3Rpb24obG9jYWxTaGFyZVNjb3BlTWFwLCBzYywgcGtnTmFtZSk7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRSZXNvbHZlciA9ICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKHNoYXJlQ29uZmlnLnNpbmdsZXRvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkVmVyc2lvbiA9PT0gJ3N0cmluZycgJiYgIXNhdGlzZnkobWF4T3JTaW5nbGV0b25WZXJzaW9uLCByZXF1aXJlZFZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgVmVyc2lvbiAke21heE9yU2luZ2xldG9uVmVyc2lvbn0gZnJvbSAke21heE9yU2luZ2xldG9uVmVyc2lvbiAmJiBsb2NhbFNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdW21heE9yU2luZ2xldG9uVmVyc2lvbl0uZnJvbX0gb2Ygc2hhcmVkIHNpbmdsZXRvbiBtb2R1bGUgJHtwa2dOYW1lfSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSByZXF1aXJlbWVudCBvZiAke3NoYXJlSW5mby5mcm9tfSB3aGljaCBuZWVkcyAke3JlcXVpcmVkVmVyc2lvbn0pYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFyZUNvbmZpZy5zdHJpY3RWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdW21heE9yU2luZ2xldG9uVmVyc2lvbl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkVmVyc2lvbiA9PT0gZmFsc2UgfHwgcmVxdWlyZWRWZXJzaW9uID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdW21heE9yU2luZ2xldG9uVmVyc2lvbl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhdGlzZnkobWF4T3JTaW5nbGV0b25WZXJzaW9uLCByZXF1aXJlZFZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXVttYXhPclNpbmdsZXRvblZlcnNpb25dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3ZlcnNpb25LZXksIHZlcnNpb25WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobG9jYWxTaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNhdGlzZnkodmVyc2lvbktleSwgcmVxdWlyZWRWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHNoYXJlU2NvcGVNYXA6IGxvY2FsU2hhcmVTY29wZU1hcCxcbiAgICAgICAgICAgICAgICBzY29wZTogc2MsXG4gICAgICAgICAgICAgICAgcGtnTmFtZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBtYXhPclNpbmdsZXRvblZlcnNpb24sXG4gICAgICAgICAgICAgICAgR2xvYmFsRmVkZXJhdGlvbjogR2xvYmFsLl9fRkVERVJBVElPTl9fLFxuICAgICAgICAgICAgICAgIHJlc29sdmVyOiBkZWZhdWx0UmVzb2x2ZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlU2hhcmVkID0gcmVzb2x2ZVNoYXJlLmVtaXQocGFyYW1zKSB8fCBwYXJhbXM7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVNoYXJlZC5yZXNvbHZlcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0R2xvYmFsU2hhcmVTY29wZSgpIHtcbiAgICByZXR1cm4gR2xvYmFsLl9fRkVERVJBVElPTl9fLl9fU0hBUkVfXztcbn1cbmZ1bmN0aW9uIGdldFRhcmdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGtnTmFtZSwgZXh0cmFPcHRpb25zLCBzaGFyZUluZm9zIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGRlZmF1bHRSZXNvbHZlciA9IChzaGFyZWRPcHRpb25zKT0+e1xuICAgICAgICBpZiAoIXNoYXJlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hhcmVWZXJzaW9uTWFwID0ge307XG4gICAgICAgIHNoYXJlZE9wdGlvbnMuZm9yRWFjaCgoc2hhcmVkKT0+e1xuICAgICAgICAgICAgc2hhcmVWZXJzaW9uTWFwW3NoYXJlZC52ZXJzaW9uXSA9IHNoYXJlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlzTG9hZGVkKHNoYXJlVmVyc2lvbk1hcFtwcmV2XSkgJiYgdmVyc2lvbkx0KHByZXYsIGN1cik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1heFZlcnNpb24gPSBmaW5kVmVyc2lvbihzaGFyZVZlcnNpb25NYXAsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHNoYXJlVmVyc2lvbk1hcFttYXhWZXJzaW9uXTtcbiAgICB9O1xuICAgIHZhciBfZXh0cmFPcHRpb25zX3Jlc29sdmVyO1xuICAgIGNvbnN0IHJlc29sdmVyID0gKF9leHRyYU9wdGlvbnNfcmVzb2x2ZXIgPSBleHRyYU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dHJhT3B0aW9ucy5yZXNvbHZlcikgIT0gbnVsbCA/IF9leHRyYU9wdGlvbnNfcmVzb2x2ZXIgOiBkZWZhdWx0UmVzb2x2ZXI7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlc29sdmVyKHNoYXJlSW5mb3NbcGtnTmFtZV0pLCBleHRyYU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dHJhT3B0aW9ucy5jdXN0b21TaGFyZUluZm8pO1xufVxuXG5leHBvcnQgeyBnZXRCdWlsZGVySWQgYXMgQSwgaXNCcm93c2VyRW52IGFzIEIsIHNldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvciBhcyBDLCBERUZBVUxUX1JFTU9URV9UWVBFIGFzIEQsIGdldEdsb2JhbEZlZGVyYXRpb25JbnN0YW5jZSBhcyBFLCBnZXRHbG9iYWxGZWRlcmF0aW9uQ29uc3RydWN0b3IgYXMgRiwgR2xvYmFsIGFzIEcsIHNldEdsb2JhbEZlZGVyYXRpb25JbnN0YW5jZSBhcyBILCByZWdpc3Rlckdsb2JhbFBsdWdpbnMgYXMgSSwgbmF0aXZlR2xvYmFsIGFzIEosIHJlc2V0RmVkZXJhdGlvbkdsb2JhbEluZm8gYXMgSywgZ2V0VGFyZ2V0U25hcHNob3RJbmZvQnlNb2R1bGVJbmZvIGFzIEwsIGdsb2JhbExvYWRpbmcgYXMgYSwgREVGQVVMVF9TQ09QRSBhcyBiLCBnZXRSZW1vdGVFbnRyeUV4cG9ydHMgYXMgYywgYXNzZXJ0IGFzIGQsIGdldEZNSWQgYXMgZSwgZXJyb3IgYXMgZiwgZ2V0R2xvYmFsSG9zdFBsdWdpbnMgYXMgZywgaXNQbGFpbk9iamVjdCBhcyBoLCBpc09iamVjdCBhcyBpLCBpc1JlbW90ZUluZm9XaXRoRW50cnkgYXMgaiwgaXNQdXJlUmVtb3RlRW50cnkgYXMgaywgZ2V0SW5mb1dpdGhvdXRUeXBlIGFzIGwsIGdldFByZWxvYWRlZCBhcyBtLCBzZXRQcmVsb2FkZWQgYXMgbiwgZ2V0UmVnaXN0ZXJlZFNoYXJlIGFzIG8sIGFycmF5T3B0aW9ucyBhcyBwLCBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8gYXMgcSwgYWRkR2xvYmFsU25hcHNob3QgYXMgciwgc2FmZVRvU3RyaW5nIGFzIHMsIHNldEdsb2JhbFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyBhcyB0LCBnZXRHbG9iYWxTbmFwc2hvdCBhcyB1LCBmb3JtYXRTaGFyZUNvbmZpZ3MgYXMgdiwgd2FybiBhcyB3LCBnZXRUYXJnZXRTaGFyZWRPcHRpb25zIGFzIHgsIGdldEdsb2JhbFNoYXJlU2NvcGUgYXMgeSwgYWRkVW5pcXVlSXRlbSBhcyB6IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@module-federation/runtime/dist/share.esm.js\n");

/***/ }),

/***/ "../../node_modules/@module-federation/sdk/dist/index.cjs.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@module-federation/sdk/dist/index.cjs.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _define_property$3(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nvar FederationModuleManifest = 'federation-manifest.json';\nvar MANIFEST_EXT = '.json';\nvar BROWSER_LOG_KEY = 'FEDERATION_DEBUG';\nvar BROWSER_LOG_VALUE = '1';\nvar NameTransformSymbol = {\n    AT: '@',\n    HYPHEN: '-',\n    SLASH: '/'\n};\nvar _obj;\nvar NameTransformMap = (_obj = {}, _define_property$3(_obj, NameTransformSymbol.AT, 'scope_'), _define_property$3(_obj, NameTransformSymbol.HYPHEN, '_'), _define_property$3(_obj, NameTransformSymbol.SLASH, '__'), _obj);\nvar _obj1;\nvar EncodedNameTransformMap = (_obj1 = {}, _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.AT], NameTransformSymbol.AT), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.HYPHEN], NameTransformSymbol.HYPHEN), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.SLASH], NameTransformSymbol.SLASH), _obj1);\nvar SEPARATOR = ':';\nvar ManifestFileName = 'mf-manifest.json';\nvar StatsFileName = 'mf-stats.json';\nvar MFModuleType = {\n    NPM: 'npm',\n    APP: 'app'\n};\nvar MODULE_DEVTOOL_IDENTIFIER = '__MF_DEVTOOLS_MODULE_INFO__';\n\nvar ContainerPlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar ContainerReferencePlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar ModuleFederationPlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar SharePlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nfunction isBrowserEnv() {\n    return typeof window !== 'undefined';\n}\nfunction isDebugMode() {\n    if (typeof process !== 'undefined' && process.env && process.env['FEDERATION_DEBUG']) {\n        return Boolean(process.env['FEDERATION_DEBUG']);\n    }\n    return typeof FEDERATION_DEBUG !== 'undefined' && Boolean(FEDERATION_DEBUG);\n}\nvar getProcessEnv = function getProcessEnv() {\n    return typeof process !== 'undefined' && process.env ? process.env : {};\n};\n\nfunction _array_like_to_array$2(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array$2(arr);\n}\nfunction _class_call_check(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _define_property$2(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _iterable_to_array$1(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array$1(arr) || _unsupported_iterable_to_array$2(arr) || _non_iterable_spread();\n}\nfunction _unsupported_iterable_to_array$2(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array$2(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$2(o, minLen);\n}\nfunction safeToString(info) {\n    try {\n        return JSON.stringify(info, null, 2);\n    } catch (e) {\n        return '';\n    }\n}\nvar DEBUG_LOG = '[ FEDERATION DEBUG ]';\nfunction safeGetLocalStorageItem() {\n    try {\n        if (typeof window !== 'undefined' && window.localStorage) {\n            return localStorage.getItem(BROWSER_LOG_KEY) === BROWSER_LOG_VALUE;\n        }\n    } catch (error) {\n        return typeof document !== 'undefined';\n    }\n    return false;\n}\nvar Logger = /*#__PURE__*/ function() {\n    function Logger(identifier) {\n        _class_call_check(this, Logger);\n        _define_property$2(this, \"enable\", false);\n        _define_property$2(this, \"identifier\", void 0);\n        this.identifier = identifier || DEBUG_LOG;\n        if (isBrowserEnv() && safeGetLocalStorageItem()) {\n            this.enable = true;\n        } else if (isDebugMode()) {\n            this.enable = true;\n        }\n    }\n    _create_class(Logger, [\n        {\n            key: \"info\",\n            value: function info(msg, info) {\n                if (this.enable) {\n                    var argsToString = safeToString(info) || '';\n                    if (isBrowserEnv()) {\n                        console.info(\"%c \".concat(this.identifier, \": \").concat(msg, \" \").concat(argsToString), 'color:#3300CC');\n                    } else {\n                        console.info('\\x1b[34m%s', \"\".concat(this.identifier, \": \").concat(msg, \" \").concat(argsToString ? \"\\n\".concat(argsToString) : ''));\n                    }\n                }\n            }\n        },\n        {\n            key: \"logOriginalInfo\",\n            value: function logOriginalInfo() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                if (this.enable) {\n                    if (isBrowserEnv()) {\n                        var _console;\n                        console.info(\"%c \".concat(this.identifier, \": OriginalInfo\"), 'color:#3300CC');\n                        (_console = console).log.apply(_console, _to_consumable_array(args));\n                    } else {\n                        var _console1;\n                        console.info(\"%c \".concat(this.identifier, \": OriginalInfo\"), 'color:#3300CC');\n                        (_console1 = console).log.apply(_console1, _to_consumable_array(args));\n                    }\n                }\n            }\n        }\n    ]);\n    return Logger;\n}();\n\nfunction _array_like_to_array$1(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes$1(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterable_to_array_limit$1(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest$1() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array$1(arr, i) {\n    return _array_with_holes$1(arr) || _iterable_to_array_limit$1(arr, i) || _unsupported_iterable_to_array$1(arr, i) || _non_iterable_rest$1();\n}\nfunction _to_array(arr) {\n    return _array_with_holes$1(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array$1(arr) || _non_iterable_rest$1();\n}\nfunction _unsupported_iterable_to_array$1(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array$1(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$1(o, minLen);\n}\nvar LOG_CATEGORY = '[ Federation Runtime ]';\n// entry: name:version   version : 1.0.0 | ^1.2.3\n// entry: name:entry  entry:  https://localhost:9000/federation-manifest.json\nvar parseEntry = function(str, devVerOrUrl) {\n    var separator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : SEPARATOR;\n    var strSplit = str.split(separator);\n    var devVersionOrUrl = getProcessEnv()['NODE_ENV'] === 'development' && devVerOrUrl;\n    var defaultVersion = '*';\n    var isEntry = function(s) {\n        return s.startsWith('http') || s.includes(MANIFEST_EXT);\n    };\n    // Check if the string starts with a type\n    if (strSplit.length >= 2) {\n        var _strSplit = _to_array(strSplit), name = _strSplit[0], versionOrEntryArr = _strSplit.slice(1);\n        var versionOrEntry = devVersionOrUrl || versionOrEntryArr.join(separator);\n        if (isEntry(versionOrEntry)) {\n            return {\n                name: name,\n                entry: versionOrEntry\n            };\n        } else {\n            // Apply version rule\n            // devVersionOrUrl => inputVersion => defaultVersion\n            return {\n                name: name,\n                version: versionOrEntry || defaultVersion\n            };\n        }\n    } else if (strSplit.length === 1) {\n        var _strSplit1 = _sliced_to_array$1(strSplit, 1), name1 = _strSplit1[0];\n        if (devVersionOrUrl && isEntry(devVersionOrUrl)) {\n            return {\n                name: name1,\n                entry: devVersionOrUrl\n            };\n        }\n        return {\n            name: name1,\n            version: devVersionOrUrl || defaultVersion\n        };\n    } else {\n        throw \"Invalid entry value: \".concat(str);\n    }\n};\nvar logger = new Logger();\nvar composeKeyWithSeparator =  function composeKeyWithSeparator() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!args.length) {\n        return '';\n    }\n    return args.reduce(function(sum, cur) {\n        if (!cur) {\n            return sum;\n        }\n        if (!sum) {\n            return cur;\n        }\n        return \"\".concat(sum).concat(SEPARATOR).concat(cur);\n    }, '');\n};\nvar encodeName =  function encodeName(name) {\n    var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '', withExt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    try {\n        var ext = withExt ? '.js' : '';\n        return \"\".concat(prefix).concat(name.replace(new RegExp(\"\".concat(NameTransformSymbol.AT), 'g'), NameTransformMap[NameTransformSymbol.AT]).replace(new RegExp(\"\".concat(NameTransformSymbol.HYPHEN), 'g'), NameTransformMap[NameTransformSymbol.HYPHEN]).replace(new RegExp(\"\".concat(NameTransformSymbol.SLASH), 'g'), NameTransformMap[NameTransformSymbol.SLASH])).concat(ext);\n    } catch (err) {\n        throw err;\n    }\n};\nvar decodeName =  function decodeName(name, prefix, withExt) {\n    try {\n        var decodedName = name;\n        if (prefix) {\n            if (!decodedName.startsWith(prefix)) {\n                return decodedName;\n            }\n            decodedName = decodedName.replace(new RegExp(prefix, 'g'), '');\n        }\n        decodedName = decodedName.replace(new RegExp(\"\".concat(NameTransformMap[NameTransformSymbol.AT]), 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.AT]]).replace(new RegExp(\"\".concat(NameTransformMap[NameTransformSymbol.SLASH]), 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.SLASH]]).replace(new RegExp(\"\".concat(NameTransformMap[NameTransformSymbol.HYPHEN]), 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.HYPHEN]]);\n        if (withExt) {\n            decodedName = decodedName.replace('.js', '');\n        }\n        return decodedName;\n    } catch (err) {\n        throw err;\n    }\n};\nvar generateExposeFilename =  function(exposeName, withExt) {\n    if (!exposeName) {\n        return '';\n    }\n    var expose = exposeName;\n    if (expose === '.') {\n        expose = 'default_export';\n    }\n    if (expose.startsWith('./')) {\n        expose = expose.replace('./', '');\n    }\n    return encodeName(expose, '__federation_expose_', withExt);\n};\nvar generateShareFilename =  function(pkgName, withExt) {\n    if (!pkgName) {\n        return '';\n    }\n    return encodeName(pkgName, '__federation_shared_', withExt);\n};\nvar getResourceUrl = function(module, sourceUrl) {\n    if ('getPublicPath' in module) {\n        var publicPath = new Function(module.getPublicPath)();\n        return \"\".concat(publicPath).concat(sourceUrl);\n    } else if ('publicPath' in module) {\n        return \"\".concat(module.publicPath).concat(sourceUrl);\n    } else {\n        console.warn('Can not get resource url, if in debug mode, please ignore', module, sourceUrl);\n        return '';\n    }\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nvar assert = function(condition, msg) {\n    if (!condition) {\n        error(msg);\n    }\n};\nvar error = function(msg) {\n    throw new Error(\"\".concat(LOG_CATEGORY, \": \").concat(msg));\n};\nvar warn = function(msg) {\n    console.warn(\"\".concat(LOG_CATEGORY, \": \").concat(msg));\n};\n\nfunction _define_property$1(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _object_spread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property$1(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _object_spread_props(target, source) {\n    source = source != null ? source : {};\n    if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n        ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nvar simpleJoinRemoteEntry = function(rPath, rName) {\n    if (!rPath) {\n        return rName;\n    }\n    var transformPath = function(str) {\n        if (str === '.') {\n            return '';\n        }\n        if (str.startsWith('./')) {\n            return str.replace('./', '');\n        }\n        if (str.startsWith('/')) {\n            var strWithoutSlash = str.slice(1);\n            if (strWithoutSlash.endsWith('/')) {\n                return strWithoutSlash.slice(0, -1);\n            }\n            return strWithoutSlash;\n        }\n        return str;\n    };\n    var transformedPath = transformPath(rPath);\n    if (!transformedPath) {\n        return rName;\n    }\n    if (transformedPath.endsWith('/')) {\n        return \"\".concat(transformedPath).concat(rName);\n    }\n    return \"\".concat(transformedPath, \"/\").concat(rName);\n};\nfunction inferAutoPublicPath(url) {\n    return url.replace(/#.*$/, '').replace(/\\?.*$/, '').replace(/\\/[^\\/]+$/, '/');\n}\n// Priority: overrides > remotes\n// eslint-disable-next-line max-lines-per-function\nfunction generateSnapshotFromManifest(manifest) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var _manifest_metaData, _manifest_metaData1;\n    var _options_remotes = options.remotes, remotes = _options_remotes === void 0 ? {} : _options_remotes, _options_overrides = options.overrides, overrides = _options_overrides === void 0 ? {} : _options_overrides, version = options.version;\n    var remoteSnapshot;\n    var getPublicPath = function() {\n        if ('publicPath' in manifest.metaData) {\n            if (manifest.metaData.publicPath === 'auto' && version) {\n                // use same implementation as publicPath auto runtime module implements\n                return inferAutoPublicPath(version);\n            }\n            return manifest.metaData.publicPath;\n        } else {\n            return manifest.metaData.getPublicPath;\n        }\n    };\n    var overridesKeys = Object.keys(overrides);\n    var remotesInfo = {};\n    // If remotes are not provided, only the remotes in the manifest will be read\n    if (!Object.keys(remotes).length) {\n        var _manifest_remotes;\n        remotesInfo = ((_manifest_remotes = manifest.remotes) === null || _manifest_remotes === void 0 ? void 0 : _manifest_remotes.reduce(function(res, next) {\n            var matchedVersion;\n            var name = next.federationContainerName;\n            // overrides have higher priority\n            if (overridesKeys.includes(name)) {\n                matchedVersion = overrides[name];\n            } else {\n                if ('version' in next) {\n                    matchedVersion = next.version;\n                } else {\n                    matchedVersion = next.entry;\n                }\n            }\n            res[name] = {\n                matchedVersion: matchedVersion\n            };\n            return res;\n        }, {})) || {};\n    }\n    // If remotes (deploy scenario) are specified, they need to be traversed again\n    Object.keys(remotes).forEach(function(key) {\n        return remotesInfo[key] = {\n            // overrides will override dependencies\n            matchedVersion: overridesKeys.includes(key) ? overrides[key] : remotes[key]\n        };\n    });\n    var _manifest_metaData2 = manifest.metaData, _manifest_metaData_remoteEntry = _manifest_metaData2.remoteEntry, remoteEntryPath = _manifest_metaData_remoteEntry.path, remoteEntryName = _manifest_metaData_remoteEntry.name, remoteEntryType = _manifest_metaData_remoteEntry.type, remoteTypes = _manifest_metaData2.types, buildVersion = _manifest_metaData2.buildInfo.buildVersion, globalName = _manifest_metaData2.globalName;\n    var exposes = manifest.exposes;\n    var basicRemoteSnapshot = {\n        version: version ? version : '',\n        buildVersion: buildVersion,\n        globalName: globalName,\n        remoteEntry: simpleJoinRemoteEntry(remoteEntryPath, remoteEntryName),\n        remoteEntryType: remoteEntryType,\n        remoteTypes: simpleJoinRemoteEntry(remoteTypes.path, remoteTypes.name),\n        remoteTypesZip: remoteTypes.zip || '',\n        remoteTypesAPI: remoteTypes.api || '',\n        remotesInfo: remotesInfo,\n        shared: manifest === null || manifest === void 0 ? void 0 : manifest.shared.map(function(item) {\n            return {\n                assets: item.assets,\n                sharedName: item.name,\n                version: item.version\n            };\n        }),\n        modules: exposes === null || exposes === void 0 ? void 0 : exposes.map(function(expose) {\n            return {\n                moduleName: expose.name,\n                modulePath: expose.path,\n                assets: expose.assets\n            };\n        })\n    };\n    if ((_manifest_metaData = manifest.metaData) === null || _manifest_metaData === void 0 ? void 0 : _manifest_metaData.prefetchInterface) {\n        var prefetchInterface = manifest.metaData.prefetchInterface;\n        basicRemoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            prefetchInterface: prefetchInterface\n        });\n    }\n    if ((_manifest_metaData1 = manifest.metaData) === null || _manifest_metaData1 === void 0 ? void 0 : _manifest_metaData1.prefetchEntry) {\n        var _manifest_metaData_prefetchEntry = manifest.metaData.prefetchEntry, path = _manifest_metaData_prefetchEntry.path, name = _manifest_metaData_prefetchEntry.name, type = _manifest_metaData_prefetchEntry.type;\n        basicRemoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            prefetchEntry: simpleJoinRemoteEntry(path, name),\n            prefetchEntryType: type\n        });\n    }\n    if ('publicPath' in manifest.metaData) {\n        remoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            publicPath: getPublicPath()\n        });\n    } else {\n        remoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            getPublicPath: getPublicPath()\n        });\n    }\n    return remoteSnapshot;\n}\nfunction isManifestProvider(moduleInfo) {\n    if ('remoteEntry' in moduleInfo && moduleInfo.remoteEntry.includes(MANIFEST_EXT)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator$1(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _ts_generator$1(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction safeWrapper(callback, disableWarn) {\n    return _safeWrapper.apply(this, arguments);\n}\nfunction _safeWrapper() {\n    _safeWrapper = _async_to_generator$1(function(callback, disableWarn) {\n        var res, e;\n        return _ts_generator$1(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    return [\n                        4,\n                        callback()\n                    ];\n                case 1:\n                    res = _state.sent();\n                    return [\n                        2,\n                        res\n                    ];\n                case 2:\n                    e = _state.sent();\n                    !disableWarn && warn(e);\n                    return [\n                        2\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return _safeWrapper.apply(this, arguments);\n}\nfunction isStaticResourcesEqual(url1, url2) {\n    var REG_EXP = /^(https?:)?\\/\\//i;\n    // Transform url1 and url2 into relative paths\n    var relativeUrl1 = url1.replace(REG_EXP, '').replace(/\\/$/, '');\n    var relativeUrl2 = url2.replace(REG_EXP, '').replace(/\\/$/, '');\n    // Check if the relative paths are identical\n    return relativeUrl1 === relativeUrl2;\n}\nfunction createScript(url, cb, attrs, createScriptHook) {\n    // Retrieve the existing script element by its src attribute\n    var script = null;\n    var needAttach = true;\n    var timeout = 20000;\n    var timeoutId;\n    var scripts = document.getElementsByTagName('script');\n    for(var i = 0; i < scripts.length; i++){\n        var s = scripts[i];\n        var scriptSrc = s.getAttribute('src');\n        if (scriptSrc && isStaticResourcesEqual(scriptSrc, url)) {\n            script = s;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!script) {\n        script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n        if (createScriptHook) {\n            var createScriptRes = createScriptHook(url);\n            if (_instanceof(createScriptRes, HTMLScriptElement)) {\n                script = createScriptRes;\n            } else if (typeof createScriptRes === 'object') {\n                if (createScriptRes.script) script = createScriptRes.script;\n                if (createScriptRes.timeout) timeout = createScriptRes.timeout;\n            }\n        }\n    }\n    if (attrs) {\n        Object.keys(attrs).forEach(function(name) {\n            if (script) {\n                if (name === 'async' || name === 'defer') {\n                    script[name] = attrs[name];\n                } else {\n                    script.setAttribute(name, attrs[name]);\n                }\n            }\n        });\n    }\n    var onScriptComplete = function(prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event) {\n        clearTimeout(timeoutId);\n        // Prevent memory leaks in IE.\n        if (script) {\n            script.onerror = null;\n            script.onload = null;\n            safeWrapper(function() {\n                (script === null || script === void 0 ? void 0 : script.parentNode) && script.parentNode.removeChild(script);\n            });\n            if (prev) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var res = prev(event);\n                cb();\n                return res;\n            }\n        }\n        cb();\n    };\n    script.onerror = onScriptComplete.bind(null, script.onerror);\n    script.onload = onScriptComplete.bind(null, script.onload);\n    timeoutId = setTimeout(function() {\n        onScriptComplete(null, new Error('Remote script \"'.concat(url, '\" time-outed.')));\n    }, timeout);\n    return {\n        script: script,\n        needAttach: needAttach\n    };\n}\nfunction createLink(url, cb) {\n    var attrs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, createLinkHook = arguments.length > 3 ? arguments[3] : void 0;\n    // <link rel=\"preload\" href=\"script.js\" as=\"script\">\n    // Retrieve the existing script element by its src attribute\n    var link = null;\n    var needAttach = true;\n    var links = document.getElementsByTagName('link');\n    for(var i = 0; i < links.length; i++){\n        var l = links[i];\n        var linkHref = l.getAttribute('href');\n        var linkRef = l.getAttribute('ref');\n        if (linkHref && isStaticResourcesEqual(linkHref, url) && linkRef === attrs['ref']) {\n            link = l;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!link) {\n        link = document.createElement('link');\n        link.setAttribute('href', url);\n        if (createLinkHook) {\n            var createLinkRes = createLinkHook(url);\n            if (_instanceof(createLinkRes, HTMLLinkElement)) {\n                link = createLinkRes;\n            }\n        }\n    }\n    if (attrs) {\n        Object.keys(attrs).forEach(function(name) {\n            if (link) {\n                link.setAttribute(name, attrs[name]);\n            }\n        });\n    }\n    var onLinkComplete = function(prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event) {\n        // Prevent memory leaks in IE.\n        if (link) {\n            link.onerror = null;\n            link.onload = null;\n            safeWrapper(function() {\n                (link === null || link === void 0 ? void 0 : link.parentNode) && link.parentNode.removeChild(link);\n            });\n            if (prev) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var res = prev(event);\n                cb();\n                return res;\n            }\n        }\n        cb();\n    };\n    link.onerror = onLinkComplete.bind(null, link.onerror);\n    link.onload = onLinkComplete.bind(null, link.onload);\n    return {\n        link: link,\n        needAttach: needAttach\n    };\n}\nfunction loadScript(url, info) {\n    var attrs = info.attrs, createScriptHook = info.createScriptHook;\n    return new Promise(function(resolve, _reject) {\n        var _createScript = createScript(url, resolve, attrs, createScriptHook), script = _createScript.script, needAttach = _createScript.needAttach;\n        needAttach && document.getElementsByTagName('head')[0].appendChild(script);\n    });\n}\n\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _ts_generator(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nfunction importNodeModule(name) {\n    if (!name) {\n        throw new Error('import specifier is required');\n    }\n    var importModule = new Function('name', \"return import(name)\");\n    return importModule(name).then(function(res) {\n        return res.default;\n    }).catch(function(error) {\n        console.error(\"Error importing module \".concat(name, \":\"), error);\n        throw error;\n    });\n}\nfunction createScriptNode(url, cb, attrs, createScriptHook) {\n    if (createScriptHook) {\n        var hookResult = createScriptHook(url);\n        if (hookResult && typeof hookResult === 'object' && 'url' in hookResult) {\n            url = hookResult.url;\n        }\n    }\n    var urlObj;\n    try {\n        urlObj = new URL(url);\n    } catch (e) {\n        console.error('Error constructing URL:', e);\n        cb(new Error(\"Invalid URL: \".concat(e)));\n        return;\n    }\n    var getFetch = function() {\n        var _ref = _async_to_generator(function() {\n            var fetchModule;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        if (!(typeof fetch === 'undefined')) return [\n                            3,\n                            2\n                        ];\n                        return [\n                            4,\n                            importNodeModule('node-fetch')\n                        ];\n                    case 1:\n                        fetchModule = _state.sent();\n                        //@ts-ignore\n                        return [\n                            2,\n                            (fetchModule === null || fetchModule === void 0 ? void 0 : fetchModule.default) || fetchModule\n                        ];\n                    case 2:\n                        return [\n                            2,\n                            fetch\n                        ];\n                    case 3:\n                        return [\n                            2\n                        ];\n                }\n            });\n        });\n        return function getFetch() {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    console.log('fetching', urlObj.href);\n    getFetch().then(function(f) {\n        f(urlObj.href).then(function(res) {\n            return res.text();\n        }).then(function() {\n            var _ref = _async_to_generator(function(data) {\n                var _ref, path, vm, scriptContext, urlDirname, filename, script, exportedInterface, container;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            return [\n                                4,\n                                Promise.all([\n                                    importNodeModule('path'),\n                                    importNodeModule('vm')\n                                ])\n                            ];\n                        case 1:\n                            _ref = _sliced_to_array.apply(void 0, [\n                                _state.sent(),\n                                2\n                            ]), path = _ref[0], vm = _ref[1];\n                            scriptContext = {\n                                exports: {},\n                                module: {\n                                    exports: {}\n                                }\n                            };\n                            urlDirname = urlObj.pathname.split('/').slice(0, -1).join('/');\n                            filename = path.basename(urlObj.pathname);\n                            try {\n                                script = new vm.Script(\"(function(exports, module, require, __dirname, __filename) {\".concat(data, \"\\n})\"), filename);\n                                script.runInThisContext()(scriptContext.exports, scriptContext.module, eval('require'), urlDirname, filename);\n                                exportedInterface = scriptContext.module.exports || scriptContext.exports;\n                                if (attrs && exportedInterface && attrs['globalName']) {\n                                    container = exportedInterface[attrs['globalName']] || exportedInterface;\n                                    cb(undefined, container);\n                                    return [\n                                        2\n                                    ];\n                                }\n                                cb(undefined, exportedInterface);\n                            } catch (e) {\n                                // console.error('Error running script:', e);\n                                cb(new Error(\"Script execution error: \".concat(e)));\n                            }\n                            return [\n                                2\n                            ];\n                    }\n                });\n            });\n            return function(data) {\n                return _ref.apply(this, arguments);\n            };\n        }()).catch(function(err) {\n            // console.error('Error fetching script:', err);\n            cb(err);\n        });\n    });\n}\nfunction loadScriptNode(url, info) {\n    return new Promise(function(resolve, reject) {\n        createScriptNode(url, function(error, scriptContext) {\n            if (error) {\n                reject(error);\n            } else {\n                var _info_attrs, _info_attrs1;\n                var remoteEntryKey = (info === null || info === void 0 ? void 0 : (_info_attrs = info.attrs) === null || _info_attrs === void 0 ? void 0 : _info_attrs['globalName']) || \"__FEDERATION_\".concat(info === null || info === void 0 ? void 0 : (_info_attrs1 = info.attrs) === null || _info_attrs1 === void 0 ? void 0 : _info_attrs1['name'], \":custom__\");\n                var entryExports = globalThis[remoteEntryKey] = scriptContext;\n                resolve(entryExports);\n            }\n        }, info.attrs, info.createScriptHook);\n    });\n}\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _object_spread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction normalizeOptions(enableDefault, defaultOptions, key) {\n    return function(options) {\n        if (options === false) {\n            return false;\n        }\n        if (typeof options === 'undefined') {\n            if (enableDefault) {\n                return defaultOptions;\n            } else {\n                return false;\n            }\n        }\n        if (options === true) {\n            return defaultOptions;\n        }\n        if (options && typeof options === 'object') {\n            return _object_spread({}, defaultOptions, options);\n        }\n        throw new Error(\"Unexpected type for `\".concat(key, \"`, expect boolean/undefined/object, got: \").concat(typeof options === \"undefined\" ? \"undefined\" : _type_of(options)));\n    };\n}\n\nexports.BROWSER_LOG_KEY = BROWSER_LOG_KEY;\nexports.BROWSER_LOG_VALUE = BROWSER_LOG_VALUE;\nexports.EncodedNameTransformMap = EncodedNameTransformMap;\nexports.FederationModuleManifest = FederationModuleManifest;\nexports.Logger = Logger;\nexports.MANIFEST_EXT = MANIFEST_EXT;\nexports.MFModuleType = MFModuleType;\nexports.MODULE_DEVTOOL_IDENTIFIER = MODULE_DEVTOOL_IDENTIFIER;\nexports.ManifestFileName = ManifestFileName;\nexports.NameTransformMap = NameTransformMap;\nexports.NameTransformSymbol = NameTransformSymbol;\nexports.SEPARATOR = SEPARATOR;\nexports.StatsFileName = StatsFileName;\nexports.assert = assert;\nexports.composeKeyWithSeparator = composeKeyWithSeparator;\nexports.containerPlugin = ContainerPlugin;\nexports.containerReferencePlugin = ContainerReferencePlugin;\nexports.createLink = createLink;\nexports.createScript = createScript;\nexports.createScriptNode = createScriptNode;\nexports.decodeName = decodeName;\nexports.encodeName = encodeName;\nexports.error = error;\nexports.generateExposeFilename = generateExposeFilename;\nexports.generateShareFilename = generateShareFilename;\nexports.generateSnapshotFromManifest = generateSnapshotFromManifest;\nexports.getProcessEnv = getProcessEnv;\nexports.getResourceUrl = getResourceUrl;\nexports.inferAutoPublicPath = inferAutoPublicPath;\nexports.isBrowserEnv = isBrowserEnv;\nexports.isDebugMode = isDebugMode;\nexports.isManifestProvider = isManifestProvider;\nexports.isStaticResourcesEqual = isStaticResourcesEqual;\nexports.loadScript = loadScript;\nexports.loadScriptNode = loadScriptNode;\nexports.logger = logger;\nexports.moduleFederationPlugin = ModuleFederationPlugin;\nexports.normalizeOptions = normalizeOptions;\nexports.parseEntry = parseEntry;\nexports.safeWrapper = safeWrapper;\nexports.sharePlugin = SharePlugin;\nexports.simpleJoinRemoteEntry = simpleJoinRemoteEntry;\nexports.warn = warn;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi9zZGsvZGlzdC9pbmRleC5janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLGFBQWE7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0JBQStCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLDJHQUEyRztBQUNsTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOLGlFQUFpRTtBQUNqRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtCQUErQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCxtQkFBbUI7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEMsY0FBYztBQUNkLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsaUNBQWlDO0FBQ2pDLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixxQkFBcUI7QUFDckIsY0FBYztBQUNkLCtCQUErQjtBQUMvQix1QkFBdUI7QUFDdkIsZ0NBQWdDO0FBQ2hDLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsYUFBYTtBQUNiLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0Isb0NBQW9DO0FBQ3BDLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5QixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLGNBQWM7QUFDZCw4QkFBOEI7QUFDOUIsd0JBQXdCO0FBQ3hCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLDZCQUE2QjtBQUM3QixZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9kdWxlQXBwQi8uLi8uLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3Nkay9kaXN0L2luZGV4LmNqcy5qcz8xYjdhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2RlZmluZV9wcm9wZXJ0eSQzKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG52YXIgRmVkZXJhdGlvbk1vZHVsZU1hbmlmZXN0ID0gJ2ZlZGVyYXRpb24tbWFuaWZlc3QuanNvbic7XG52YXIgTUFOSUZFU1RfRVhUID0gJy5qc29uJztcbnZhciBCUk9XU0VSX0xPR19LRVkgPSAnRkVERVJBVElPTl9ERUJVRyc7XG52YXIgQlJPV1NFUl9MT0dfVkFMVUUgPSAnMSc7XG52YXIgTmFtZVRyYW5zZm9ybVN5bWJvbCA9IHtcbiAgICBBVDogJ0AnLFxuICAgIEhZUEhFTjogJy0nLFxuICAgIFNMQVNIOiAnLydcbn07XG52YXIgX29iajtcbnZhciBOYW1lVHJhbnNmb3JtTWFwID0gKF9vYmogPSB7fSwgX2RlZmluZV9wcm9wZXJ0eSQzKF9vYmosIE5hbWVUcmFuc2Zvcm1TeW1ib2wuQVQsICdzY29wZV8nKSwgX2RlZmluZV9wcm9wZXJ0eSQzKF9vYmosIE5hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOLCAnXycpLCBfZGVmaW5lX3Byb3BlcnR5JDMoX29iaiwgTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSCwgJ19fJyksIF9vYmopO1xudmFyIF9vYmoxO1xudmFyIEVuY29kZWROYW1lVHJhbnNmb3JtTWFwID0gKF9vYmoxID0ge30sIF9kZWZpbmVfcHJvcGVydHkkMyhfb2JqMSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXSwgTmFtZVRyYW5zZm9ybVN5bWJvbC5BVCksIF9kZWZpbmVfcHJvcGVydHkkMyhfb2JqMSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTl0sIE5hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOKSwgX2RlZmluZV9wcm9wZXJ0eSQzKF9vYmoxLCBOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuU0xBU0hdLCBOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIKSwgX29iajEpO1xudmFyIFNFUEFSQVRPUiA9ICc6JztcbnZhciBNYW5pZmVzdEZpbGVOYW1lID0gJ21mLW1hbmlmZXN0Lmpzb24nO1xudmFyIFN0YXRzRmlsZU5hbWUgPSAnbWYtc3RhdHMuanNvbic7XG52YXIgTUZNb2R1bGVUeXBlID0ge1xuICAgIE5QTTogJ25wbScsXG4gICAgQVBQOiAnYXBwJ1xufTtcbnZhciBNT0RVTEVfREVWVE9PTF9JREVOVElGSUVSID0gJ19fTUZfREVWVE9PTFNfTU9EVUxFX0lORk9fXyc7XG5cbnZhciBDb250YWluZXJQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbnZhciBDb250YWluZXJSZWZlcmVuY2VQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbnZhciBNb2R1bGVGZWRlcmF0aW9uUGx1Z2luID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG52YXIgU2hhcmVQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbmZ1bmN0aW9uIGlzQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc0RlYnVnTW9kZSgpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52WydGRURFUkFUSU9OX0RFQlVHJ10pIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocHJvY2Vzcy5lbnZbJ0ZFREVSQVRJT05fREVCVUcnXSk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgRkVERVJBVElPTl9ERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgQm9vbGVhbihGRURFUkFUSU9OX0RFQlVHKTtcbn1cbnZhciBnZXRQcm9jZXNzRW52ID0gZnVuY3Rpb24gZ2V0UHJvY2Vzc0VudigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ID8gcHJvY2Vzcy5lbnYgOiB7fTtcbn07XG5cbmZ1bmN0aW9uIF9hcnJheV9saWtlX3RvX2FycmF5JDIoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKylhcnIyW2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX2FycmF5X3dpdGhvdXRfaG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5JDIoYXJyKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc19jYWxsX2NoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZV9jbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2RlZmluZV9wcm9wZXJ0eSQyKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVfdG9fYXJyYXkkMShpdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5mdW5jdGlvbiBfbm9uX2l0ZXJhYmxlX3NwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3RvX2NvbnN1bWFibGVfYXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIF9hcnJheV93aXRob3V0X2hvbGVzKGFycikgfHwgX2l0ZXJhYmxlX3RvX2FycmF5JDEoYXJyKSB8fCBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkkMihhcnIpIHx8IF9ub25faXRlcmFibGVfc3ByZWFkKCk7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkkMihvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlfbGlrZV90b19hcnJheSQyKG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlfbGlrZV90b19hcnJheSQyKG8sIG1pbkxlbik7XG59XG5mdW5jdGlvbiBzYWZlVG9TdHJpbmcoaW5mbykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbmZvLCBudWxsLCAyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG52YXIgREVCVUdfTE9HID0gJ1sgRkVERVJBVElPTiBERUJVRyBdJztcbmZ1bmN0aW9uIHNhZmVHZXRMb2NhbFN0b3JhZ2VJdGVtKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oQlJPV1NFUl9MT0dfS0VZKSA9PT0gQlJPV1NFUl9MT0dfVkFMVUU7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxudmFyIExvZ2dlciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTG9nZ2VyKGlkZW50aWZpZXIpIHtcbiAgICAgICAgX2NsYXNzX2NhbGxfY2hlY2sodGhpcywgTG9nZ2VyKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSQyKHRoaXMsIFwiZW5hYmxlXCIsIGZhbHNlKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSQyKHRoaXMsIFwiaWRlbnRpZmllclwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyIHx8IERFQlVHX0xPRztcbiAgICAgICAgaWYgKGlzQnJvd3NlckVudigpICYmIHNhZmVHZXRMb2NhbFN0b3JhZ2VJdGVtKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlYnVnTW9kZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NyZWF0ZV9jbGFzcyhMb2dnZXIsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImluZm9cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZvKG1zZywgaW5mbykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnc1RvU3RyaW5nID0gc2FmZVRvU3RyaW5nKGluZm8pIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCcm93c2VyRW52KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIiVjIFwiLmNvbmNhdCh0aGlzLmlkZW50aWZpZXIsIFwiOiBcIikuY29uY2F0KG1zZywgXCIgXCIpLmNvbmNhdChhcmdzVG9TdHJpbmcpLCAnY29sb3I6IzMzMDBDQycpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdcXHgxYlszNG0lcycsIFwiXCIuY29uY2F0KHRoaXMuaWRlbnRpZmllciwgXCI6IFwiKS5jb25jYXQobXNnLCBcIiBcIikuY29uY2F0KGFyZ3NUb1N0cmluZyA/IFwiXFxuXCIuY29uY2F0KGFyZ3NUb1N0cmluZykgOiAnJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibG9nT3JpZ2luYWxJbmZvXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9nT3JpZ2luYWxJbmZvKCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jyb3dzZXJFbnYoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jb25zb2xlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiJWMgXCIuY29uY2F0KHRoaXMuaWRlbnRpZmllciwgXCI6IE9yaWdpbmFsSW5mb1wiKSwgJ2NvbG9yOiMzMzAwQ0MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfY29uc29sZSA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZSwgX3RvX2NvbnN1bWFibGVfYXJyYXkoYXJncykpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jb25zb2xlMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIiVjIFwiLmNvbmNhdCh0aGlzLmlkZW50aWZpZXIsIFwiOiBPcmlnaW5hbEluZm9cIiksICdjb2xvcjojMzMwMENDJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2NvbnNvbGUxID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlMSwgX3RvX2NvbnN1bWFibGVfYXJyYXkoYXJncykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIExvZ2dlcjtcbn0oKTtcblxuZnVuY3Rpb24gX2FycmF5X2xpa2VfdG9fYXJyYXkkMShhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKWFycjJbaV0gPSBhcnJbaV07XG4gICAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfYXJyYXlfd2l0aF9ob2xlcyQxKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVfdG9fYXJyYXkoaXRlcikge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlX3RvX2FycmF5X2xpbWl0JDEoYXJyLCBpKSB7XG4gICAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuICAgIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfcywgX2U7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKXtcbiAgICAgICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2QgPSB0cnVlO1xuICAgICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9hcnI7XG59XG5mdW5jdGlvbiBfbm9uX2l0ZXJhYmxlX3Jlc3QkMSgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfc2xpY2VkX3RvX2FycmF5JDEoYXJyLCBpKSB7XG4gICAgcmV0dXJuIF9hcnJheV93aXRoX2hvbGVzJDEoYXJyKSB8fCBfaXRlcmFibGVfdG9fYXJyYXlfbGltaXQkMShhcnIsIGkpIHx8IF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheSQxKGFyciwgaSkgfHwgX25vbl9pdGVyYWJsZV9yZXN0JDEoKTtcbn1cbmZ1bmN0aW9uIF90b19hcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5X3dpdGhfaG9sZXMkMShhcnIpIHx8IF9pdGVyYWJsZV90b19hcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheSQxKGFycikgfHwgX25vbl9pdGVyYWJsZV9yZXN0JDEoKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheSQxKG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5JDEobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5JDEobywgbWluTGVuKTtcbn1cbnZhciBMT0dfQ0FURUdPUlkgPSAnWyBGZWRlcmF0aW9uIFJ1bnRpbWUgXSc7XG4vLyBlbnRyeTogbmFtZTp2ZXJzaW9uICAgdmVyc2lvbiA6IDEuMC4wIHwgXjEuMi4zXG4vLyBlbnRyeTogbmFtZTplbnRyeSAgZW50cnk6ICBodHRwczovL2xvY2FsaG9zdDo5MDAwL2ZlZGVyYXRpb24tbWFuaWZlc3QuanNvblxudmFyIHBhcnNlRW50cnkgPSBmdW5jdGlvbihzdHIsIGRldlZlck9yVXJsKSB7XG4gICAgdmFyIHNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogU0VQQVJBVE9SO1xuICAgIHZhciBzdHJTcGxpdCA9IHN0ci5zcGxpdChzZXBhcmF0b3IpO1xuICAgIHZhciBkZXZWZXJzaW9uT3JVcmwgPSBnZXRQcm9jZXNzRW52KClbJ05PREVfRU5WJ10gPT09ICdkZXZlbG9wbWVudCcgJiYgZGV2VmVyT3JVcmw7XG4gICAgdmFyIGRlZmF1bHRWZXJzaW9uID0gJyonO1xuICAgIHZhciBpc0VudHJ5ID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gcy5zdGFydHNXaXRoKCdodHRwJykgfHwgcy5pbmNsdWRlcyhNQU5JRkVTVF9FWFQpO1xuICAgIH07XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHN0cmluZyBzdGFydHMgd2l0aCBhIHR5cGVcbiAgICBpZiAoc3RyU3BsaXQubGVuZ3RoID49IDIpIHtcbiAgICAgICAgdmFyIF9zdHJTcGxpdCA9IF90b19hcnJheShzdHJTcGxpdCksIG5hbWUgPSBfc3RyU3BsaXRbMF0sIHZlcnNpb25PckVudHJ5QXJyID0gX3N0clNwbGl0LnNsaWNlKDEpO1xuICAgICAgICB2YXIgdmVyc2lvbk9yRW50cnkgPSBkZXZWZXJzaW9uT3JVcmwgfHwgdmVyc2lvbk9yRW50cnlBcnIuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaXNFbnRyeSh2ZXJzaW9uT3JFbnRyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBlbnRyeTogdmVyc2lvbk9yRW50cnlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBcHBseSB2ZXJzaW9uIHJ1bGVcbiAgICAgICAgICAgIC8vIGRldlZlcnNpb25PclVybCA9PiBpbnB1dFZlcnNpb24gPT4gZGVmYXVsdFZlcnNpb25cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uT3JFbnRyeSB8fCBkZWZhdWx0VmVyc2lvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyU3BsaXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBfc3RyU3BsaXQxID0gX3NsaWNlZF90b19hcnJheSQxKHN0clNwbGl0LCAxKSwgbmFtZTEgPSBfc3RyU3BsaXQxWzBdO1xuICAgICAgICBpZiAoZGV2VmVyc2lvbk9yVXJsICYmIGlzRW50cnkoZGV2VmVyc2lvbk9yVXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lMSxcbiAgICAgICAgICAgICAgICBlbnRyeTogZGV2VmVyc2lvbk9yVXJsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lMSxcbiAgICAgICAgICAgIHZlcnNpb246IGRldlZlcnNpb25PclVybCB8fCBkZWZhdWx0VmVyc2lvblxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFwiSW52YWxpZCBlbnRyeSB2YWx1ZTogXCIuY29uY2F0KHN0cik7XG4gICAgfVxufTtcbnZhciBsb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG52YXIgY29tcG9zZUtleVdpdGhTZXBhcmF0b3IgPSAgZnVuY3Rpb24gY29tcG9zZUtleVdpdGhTZXBhcmF0b3IoKSB7XG4gICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKGZ1bmN0aW9uKHN1bSwgY3VyKSB7XG4gICAgICAgIGlmICghY3VyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3VtKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChzdW0pLmNvbmNhdChTRVBBUkFUT1IpLmNvbmNhdChjdXIpO1xuICAgIH0sICcnKTtcbn07XG52YXIgZW5jb2RlTmFtZSA9ICBmdW5jdGlvbiBlbmNvZGVOYW1lKG5hbWUpIHtcbiAgICB2YXIgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiAnJywgd2l0aEV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGV4dCA9IHdpdGhFeHQgPyAnLmpzJyA6ICcnO1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQocHJlZml4KS5jb25jYXQobmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoTmFtZVRyYW5zZm9ybVN5bWJvbC5BVCksICdnJyksIE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5BVF0pLnJlcGxhY2UobmV3IFJlZ0V4cChcIlwiLmNvbmNhdChOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTiksICdnJyksIE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU5dKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSCksICdnJyksIE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF0pKS5jb25jYXQoZXh0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn07XG52YXIgZGVjb2RlTmFtZSA9ICBmdW5jdGlvbiBkZWNvZGVOYW1lKG5hbWUsIHByZWZpeCwgd2l0aEV4dCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBkZWNvZGVkTmFtZSA9IG5hbWU7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICghZGVjb2RlZE5hbWUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZWROYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZE5hbWUgPSBkZWNvZGVkTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAocHJlZml4LCAnZycpLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZE5hbWUgPSBkZWNvZGVkTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXSksICdnJyksIEVuY29kZWROYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5BVF1dKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXSksICdnJyksIEVuY29kZWROYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF1dKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTl0pLCAnZycpLCBFbmNvZGVkTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOXV0pO1xuICAgICAgICBpZiAod2l0aEV4dCkge1xuICAgICAgICAgICAgZGVjb2RlZE5hbWUgPSBkZWNvZGVkTmFtZS5yZXBsYWNlKCcuanMnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29kZWROYW1lO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcbnZhciBnZW5lcmF0ZUV4cG9zZUZpbGVuYW1lID0gIGZ1bmN0aW9uKGV4cG9zZU5hbWUsIHdpdGhFeHQpIHtcbiAgICBpZiAoIWV4cG9zZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgZXhwb3NlID0gZXhwb3NlTmFtZTtcbiAgICBpZiAoZXhwb3NlID09PSAnLicpIHtcbiAgICAgICAgZXhwb3NlID0gJ2RlZmF1bHRfZXhwb3J0JztcbiAgICB9XG4gICAgaWYgKGV4cG9zZS5zdGFydHNXaXRoKCcuLycpKSB7XG4gICAgICAgIGV4cG9zZSA9IGV4cG9zZS5yZXBsYWNlKCcuLycsICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZU5hbWUoZXhwb3NlLCAnX19mZWRlcmF0aW9uX2V4cG9zZV8nLCB3aXRoRXh0KTtcbn07XG52YXIgZ2VuZXJhdGVTaGFyZUZpbGVuYW1lID0gIGZ1bmN0aW9uKHBrZ05hbWUsIHdpdGhFeHQpIHtcbiAgICBpZiAoIXBrZ05hbWUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlTmFtZShwa2dOYW1lLCAnX19mZWRlcmF0aW9uX3NoYXJlZF8nLCB3aXRoRXh0KTtcbn07XG52YXIgZ2V0UmVzb3VyY2VVcmwgPSBmdW5jdGlvbihtb2R1bGUsIHNvdXJjZVVybCkge1xuICAgIGlmICgnZ2V0UHVibGljUGF0aCcgaW4gbW9kdWxlKSB7XG4gICAgICAgIHZhciBwdWJsaWNQYXRoID0gbmV3IEZ1bmN0aW9uKG1vZHVsZS5nZXRQdWJsaWNQYXRoKSgpO1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQocHVibGljUGF0aCkuY29uY2F0KHNvdXJjZVVybCk7XG4gICAgfSBlbHNlIGlmICgncHVibGljUGF0aCcgaW4gbW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChtb2R1bGUucHVibGljUGF0aCkuY29uY2F0KHNvdXJjZVVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDYW4gbm90IGdldCByZXNvdXJjZSB1cmwsIGlmIGluIGRlYnVnIG1vZGUsIHBsZWFzZSBpZ25vcmUnLCBtb2R1bGUsIHNvdXJjZVVybCk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbnZhciBhc3NlcnQgPSBmdW5jdGlvbihjb25kaXRpb24sIG1zZykge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIGVycm9yKG1zZyk7XG4gICAgfVxufTtcbnZhciBlcnJvciA9IGZ1bmN0aW9uKG1zZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChMT0dfQ0FURUdPUlksIFwiOiBcIikuY29uY2F0KG1zZykpO1xufTtcbnZhciB3YXJuID0gZnVuY3Rpb24obXNnKSB7XG4gICAgY29uc29sZS53YXJuKFwiXCIuY29uY2F0KExPR19DQVRFR09SWSwgXCI6IFwiKS5jb25jYXQobXNnKSk7XG59O1xuXG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5JDEob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9vYmplY3Rfc3ByZWFkJDEodGFyZ2V0KSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfZGVmaW5lX3Byb3BlcnR5JDEodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICAgIGlmIChlbnVtZXJhYmxlT25seSkge1xuICAgICAgICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3Rfc3ByZWFkX3Byb3BzKHRhcmdldCwgc291cmNlKSB7XG4gICAgc291cmNlID0gc291cmNlICE9IG51bGwgPyBzb3VyY2UgOiB7fTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxudmFyIHNpbXBsZUpvaW5SZW1vdGVFbnRyeSA9IGZ1bmN0aW9uKHJQYXRoLCByTmFtZSkge1xuICAgIGlmICghclBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHJOYW1lO1xuICAgIH1cbiAgICB2YXIgdHJhbnNmb3JtUGF0aCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBpZiAoc3RyID09PSAnLicpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgnLi8nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIHZhciBzdHJXaXRob3V0U2xhc2ggPSBzdHIuc2xpY2UoMSk7XG4gICAgICAgICAgICBpZiAoc3RyV2l0aG91dFNsYXNoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyV2l0aG91dFNsYXNoLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJXaXRob3V0U2xhc2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuICAgIHZhciB0cmFuc2Zvcm1lZFBhdGggPSB0cmFuc2Zvcm1QYXRoKHJQYXRoKTtcbiAgICBpZiAoIXRyYW5zZm9ybWVkUGF0aCkge1xuICAgICAgICByZXR1cm4gck5hbWU7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1lZFBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodHJhbnNmb3JtZWRQYXRoKS5jb25jYXQock5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIi5jb25jYXQodHJhbnNmb3JtZWRQYXRoLCBcIi9cIikuY29uY2F0KHJOYW1lKTtcbn07XG5mdW5jdGlvbiBpbmZlckF1dG9QdWJsaWNQYXRoKHVybCkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvIy4qJC8sICcnKS5yZXBsYWNlKC9cXD8uKiQvLCAnJykucmVwbGFjZSgvXFwvW15cXC9dKyQvLCAnLycpO1xufVxuLy8gUHJpb3JpdHk6IG92ZXJyaWRlcyA+IHJlbW90ZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGluZXMtcGVyLWZ1bmN0aW9uXG5mdW5jdGlvbiBnZW5lcmF0ZVNuYXBzaG90RnJvbU1hbmlmZXN0KG1hbmlmZXN0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfbWFuaWZlc3RfbWV0YURhdGEsIF9tYW5pZmVzdF9tZXRhRGF0YTE7XG4gICAgdmFyIF9vcHRpb25zX3JlbW90ZXMgPSBvcHRpb25zLnJlbW90ZXMsIHJlbW90ZXMgPSBfb3B0aW9uc19yZW1vdGVzID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX3JlbW90ZXMsIF9vcHRpb25zX292ZXJyaWRlcyA9IG9wdGlvbnMub3ZlcnJpZGVzLCBvdmVycmlkZXMgPSBfb3B0aW9uc19vdmVycmlkZXMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnNfb3ZlcnJpZGVzLCB2ZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uO1xuICAgIHZhciByZW1vdGVTbmFwc2hvdDtcbiAgICB2YXIgZ2V0UHVibGljUGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoJ3B1YmxpY1BhdGgnIGluIG1hbmlmZXN0Lm1ldGFEYXRhKSB7XG4gICAgICAgICAgICBpZiAobWFuaWZlc3QubWV0YURhdGEucHVibGljUGF0aCA9PT0gJ2F1dG8nICYmIHZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAvLyB1c2Ugc2FtZSBpbXBsZW1lbnRhdGlvbiBhcyBwdWJsaWNQYXRoIGF1dG8gcnVudGltZSBtb2R1bGUgaW1wbGVtZW50c1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmZlckF1dG9QdWJsaWNQYXRoKHZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hbmlmZXN0Lm1ldGFEYXRhLnB1YmxpY1BhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWFuaWZlc3QubWV0YURhdGEuZ2V0UHVibGljUGF0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG92ZXJyaWRlc0tleXMgPSBPYmplY3Qua2V5cyhvdmVycmlkZXMpO1xuICAgIHZhciByZW1vdGVzSW5mbyA9IHt9O1xuICAgIC8vIElmIHJlbW90ZXMgYXJlIG5vdCBwcm92aWRlZCwgb25seSB0aGUgcmVtb3RlcyBpbiB0aGUgbWFuaWZlc3Qgd2lsbCBiZSByZWFkXG4gICAgaWYgKCFPYmplY3Qua2V5cyhyZW1vdGVzKS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIF9tYW5pZmVzdF9yZW1vdGVzO1xuICAgICAgICByZW1vdGVzSW5mbyA9ICgoX21hbmlmZXN0X3JlbW90ZXMgPSBtYW5pZmVzdC5yZW1vdGVzKSA9PT0gbnVsbCB8fCBfbWFuaWZlc3RfcmVtb3RlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hbmlmZXN0X3JlbW90ZXMucmVkdWNlKGZ1bmN0aW9uKHJlcywgbmV4dCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWRWZXJzaW9uO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBuZXh0LmZlZGVyYXRpb25Db250YWluZXJOYW1lO1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVzIGhhdmUgaGlnaGVyIHByaW9yaXR5XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVzS2V5cy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRWZXJzaW9uID0gb3ZlcnJpZGVzW25hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoJ3ZlcnNpb24nIGluIG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb24gPSBuZXh0LnZlcnNpb247XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb24gPSBuZXh0LmVudHJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbjogbWF0Y2hlZFZlcnNpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCB7fSkpIHx8IHt9O1xuICAgIH1cbiAgICAvLyBJZiByZW1vdGVzIChkZXBsb3kgc2NlbmFyaW8pIGFyZSBzcGVjaWZpZWQsIHRoZXkgbmVlZCB0byBiZSB0cmF2ZXJzZWQgYWdhaW5cbiAgICBPYmplY3Qua2V5cyhyZW1vdGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gcmVtb3Rlc0luZm9ba2V5XSA9IHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlcyB3aWxsIG92ZXJyaWRlIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb246IG92ZXJyaWRlc0tleXMuaW5jbHVkZXMoa2V5KSA/IG92ZXJyaWRlc1trZXldIDogcmVtb3Rlc1trZXldXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIF9tYW5pZmVzdF9tZXRhRGF0YTIgPSBtYW5pZmVzdC5tZXRhRGF0YSwgX21hbmlmZXN0X21ldGFEYXRhX3JlbW90ZUVudHJ5ID0gX21hbmlmZXN0X21ldGFEYXRhMi5yZW1vdGVFbnRyeSwgcmVtb3RlRW50cnlQYXRoID0gX21hbmlmZXN0X21ldGFEYXRhX3JlbW90ZUVudHJ5LnBhdGgsIHJlbW90ZUVudHJ5TmFtZSA9IF9tYW5pZmVzdF9tZXRhRGF0YV9yZW1vdGVFbnRyeS5uYW1lLCByZW1vdGVFbnRyeVR5cGUgPSBfbWFuaWZlc3RfbWV0YURhdGFfcmVtb3RlRW50cnkudHlwZSwgcmVtb3RlVHlwZXMgPSBfbWFuaWZlc3RfbWV0YURhdGEyLnR5cGVzLCBidWlsZFZlcnNpb24gPSBfbWFuaWZlc3RfbWV0YURhdGEyLmJ1aWxkSW5mby5idWlsZFZlcnNpb24sIGdsb2JhbE5hbWUgPSBfbWFuaWZlc3RfbWV0YURhdGEyLmdsb2JhbE5hbWU7XG4gICAgdmFyIGV4cG9zZXMgPSBtYW5pZmVzdC5leHBvc2VzO1xuICAgIHZhciBiYXNpY1JlbW90ZVNuYXBzaG90ID0ge1xuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uID8gdmVyc2lvbiA6ICcnLFxuICAgICAgICBidWlsZFZlcnNpb246IGJ1aWxkVmVyc2lvbixcbiAgICAgICAgZ2xvYmFsTmFtZTogZ2xvYmFsTmFtZSxcbiAgICAgICAgcmVtb3RlRW50cnk6IHNpbXBsZUpvaW5SZW1vdGVFbnRyeShyZW1vdGVFbnRyeVBhdGgsIHJlbW90ZUVudHJ5TmFtZSksXG4gICAgICAgIHJlbW90ZUVudHJ5VHlwZTogcmVtb3RlRW50cnlUeXBlLFxuICAgICAgICByZW1vdGVUeXBlczogc2ltcGxlSm9pblJlbW90ZUVudHJ5KHJlbW90ZVR5cGVzLnBhdGgsIHJlbW90ZVR5cGVzLm5hbWUpLFxuICAgICAgICByZW1vdGVUeXBlc1ppcDogcmVtb3RlVHlwZXMuemlwIHx8ICcnLFxuICAgICAgICByZW1vdGVUeXBlc0FQSTogcmVtb3RlVHlwZXMuYXBpIHx8ICcnLFxuICAgICAgICByZW1vdGVzSW5mbzogcmVtb3Rlc0luZm8sXG4gICAgICAgIHNoYXJlZDogbWFuaWZlc3QgPT09IG51bGwgfHwgbWFuaWZlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hbmlmZXN0LnNoYXJlZC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhc3NldHM6IGl0ZW0uYXNzZXRzLFxuICAgICAgICAgICAgICAgIHNoYXJlZE5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBpdGVtLnZlcnNpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICBtb2R1bGVzOiBleHBvc2VzID09PSBudWxsIHx8IGV4cG9zZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4cG9zZXMubWFwKGZ1bmN0aW9uKGV4cG9zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBleHBvc2UubmFtZSxcbiAgICAgICAgICAgICAgICBtb2R1bGVQYXRoOiBleHBvc2UucGF0aCxcbiAgICAgICAgICAgICAgICBhc3NldHM6IGV4cG9zZS5hc3NldHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgfTtcbiAgICBpZiAoKF9tYW5pZmVzdF9tZXRhRGF0YSA9IG1hbmlmZXN0Lm1ldGFEYXRhKSA9PT0gbnVsbCB8fCBfbWFuaWZlc3RfbWV0YURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9tZXRhRGF0YS5wcmVmZXRjaEludGVyZmFjZSkge1xuICAgICAgICB2YXIgcHJlZmV0Y2hJbnRlcmZhY2UgPSBtYW5pZmVzdC5tZXRhRGF0YS5wcmVmZXRjaEludGVyZmFjZTtcbiAgICAgICAgYmFzaWNSZW1vdGVTbmFwc2hvdCA9IF9vYmplY3Rfc3ByZWFkX3Byb3BzKF9vYmplY3Rfc3ByZWFkJDEoe30sIGJhc2ljUmVtb3RlU25hcHNob3QpLCB7XG4gICAgICAgICAgICBwcmVmZXRjaEludGVyZmFjZTogcHJlZmV0Y2hJbnRlcmZhY2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgoX21hbmlmZXN0X21ldGFEYXRhMSA9IG1hbmlmZXN0Lm1ldGFEYXRhKSA9PT0gbnVsbCB8fCBfbWFuaWZlc3RfbWV0YURhdGExID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWFuaWZlc3RfbWV0YURhdGExLnByZWZldGNoRW50cnkpIHtcbiAgICAgICAgdmFyIF9tYW5pZmVzdF9tZXRhRGF0YV9wcmVmZXRjaEVudHJ5ID0gbWFuaWZlc3QubWV0YURhdGEucHJlZmV0Y2hFbnRyeSwgcGF0aCA9IF9tYW5pZmVzdF9tZXRhRGF0YV9wcmVmZXRjaEVudHJ5LnBhdGgsIG5hbWUgPSBfbWFuaWZlc3RfbWV0YURhdGFfcHJlZmV0Y2hFbnRyeS5uYW1lLCB0eXBlID0gX21hbmlmZXN0X21ldGFEYXRhX3ByZWZldGNoRW50cnkudHlwZTtcbiAgICAgICAgYmFzaWNSZW1vdGVTbmFwc2hvdCA9IF9vYmplY3Rfc3ByZWFkX3Byb3BzKF9vYmplY3Rfc3ByZWFkJDEoe30sIGJhc2ljUmVtb3RlU25hcHNob3QpLCB7XG4gICAgICAgICAgICBwcmVmZXRjaEVudHJ5OiBzaW1wbGVKb2luUmVtb3RlRW50cnkocGF0aCwgbmFtZSksXG4gICAgICAgICAgICBwcmVmZXRjaEVudHJ5VHlwZTogdHlwZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCdwdWJsaWNQYXRoJyBpbiBtYW5pZmVzdC5tZXRhRGF0YSkge1xuICAgICAgICByZW1vdGVTbmFwc2hvdCA9IF9vYmplY3Rfc3ByZWFkX3Byb3BzKF9vYmplY3Rfc3ByZWFkJDEoe30sIGJhc2ljUmVtb3RlU25hcHNob3QpLCB7XG4gICAgICAgICAgICBwdWJsaWNQYXRoOiBnZXRQdWJsaWNQYXRoKClcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3RlU25hcHNob3QgPSBfb2JqZWN0X3NwcmVhZF9wcm9wcyhfb2JqZWN0X3NwcmVhZCQxKHt9LCBiYXNpY1JlbW90ZVNuYXBzaG90KSwge1xuICAgICAgICAgICAgZ2V0UHVibGljUGF0aDogZ2V0UHVibGljUGF0aCgpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVtb3RlU25hcHNob3Q7XG59XG5mdW5jdGlvbiBpc01hbmlmZXN0UHJvdmlkZXIobW9kdWxlSW5mbykge1xuICAgIGlmICgncmVtb3RlRW50cnknIGluIG1vZHVsZUluZm8gJiYgbW9kdWxlSW5mby5yZW1vdGVFbnRyeS5pbmNsdWRlcyhNQU5JRkVTVF9FWFQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcCQxKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9hc3luY190b19nZW5lcmF0b3IkMShmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcCQxKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcCQxKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gX2luc3RhbmNlb2YobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAocmlnaHQgIT0gbnVsbCAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIHJpZ2h0W1N5bWJvbC5oYXNJbnN0YW5jZV0pIHtcbiAgICAgICAgcmV0dXJuICEhcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXShsZWZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGVmdCBpbnN0YW5jZW9mIHJpZ2h0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIF90c19nZW5lcmF0b3IkMSh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIGYsIHksIHQsIGcsIF8gPSB7XG4gICAgICAgIGxhYmVsOiAwLFxuICAgICAgICBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTtcbiAgICAgICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgICB9LFxuICAgICAgICB0cnlzOiBbXSxcbiAgICAgICAgb3BzOiBbXVxuICAgIH07XG4gICAgcmV0dXJuIGcgPSB7XG4gICAgICAgIG5leHQ6IHZlcmIoMCksXG4gICAgICAgIFwidGhyb3dcIjogdmVyYigxKSxcbiAgICAgICAgXCJyZXR1cm5cIjogdmVyYigyKVxuICAgIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoW1xuICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgdlxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZShfKXRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW1xuICAgICAgICAgICAgICAgIG9wWzBdICYgMixcbiAgICAgICAgICAgICAgICB0LnZhbHVlXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc3dpdGNoKG9wWzBdKXtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICBvcCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvcCA9IFtcbiAgICAgICAgICAgICAgICA2LFxuICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsXG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHNhZmVXcmFwcGVyKGNhbGxiYWNrLCBkaXNhYmxlV2Fybikge1xuICAgIHJldHVybiBfc2FmZVdyYXBwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9zYWZlV3JhcHBlcigpIHtcbiAgICBfc2FmZVdyYXBwZXIgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yJDEoZnVuY3Rpb24oY2FsbGJhY2ssIGRpc2FibGVXYXJuKSB7XG4gICAgICAgIHZhciByZXMsIGU7XG4gICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yJDEodGhpcywgZnVuY3Rpb24oX3N0YXRlKSB7XG4gICAgICAgICAgICBzd2l0Y2goX3N0YXRlLmxhYmVsKXtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9zdGF0ZS50cnlzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICAzXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBlID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgIWRpc2FibGVXYXJuICYmIHdhcm4oZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3NhZmVXcmFwcGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBpc1N0YXRpY1Jlc291cmNlc0VxdWFsKHVybDEsIHVybDIpIHtcbiAgICB2YXIgUkVHX0VYUCA9IC9eKGh0dHBzPzopP1xcL1xcLy9pO1xuICAgIC8vIFRyYW5zZm9ybSB1cmwxIGFuZCB1cmwyIGludG8gcmVsYXRpdmUgcGF0aHNcbiAgICB2YXIgcmVsYXRpdmVVcmwxID0gdXJsMS5yZXBsYWNlKFJFR19FWFAsICcnKS5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgIHZhciByZWxhdGl2ZVVybDIgPSB1cmwyLnJlcGxhY2UoUkVHX0VYUCwgJycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJlbGF0aXZlIHBhdGhzIGFyZSBpZGVudGljYWxcbiAgICByZXR1cm4gcmVsYXRpdmVVcmwxID09PSByZWxhdGl2ZVVybDI7XG59XG5mdW5jdGlvbiBjcmVhdGVTY3JpcHQodXJsLCBjYiwgYXR0cnMsIGNyZWF0ZVNjcmlwdEhvb2spIHtcbiAgICAvLyBSZXRyaWV2ZSB0aGUgZXhpc3Rpbmcgc2NyaXB0IGVsZW1lbnQgYnkgaXRzIHNyYyBhdHRyaWJ1dGVcbiAgICB2YXIgc2NyaXB0ID0gbnVsbDtcbiAgICB2YXIgbmVlZEF0dGFjaCA9IHRydWU7XG4gICAgdmFyIHRpbWVvdXQgPSAyMDAwMDtcbiAgICB2YXIgdGltZW91dElkO1xuICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHMgPSBzY3JpcHRzW2ldO1xuICAgICAgICB2YXIgc2NyaXB0U3JjID0gcy5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICBpZiAoc2NyaXB0U3JjICYmIGlzU3RhdGljUmVzb3VyY2VzRXF1YWwoc2NyaXB0U3JjLCB1cmwpKSB7XG4gICAgICAgICAgICBzY3JpcHQgPSBzO1xuICAgICAgICAgICAgbmVlZEF0dGFjaCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzY3JpcHQpIHtcbiAgICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgIGlmIChjcmVhdGVTY3JpcHRIb29rKSB7XG4gICAgICAgICAgICB2YXIgY3JlYXRlU2NyaXB0UmVzID0gY3JlYXRlU2NyaXB0SG9vayh1cmwpO1xuICAgICAgICAgICAgaWYgKF9pbnN0YW5jZW9mKGNyZWF0ZVNjcmlwdFJlcywgSFRNTFNjcmlwdEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gY3JlYXRlU2NyaXB0UmVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY3JlYXRlU2NyaXB0UmVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChjcmVhdGVTY3JpcHRSZXMuc2NyaXB0KSBzY3JpcHQgPSBjcmVhdGVTY3JpcHRSZXMuc2NyaXB0O1xuICAgICAgICAgICAgICAgIGlmIChjcmVhdGVTY3JpcHRSZXMudGltZW91dCkgdGltZW91dCA9IGNyZWF0ZVNjcmlwdFJlcy50aW1lb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRycykge1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdhc3luYycgfHwgbmFtZSA9PT0gJ2RlZmVyJykge1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHRbbmFtZV0gPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgb25TY3JpcHRDb21wbGV0ZSA9IGZ1bmN0aW9uKHByZXYsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZXZlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzIGluIElFLlxuICAgICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgICAgICBzY3JpcHQub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICBzY3JpcHQub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIHNhZmVXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIChzY3JpcHQgPT09IG51bGwgfHwgc2NyaXB0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY3JpcHQucGFyZW50Tm9kZSkgJiYgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBwcmV2KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2IoKTtcbiAgICB9O1xuICAgIHNjcmlwdC5vbmVycm9yID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmVycm9yKTtcbiAgICBzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmxvYWQpO1xuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9uU2NyaXB0Q29tcGxldGUobnVsbCwgbmV3IEVycm9yKCdSZW1vdGUgc2NyaXB0IFwiJy5jb25jYXQodXJsLCAnXCIgdGltZS1vdXRlZC4nKSkpO1xuICAgIH0sIHRpbWVvdXQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNjcmlwdDogc2NyaXB0LFxuICAgICAgICBuZWVkQXR0YWNoOiBuZWVkQXR0YWNoXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxpbmsodXJsLCBjYikge1xuICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDoge30sIGNyZWF0ZUxpbmtIb29rID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB2b2lkIDA7XG4gICAgLy8gPGxpbmsgcmVsPVwicHJlbG9hZFwiIGhyZWY9XCJzY3JpcHQuanNcIiBhcz1cInNjcmlwdFwiPlxuICAgIC8vIFJldHJpZXZlIHRoZSBleGlzdGluZyBzY3JpcHQgZWxlbWVudCBieSBpdHMgc3JjIGF0dHJpYnV0ZVxuICAgIHZhciBsaW5rID0gbnVsbDtcbiAgICB2YXIgbmVlZEF0dGFjaCA9IHRydWU7XG4gICAgdmFyIGxpbmtzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpbmsnKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgbCA9IGxpbmtzW2ldO1xuICAgICAgICB2YXIgbGlua0hyZWYgPSBsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICB2YXIgbGlua1JlZiA9IGwuZ2V0QXR0cmlidXRlKCdyZWYnKTtcbiAgICAgICAgaWYgKGxpbmtIcmVmICYmIGlzU3RhdGljUmVzb3VyY2VzRXF1YWwobGlua0hyZWYsIHVybCkgJiYgbGlua1JlZiA9PT0gYXR0cnNbJ3JlZiddKSB7XG4gICAgICAgICAgICBsaW5rID0gbDtcbiAgICAgICAgICAgIG5lZWRBdHRhY2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbGluaykge1xuICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XG4gICAgICAgIGlmIChjcmVhdGVMaW5rSG9vaykge1xuICAgICAgICAgICAgdmFyIGNyZWF0ZUxpbmtSZXMgPSBjcmVhdGVMaW5rSG9vayh1cmwpO1xuICAgICAgICAgICAgaWYgKF9pbnN0YW5jZW9mKGNyZWF0ZUxpbmtSZXMsIEhUTUxMaW5rRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBsaW5rID0gY3JlYXRlTGlua1JlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgb25MaW5rQ29tcGxldGUgPSBmdW5jdGlvbihwcmV2LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGV2ZW50KSB7XG4gICAgICAgIC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzIGluIElFLlxuICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgbGluay5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIGxpbmsub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIHNhZmVXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIChsaW5rID09PSBudWxsIHx8IGxpbmsgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmsucGFyZW50Tm9kZSkgJiYgbGluay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHByZXYoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYigpO1xuICAgIH07XG4gICAgbGluay5vbmVycm9yID0gb25MaW5rQ29tcGxldGUuYmluZChudWxsLCBsaW5rLm9uZXJyb3IpO1xuICAgIGxpbmsub25sb2FkID0gb25MaW5rQ29tcGxldGUuYmluZChudWxsLCBsaW5rLm9ubG9hZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluazogbGluayxcbiAgICAgICAgbmVlZEF0dGFjaDogbmVlZEF0dGFjaFxuICAgIH07XG59XG5mdW5jdGlvbiBsb2FkU2NyaXB0KHVybCwgaW5mbykge1xuICAgIHZhciBhdHRycyA9IGluZm8uYXR0cnMsIGNyZWF0ZVNjcmlwdEhvb2sgPSBpbmZvLmNyZWF0ZVNjcmlwdEhvb2s7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIF9yZWplY3QpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVTY3JpcHQgPSBjcmVhdGVTY3JpcHQodXJsLCByZXNvbHZlLCBhdHRycywgY3JlYXRlU2NyaXB0SG9vayksIHNjcmlwdCA9IF9jcmVhdGVTY3JpcHQuc2NyaXB0LCBuZWVkQXR0YWNoID0gX2NyZWF0ZVNjcmlwdC5uZWVkQXR0YWNoO1xuICAgICAgICBuZWVkQXR0YWNoICYmIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2FycmF5X2xpa2VfdG9fYXJyYXkoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKylhcnIyW2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX2FycmF5X3dpdGhfaG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgICB9XG59XG5mdW5jdGlvbiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZV90b19hcnJheV9saW1pdChhcnIsIGkpIHtcbiAgICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG4gICAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9zLCBfZTtcbiAgICB0cnkge1xuICAgICAgICBmb3IoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpe1xuICAgICAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZCA9IHRydWU7XG4gICAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2Fycjtcbn1cbmZ1bmN0aW9uIF9ub25faXRlcmFibGVfcmVzdCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfc2xpY2VkX3RvX2FycmF5KGFyciwgaSkge1xuICAgIHJldHVybiBfYXJyYXlfd2l0aF9ob2xlcyhhcnIpIHx8IF9pdGVyYWJsZV90b19hcnJheV9saW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheShhcnIsIGkpIHx8IF9ub25faXRlcmFibGVfcmVzdCgpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlfbGlrZV90b19hcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX3RzX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIGYsIHksIHQsIGcsIF8gPSB7XG4gICAgICAgIGxhYmVsOiAwLFxuICAgICAgICBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTtcbiAgICAgICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgICB9LFxuICAgICAgICB0cnlzOiBbXSxcbiAgICAgICAgb3BzOiBbXVxuICAgIH07XG4gICAgcmV0dXJuIGcgPSB7XG4gICAgICAgIG5leHQ6IHZlcmIoMCksXG4gICAgICAgIFwidGhyb3dcIjogdmVyYigxKSxcbiAgICAgICAgXCJyZXR1cm5cIjogdmVyYigyKVxuICAgIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoW1xuICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgdlxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZShfKXRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW1xuICAgICAgICAgICAgICAgIG9wWzBdICYgMixcbiAgICAgICAgICAgICAgICB0LnZhbHVlXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc3dpdGNoKG9wWzBdKXtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICBvcCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvcCA9IFtcbiAgICAgICAgICAgICAgICA2LFxuICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsXG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gaW1wb3J0Tm9kZU1vZHVsZShuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW1wb3J0IHNwZWNpZmllciBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICB2YXIgaW1wb3J0TW9kdWxlID0gbmV3IEZ1bmN0aW9uKCduYW1lJywgXCJyZXR1cm4gaW1wb3J0KG5hbWUpXCIpO1xuICAgIHJldHVybiBpbXBvcnRNb2R1bGUobmFtZSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlcy5kZWZhdWx0O1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbXBvcnRpbmcgbW9kdWxlIFwiLmNvbmNhdChuYW1lLCBcIjpcIiksIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTY3JpcHROb2RlKHVybCwgY2IsIGF0dHJzLCBjcmVhdGVTY3JpcHRIb29rKSB7XG4gICAgaWYgKGNyZWF0ZVNjcmlwdEhvb2spIHtcbiAgICAgICAgdmFyIGhvb2tSZXN1bHQgPSBjcmVhdGVTY3JpcHRIb29rKHVybCk7XG4gICAgICAgIGlmIChob29rUmVzdWx0ICYmIHR5cGVvZiBob29rUmVzdWx0ID09PSAnb2JqZWN0JyAmJiAndXJsJyBpbiBob29rUmVzdWx0KSB7XG4gICAgICAgICAgICB1cmwgPSBob29rUmVzdWx0LnVybDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgdXJsT2JqO1xuICAgIHRyeSB7XG4gICAgICAgIHVybE9iaiA9IG5ldyBVUkwodXJsKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvbnN0cnVjdGluZyBVUkw6JywgZSk7XG4gICAgICAgIGNiKG5ldyBFcnJvcihcIkludmFsaWQgVVJMOiBcIi5jb25jYXQoZSkpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZ2V0RmV0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGZldGNoTW9kdWxlO1xuICAgICAgICAgICAgcmV0dXJuIF90c19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoKF9zdGF0ZS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnROb2RlTW9kdWxlKCdub2RlLWZldGNoJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoTW9kdWxlID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmZXRjaE1vZHVsZSA9PT0gbnVsbCB8fCBmZXRjaE1vZHVsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hNb2R1bGUuZGVmYXVsdCkgfHwgZmV0Y2hNb2R1bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGdldEZldGNoKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9KCk7XG4gICAgY29uc29sZS5sb2coJ2ZldGNoaW5nJywgdXJsT2JqLmhyZWYpO1xuICAgIGdldEZldGNoKCkudGhlbihmdW5jdGlvbihmKSB7XG4gICAgICAgIGYodXJsT2JqLmhyZWYpLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWYsIHBhdGgsIHZtLCBzY3JpcHRDb250ZXh0LCB1cmxEaXJuYW1lLCBmaWxlbmFtZSwgc2NyaXB0LCBleHBvcnRlZEludGVyZmFjZSwgY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goX3N0YXRlLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnROb2RlTW9kdWxlKCdwYXRoJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnROb2RlTW9kdWxlKCd2bScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX3NsaWNlZF90b19hcnJheS5hcHBseSh2b2lkIDAsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCBwYXRoID0gX3JlZlswXSwgdm0gPSBfcmVmWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdENvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybERpcm5hbWUgPSB1cmxPYmoucGF0aG5hbWUuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuam9pbignLycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gcGF0aC5iYXNlbmFtZSh1cmxPYmoucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IG5ldyB2bS5TY3JpcHQoXCIoZnVuY3Rpb24oZXhwb3J0cywgbW9kdWxlLCByZXF1aXJlLCBfX2Rpcm5hbWUsIF9fZmlsZW5hbWUpIHtcIi5jb25jYXQoZGF0YSwgXCJcXG59KVwiKSwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQucnVuSW5UaGlzQ29udGV4dCgpKHNjcmlwdENvbnRleHQuZXhwb3J0cywgc2NyaXB0Q29udGV4dC5tb2R1bGUsIGV2YWwoJ3JlcXVpcmUnKSwgdXJsRGlybmFtZSwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZEludGVyZmFjZSA9IHNjcmlwdENvbnRleHQubW9kdWxlLmV4cG9ydHMgfHwgc2NyaXB0Q29udGV4dC5leHBvcnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMgJiYgZXhwb3J0ZWRJbnRlcmZhY2UgJiYgYXR0cnNbJ2dsb2JhbE5hbWUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gZXhwb3J0ZWRJbnRlcmZhY2VbYXR0cnNbJ2dsb2JhbE5hbWUnXV0gfHwgZXhwb3J0ZWRJbnRlcmZhY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYih1bmRlZmluZWQsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IodW5kZWZpbmVkLCBleHBvcnRlZEludGVyZmFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdFcnJvciBydW5uaW5nIHNjcmlwdDonLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IobmV3IEVycm9yKFwiU2NyaXB0IGV4ZWN1dGlvbiBlcnJvcjogXCIuY29uY2F0KGUpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0oKSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzY3JpcHQ6JywgZXJyKTtcbiAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbG9hZFNjcmlwdE5vZGUodXJsLCBpbmZvKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBjcmVhdGVTY3JpcHROb2RlKHVybCwgZnVuY3Rpb24oZXJyb3IsIHNjcmlwdENvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfaW5mb19hdHRycywgX2luZm9fYXR0cnMxO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdGVFbnRyeUtleSA9IChpbmZvID09PSBudWxsIHx8IGluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfaW5mb19hdHRycyA9IGluZm8uYXR0cnMpID09PSBudWxsIHx8IF9pbmZvX2F0dHJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW5mb19hdHRyc1snZ2xvYmFsTmFtZSddKSB8fCBcIl9fRkVERVJBVElPTl9cIi5jb25jYXQoaW5mbyA9PT0gbnVsbCB8fCBpbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2luZm9fYXR0cnMxID0gaW5mby5hdHRycykgPT09IG51bGwgfHwgX2luZm9fYXR0cnMxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW5mb19hdHRyczFbJ25hbWUnXSwgXCI6Y3VzdG9tX19cIik7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5RXhwb3J0cyA9IGdsb2JhbFRoaXNbcmVtb3RlRW50cnlLZXldID0gc2NyaXB0Q29udGV4dDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGVudHJ5RXhwb3J0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGluZm8uYXR0cnMsIGluZm8uY3JlYXRlU2NyaXB0SG9vayk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVfcHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9vYmplY3Rfc3ByZWFkKHRhcmdldCkge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF90eXBlX29mKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59XG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb25zKGVuYWJsZURlZmF1bHQsIGRlZmF1bHRPcHRpb25zLCBrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdF9zcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHR5cGUgZm9yIGBcIi5jb25jYXQoa2V5LCBcImAsIGV4cGVjdCBib29sZWFuL3VuZGVmaW5lZC9vYmplY3QsIGdvdDogXCIpLmNvbmNhdCh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihvcHRpb25zKSkpO1xuICAgIH07XG59XG5cbmV4cG9ydHMuQlJPV1NFUl9MT0dfS0VZID0gQlJPV1NFUl9MT0dfS0VZO1xuZXhwb3J0cy5CUk9XU0VSX0xPR19WQUxVRSA9IEJST1dTRVJfTE9HX1ZBTFVFO1xuZXhwb3J0cy5FbmNvZGVkTmFtZVRyYW5zZm9ybU1hcCA9IEVuY29kZWROYW1lVHJhbnNmb3JtTWFwO1xuZXhwb3J0cy5GZWRlcmF0aW9uTW9kdWxlTWFuaWZlc3QgPSBGZWRlcmF0aW9uTW9kdWxlTWFuaWZlc3Q7XG5leHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcbmV4cG9ydHMuTUFOSUZFU1RfRVhUID0gTUFOSUZFU1RfRVhUO1xuZXhwb3J0cy5NRk1vZHVsZVR5cGUgPSBNRk1vZHVsZVR5cGU7XG5leHBvcnRzLk1PRFVMRV9ERVZUT09MX0lERU5USUZJRVIgPSBNT0RVTEVfREVWVE9PTF9JREVOVElGSUVSO1xuZXhwb3J0cy5NYW5pZmVzdEZpbGVOYW1lID0gTWFuaWZlc3RGaWxlTmFtZTtcbmV4cG9ydHMuTmFtZVRyYW5zZm9ybU1hcCA9IE5hbWVUcmFuc2Zvcm1NYXA7XG5leHBvcnRzLk5hbWVUcmFuc2Zvcm1TeW1ib2wgPSBOYW1lVHJhbnNmb3JtU3ltYm9sO1xuZXhwb3J0cy5TRVBBUkFUT1IgPSBTRVBBUkFUT1I7XG5leHBvcnRzLlN0YXRzRmlsZU5hbWUgPSBTdGF0c0ZpbGVOYW1lO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5leHBvcnRzLmNvbXBvc2VLZXlXaXRoU2VwYXJhdG9yID0gY29tcG9zZUtleVdpdGhTZXBhcmF0b3I7XG5leHBvcnRzLmNvbnRhaW5lclBsdWdpbiA9IENvbnRhaW5lclBsdWdpbjtcbmV4cG9ydHMuY29udGFpbmVyUmVmZXJlbmNlUGx1Z2luID0gQ29udGFpbmVyUmVmZXJlbmNlUGx1Z2luO1xuZXhwb3J0cy5jcmVhdGVMaW5rID0gY3JlYXRlTGluaztcbmV4cG9ydHMuY3JlYXRlU2NyaXB0ID0gY3JlYXRlU2NyaXB0O1xuZXhwb3J0cy5jcmVhdGVTY3JpcHROb2RlID0gY3JlYXRlU2NyaXB0Tm9kZTtcbmV4cG9ydHMuZGVjb2RlTmFtZSA9IGRlY29kZU5hbWU7XG5leHBvcnRzLmVuY29kZU5hbWUgPSBlbmNvZGVOYW1lO1xuZXhwb3J0cy5lcnJvciA9IGVycm9yO1xuZXhwb3J0cy5nZW5lcmF0ZUV4cG9zZUZpbGVuYW1lID0gZ2VuZXJhdGVFeHBvc2VGaWxlbmFtZTtcbmV4cG9ydHMuZ2VuZXJhdGVTaGFyZUZpbGVuYW1lID0gZ2VuZXJhdGVTaGFyZUZpbGVuYW1lO1xuZXhwb3J0cy5nZW5lcmF0ZVNuYXBzaG90RnJvbU1hbmlmZXN0ID0gZ2VuZXJhdGVTbmFwc2hvdEZyb21NYW5pZmVzdDtcbmV4cG9ydHMuZ2V0UHJvY2Vzc0VudiA9IGdldFByb2Nlc3NFbnY7XG5leHBvcnRzLmdldFJlc291cmNlVXJsID0gZ2V0UmVzb3VyY2VVcmw7XG5leHBvcnRzLmluZmVyQXV0b1B1YmxpY1BhdGggPSBpbmZlckF1dG9QdWJsaWNQYXRoO1xuZXhwb3J0cy5pc0Jyb3dzZXJFbnYgPSBpc0Jyb3dzZXJFbnY7XG5leHBvcnRzLmlzRGVidWdNb2RlID0gaXNEZWJ1Z01vZGU7XG5leHBvcnRzLmlzTWFuaWZlc3RQcm92aWRlciA9IGlzTWFuaWZlc3RQcm92aWRlcjtcbmV4cG9ydHMuaXNTdGF0aWNSZXNvdXJjZXNFcXVhbCA9IGlzU3RhdGljUmVzb3VyY2VzRXF1YWw7XG5leHBvcnRzLmxvYWRTY3JpcHQgPSBsb2FkU2NyaXB0O1xuZXhwb3J0cy5sb2FkU2NyaXB0Tm9kZSA9IGxvYWRTY3JpcHROb2RlO1xuZXhwb3J0cy5sb2dnZXIgPSBsb2dnZXI7XG5leHBvcnRzLm1vZHVsZUZlZGVyYXRpb25QbHVnaW4gPSBNb2R1bGVGZWRlcmF0aW9uUGx1Z2luO1xuZXhwb3J0cy5ub3JtYWxpemVPcHRpb25zID0gbm9ybWFsaXplT3B0aW9ucztcbmV4cG9ydHMucGFyc2VFbnRyeSA9IHBhcnNlRW50cnk7XG5leHBvcnRzLnNhZmVXcmFwcGVyID0gc2FmZVdyYXBwZXI7XG5leHBvcnRzLnNoYXJlUGx1Z2luID0gU2hhcmVQbHVnaW47XG5leHBvcnRzLnNpbXBsZUpvaW5SZW1vdGVFbnRyeSA9IHNpbXBsZUpvaW5SZW1vdGVFbnRyeTtcbmV4cG9ydHMud2FybiA9IHdhcm47XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@module-federation/sdk/dist/index.cjs.js\n");

/***/ }),

/***/ "../../node_modules/@module-federation/sdk/dist/index.esm.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@module-federation/sdk/dist/index.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BROWSER_LOG_KEY: () => (/* binding */ BROWSER_LOG_KEY),\n/* harmony export */   BROWSER_LOG_VALUE: () => (/* binding */ BROWSER_LOG_VALUE),\n/* harmony export */   EncodedNameTransformMap: () => (/* binding */ EncodedNameTransformMap),\n/* harmony export */   FederationModuleManifest: () => (/* binding */ FederationModuleManifest),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   MANIFEST_EXT: () => (/* binding */ MANIFEST_EXT),\n/* harmony export */   MFModuleType: () => (/* binding */ MFModuleType),\n/* harmony export */   MODULE_DEVTOOL_IDENTIFIER: () => (/* binding */ MODULE_DEVTOOL_IDENTIFIER),\n/* harmony export */   ManifestFileName: () => (/* binding */ ManifestFileName),\n/* harmony export */   NameTransformMap: () => (/* binding */ NameTransformMap),\n/* harmony export */   NameTransformSymbol: () => (/* binding */ NameTransformSymbol),\n/* harmony export */   SEPARATOR: () => (/* binding */ SEPARATOR),\n/* harmony export */   StatsFileName: () => (/* binding */ StatsFileName),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   composeKeyWithSeparator: () => (/* binding */ composeKeyWithSeparator),\n/* harmony export */   containerPlugin: () => (/* binding */ ContainerPlugin),\n/* harmony export */   containerReferencePlugin: () => (/* binding */ ContainerReferencePlugin),\n/* harmony export */   createLink: () => (/* binding */ createLink),\n/* harmony export */   createScript: () => (/* binding */ createScript),\n/* harmony export */   createScriptNode: () => (/* binding */ createScriptNode),\n/* harmony export */   decodeName: () => (/* binding */ decodeName),\n/* harmony export */   encodeName: () => (/* binding */ encodeName),\n/* harmony export */   error: () => (/* binding */ error),\n/* harmony export */   generateExposeFilename: () => (/* binding */ generateExposeFilename),\n/* harmony export */   generateShareFilename: () => (/* binding */ generateShareFilename),\n/* harmony export */   generateSnapshotFromManifest: () => (/* binding */ generateSnapshotFromManifest),\n/* harmony export */   getProcessEnv: () => (/* binding */ getProcessEnv),\n/* harmony export */   getResourceUrl: () => (/* binding */ getResourceUrl),\n/* harmony export */   inferAutoPublicPath: () => (/* binding */ inferAutoPublicPath),\n/* harmony export */   isBrowserEnv: () => (/* binding */ isBrowserEnv),\n/* harmony export */   isDebugMode: () => (/* binding */ isDebugMode),\n/* harmony export */   isManifestProvider: () => (/* binding */ isManifestProvider),\n/* harmony export */   isStaticResourcesEqual: () => (/* binding */ isStaticResourcesEqual),\n/* harmony export */   loadScript: () => (/* binding */ loadScript),\n/* harmony export */   loadScriptNode: () => (/* binding */ loadScriptNode),\n/* harmony export */   logger: () => (/* binding */ logger),\n/* harmony export */   moduleFederationPlugin: () => (/* binding */ ModuleFederationPlugin),\n/* harmony export */   normalizeOptions: () => (/* binding */ normalizeOptions),\n/* harmony export */   parseEntry: () => (/* binding */ parseEntry),\n/* harmony export */   safeWrapper: () => (/* binding */ safeWrapper),\n/* harmony export */   sharePlugin: () => (/* binding */ SharePlugin),\n/* harmony export */   simpleJoinRemoteEntry: () => (/* binding */ simpleJoinRemoteEntry),\n/* harmony export */   warn: () => (/* binding */ warn)\n/* harmony export */ });\nfunction _define_property$3(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nvar FederationModuleManifest = 'federation-manifest.json';\nvar MANIFEST_EXT = '.json';\nvar BROWSER_LOG_KEY = 'FEDERATION_DEBUG';\nvar BROWSER_LOG_VALUE = '1';\nvar NameTransformSymbol = {\n    AT: '@',\n    HYPHEN: '-',\n    SLASH: '/'\n};\nvar _obj;\nvar NameTransformMap = (_obj = {}, _define_property$3(_obj, NameTransformSymbol.AT, 'scope_'), _define_property$3(_obj, NameTransformSymbol.HYPHEN, '_'), _define_property$3(_obj, NameTransformSymbol.SLASH, '__'), _obj);\nvar _obj1;\nvar EncodedNameTransformMap = (_obj1 = {}, _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.AT], NameTransformSymbol.AT), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.HYPHEN], NameTransformSymbol.HYPHEN), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.SLASH], NameTransformSymbol.SLASH), _obj1);\nvar SEPARATOR = ':';\nvar ManifestFileName = 'mf-manifest.json';\nvar StatsFileName = 'mf-stats.json';\nvar MFModuleType = {\n    NPM: 'npm',\n    APP: 'app'\n};\nvar MODULE_DEVTOOL_IDENTIFIER = '__MF_DEVTOOLS_MODULE_INFO__';\n\nvar ContainerPlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar ContainerReferencePlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar ModuleFederationPlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar SharePlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nfunction isBrowserEnv() {\n    return typeof window !== 'undefined';\n}\nfunction isDebugMode() {\n    if (typeof process !== 'undefined' && process.env && process.env['FEDERATION_DEBUG']) {\n        return Boolean(process.env['FEDERATION_DEBUG']);\n    }\n    return typeof FEDERATION_DEBUG !== 'undefined' && Boolean(FEDERATION_DEBUG);\n}\nvar getProcessEnv = function getProcessEnv() {\n    return typeof process !== 'undefined' && process.env ? process.env : {};\n};\n\nfunction _array_like_to_array$2(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array$2(arr);\n}\nfunction _class_call_check(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _define_property$2(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _iterable_to_array$1(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array$1(arr) || _unsupported_iterable_to_array$2(arr) || _non_iterable_spread();\n}\nfunction _unsupported_iterable_to_array$2(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array$2(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$2(o, minLen);\n}\nfunction safeToString(info) {\n    try {\n        return JSON.stringify(info, null, 2);\n    } catch (e) {\n        return '';\n    }\n}\nvar DEBUG_LOG = '[ FEDERATION DEBUG ]';\nfunction safeGetLocalStorageItem() {\n    try {\n        if (typeof window !== 'undefined' && window.localStorage) {\n            return localStorage.getItem(BROWSER_LOG_KEY) === BROWSER_LOG_VALUE;\n        }\n    } catch (error) {\n        return typeof document !== 'undefined';\n    }\n    return false;\n}\nvar Logger = /*#__PURE__*/ function() {\n    function Logger(identifier) {\n        _class_call_check(this, Logger);\n        _define_property$2(this, \"enable\", false);\n        _define_property$2(this, \"identifier\", void 0);\n        this.identifier = identifier || DEBUG_LOG;\n        if (isBrowserEnv() && safeGetLocalStorageItem()) {\n            this.enable = true;\n        } else if (isDebugMode()) {\n            this.enable = true;\n        }\n    }\n    _create_class(Logger, [\n        {\n            key: \"info\",\n            value: function info(msg, info) {\n                if (this.enable) {\n                    var argsToString = safeToString(info) || '';\n                    if (isBrowserEnv()) {\n                        console.info(\"%c \".concat(this.identifier, \": \").concat(msg, \" \").concat(argsToString), 'color:#3300CC');\n                    } else {\n                        console.info('\\x1b[34m%s', \"\".concat(this.identifier, \": \").concat(msg, \" \").concat(argsToString ? \"\\n\".concat(argsToString) : ''));\n                    }\n                }\n            }\n        },\n        {\n            key: \"logOriginalInfo\",\n            value: function logOriginalInfo() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                if (this.enable) {\n                    if (isBrowserEnv()) {\n                        var _console;\n                        console.info(\"%c \".concat(this.identifier, \": OriginalInfo\"), 'color:#3300CC');\n                        (_console = console).log.apply(_console, _to_consumable_array(args));\n                    } else {\n                        var _console1;\n                        console.info(\"%c \".concat(this.identifier, \": OriginalInfo\"), 'color:#3300CC');\n                        (_console1 = console).log.apply(_console1, _to_consumable_array(args));\n                    }\n                }\n            }\n        }\n    ]);\n    return Logger;\n}();\n\nfunction _array_like_to_array$1(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes$1(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterable_to_array_limit$1(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest$1() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array$1(arr, i) {\n    return _array_with_holes$1(arr) || _iterable_to_array_limit$1(arr, i) || _unsupported_iterable_to_array$1(arr, i) || _non_iterable_rest$1();\n}\nfunction _to_array(arr) {\n    return _array_with_holes$1(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array$1(arr) || _non_iterable_rest$1();\n}\nfunction _unsupported_iterable_to_array$1(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array$1(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array$1(o, minLen);\n}\nvar LOG_CATEGORY = '[ Federation Runtime ]';\n// entry: name:version   version : 1.0.0 | ^1.2.3\n// entry: name:entry  entry:  https://localhost:9000/federation-manifest.json\nvar parseEntry = function(str, devVerOrUrl) {\n    var separator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : SEPARATOR;\n    var strSplit = str.split(separator);\n    var devVersionOrUrl = getProcessEnv()['NODE_ENV'] === 'development' && devVerOrUrl;\n    var defaultVersion = '*';\n    var isEntry = function(s) {\n        return s.startsWith('http') || s.includes(MANIFEST_EXT);\n    };\n    // Check if the string starts with a type\n    if (strSplit.length >= 2) {\n        var _strSplit = _to_array(strSplit), name = _strSplit[0], versionOrEntryArr = _strSplit.slice(1);\n        var versionOrEntry = devVersionOrUrl || versionOrEntryArr.join(separator);\n        if (isEntry(versionOrEntry)) {\n            return {\n                name: name,\n                entry: versionOrEntry\n            };\n        } else {\n            // Apply version rule\n            // devVersionOrUrl => inputVersion => defaultVersion\n            return {\n                name: name,\n                version: versionOrEntry || defaultVersion\n            };\n        }\n    } else if (strSplit.length === 1) {\n        var _strSplit1 = _sliced_to_array$1(strSplit, 1), name1 = _strSplit1[0];\n        if (devVersionOrUrl && isEntry(devVersionOrUrl)) {\n            return {\n                name: name1,\n                entry: devVersionOrUrl\n            };\n        }\n        return {\n            name: name1,\n            version: devVersionOrUrl || defaultVersion\n        };\n    } else {\n        throw \"Invalid entry value: \".concat(str);\n    }\n};\nvar logger = new Logger();\nvar composeKeyWithSeparator =  function composeKeyWithSeparator() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (!args.length) {\n        return '';\n    }\n    return args.reduce(function(sum, cur) {\n        if (!cur) {\n            return sum;\n        }\n        if (!sum) {\n            return cur;\n        }\n        return \"\".concat(sum).concat(SEPARATOR).concat(cur);\n    }, '');\n};\nvar encodeName =  function encodeName(name) {\n    var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '', withExt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    try {\n        var ext = withExt ? '.js' : '';\n        return \"\".concat(prefix).concat(name.replace(new RegExp(\"\".concat(NameTransformSymbol.AT), 'g'), NameTransformMap[NameTransformSymbol.AT]).replace(new RegExp(\"\".concat(NameTransformSymbol.HYPHEN), 'g'), NameTransformMap[NameTransformSymbol.HYPHEN]).replace(new RegExp(\"\".concat(NameTransformSymbol.SLASH), 'g'), NameTransformMap[NameTransformSymbol.SLASH])).concat(ext);\n    } catch (err) {\n        throw err;\n    }\n};\nvar decodeName =  function decodeName(name, prefix, withExt) {\n    try {\n        var decodedName = name;\n        if (prefix) {\n            if (!decodedName.startsWith(prefix)) {\n                return decodedName;\n            }\n            decodedName = decodedName.replace(new RegExp(prefix, 'g'), '');\n        }\n        decodedName = decodedName.replace(new RegExp(\"\".concat(NameTransformMap[NameTransformSymbol.AT]), 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.AT]]).replace(new RegExp(\"\".concat(NameTransformMap[NameTransformSymbol.SLASH]), 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.SLASH]]).replace(new RegExp(\"\".concat(NameTransformMap[NameTransformSymbol.HYPHEN]), 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.HYPHEN]]);\n        if (withExt) {\n            decodedName = decodedName.replace('.js', '');\n        }\n        return decodedName;\n    } catch (err) {\n        throw err;\n    }\n};\nvar generateExposeFilename =  function(exposeName, withExt) {\n    if (!exposeName) {\n        return '';\n    }\n    var expose = exposeName;\n    if (expose === '.') {\n        expose = 'default_export';\n    }\n    if (expose.startsWith('./')) {\n        expose = expose.replace('./', '');\n    }\n    return encodeName(expose, '__federation_expose_', withExt);\n};\nvar generateShareFilename =  function(pkgName, withExt) {\n    if (!pkgName) {\n        return '';\n    }\n    return encodeName(pkgName, '__federation_shared_', withExt);\n};\nvar getResourceUrl = function(module, sourceUrl) {\n    if ('getPublicPath' in module) {\n        var publicPath = new Function(module.getPublicPath)();\n        return \"\".concat(publicPath).concat(sourceUrl);\n    } else if ('publicPath' in module) {\n        return \"\".concat(module.publicPath).concat(sourceUrl);\n    } else {\n        console.warn('Can not get resource url, if in debug mode, please ignore', module, sourceUrl);\n        return '';\n    }\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nvar assert = function(condition, msg) {\n    if (!condition) {\n        error(msg);\n    }\n};\nvar error = function(msg) {\n    throw new Error(\"\".concat(LOG_CATEGORY, \": \").concat(msg));\n};\nvar warn = function(msg) {\n    console.warn(\"\".concat(LOG_CATEGORY, \": \").concat(msg));\n};\n\nfunction _define_property$1(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _object_spread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property$1(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _object_spread_props(target, source) {\n    source = source != null ? source : {};\n    if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n        ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nvar simpleJoinRemoteEntry = function(rPath, rName) {\n    if (!rPath) {\n        return rName;\n    }\n    var transformPath = function(str) {\n        if (str === '.') {\n            return '';\n        }\n        if (str.startsWith('./')) {\n            return str.replace('./', '');\n        }\n        if (str.startsWith('/')) {\n            var strWithoutSlash = str.slice(1);\n            if (strWithoutSlash.endsWith('/')) {\n                return strWithoutSlash.slice(0, -1);\n            }\n            return strWithoutSlash;\n        }\n        return str;\n    };\n    var transformedPath = transformPath(rPath);\n    if (!transformedPath) {\n        return rName;\n    }\n    if (transformedPath.endsWith('/')) {\n        return \"\".concat(transformedPath).concat(rName);\n    }\n    return \"\".concat(transformedPath, \"/\").concat(rName);\n};\nfunction inferAutoPublicPath(url) {\n    return url.replace(/#.*$/, '').replace(/\\?.*$/, '').replace(/\\/[^\\/]+$/, '/');\n}\n// Priority: overrides > remotes\n// eslint-disable-next-line max-lines-per-function\nfunction generateSnapshotFromManifest(manifest) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var _manifest_metaData, _manifest_metaData1;\n    var _options_remotes = options.remotes, remotes = _options_remotes === void 0 ? {} : _options_remotes, _options_overrides = options.overrides, overrides = _options_overrides === void 0 ? {} : _options_overrides, version = options.version;\n    var remoteSnapshot;\n    var getPublicPath = function() {\n        if ('publicPath' in manifest.metaData) {\n            if (manifest.metaData.publicPath === 'auto' && version) {\n                // use same implementation as publicPath auto runtime module implements\n                return inferAutoPublicPath(version);\n            }\n            return manifest.metaData.publicPath;\n        } else {\n            return manifest.metaData.getPublicPath;\n        }\n    };\n    var overridesKeys = Object.keys(overrides);\n    var remotesInfo = {};\n    // If remotes are not provided, only the remotes in the manifest will be read\n    if (!Object.keys(remotes).length) {\n        var _manifest_remotes;\n        remotesInfo = ((_manifest_remotes = manifest.remotes) === null || _manifest_remotes === void 0 ? void 0 : _manifest_remotes.reduce(function(res, next) {\n            var matchedVersion;\n            var name = next.federationContainerName;\n            // overrides have higher priority\n            if (overridesKeys.includes(name)) {\n                matchedVersion = overrides[name];\n            } else {\n                if ('version' in next) {\n                    matchedVersion = next.version;\n                } else {\n                    matchedVersion = next.entry;\n                }\n            }\n            res[name] = {\n                matchedVersion: matchedVersion\n            };\n            return res;\n        }, {})) || {};\n    }\n    // If remotes (deploy scenario) are specified, they need to be traversed again\n    Object.keys(remotes).forEach(function(key) {\n        return remotesInfo[key] = {\n            // overrides will override dependencies\n            matchedVersion: overridesKeys.includes(key) ? overrides[key] : remotes[key]\n        };\n    });\n    var _manifest_metaData2 = manifest.metaData, _manifest_metaData_remoteEntry = _manifest_metaData2.remoteEntry, remoteEntryPath = _manifest_metaData_remoteEntry.path, remoteEntryName = _manifest_metaData_remoteEntry.name, remoteEntryType = _manifest_metaData_remoteEntry.type, remoteTypes = _manifest_metaData2.types, buildVersion = _manifest_metaData2.buildInfo.buildVersion, globalName = _manifest_metaData2.globalName;\n    var exposes = manifest.exposes;\n    var basicRemoteSnapshot = {\n        version: version ? version : '',\n        buildVersion: buildVersion,\n        globalName: globalName,\n        remoteEntry: simpleJoinRemoteEntry(remoteEntryPath, remoteEntryName),\n        remoteEntryType: remoteEntryType,\n        remoteTypes: simpleJoinRemoteEntry(remoteTypes.path, remoteTypes.name),\n        remoteTypesZip: remoteTypes.zip || '',\n        remoteTypesAPI: remoteTypes.api || '',\n        remotesInfo: remotesInfo,\n        shared: manifest === null || manifest === void 0 ? void 0 : manifest.shared.map(function(item) {\n            return {\n                assets: item.assets,\n                sharedName: item.name,\n                version: item.version\n            };\n        }),\n        modules: exposes === null || exposes === void 0 ? void 0 : exposes.map(function(expose) {\n            return {\n                moduleName: expose.name,\n                modulePath: expose.path,\n                assets: expose.assets\n            };\n        })\n    };\n    if ((_manifest_metaData = manifest.metaData) === null || _manifest_metaData === void 0 ? void 0 : _manifest_metaData.prefetchInterface) {\n        var prefetchInterface = manifest.metaData.prefetchInterface;\n        basicRemoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            prefetchInterface: prefetchInterface\n        });\n    }\n    if ((_manifest_metaData1 = manifest.metaData) === null || _manifest_metaData1 === void 0 ? void 0 : _manifest_metaData1.prefetchEntry) {\n        var _manifest_metaData_prefetchEntry = manifest.metaData.prefetchEntry, path = _manifest_metaData_prefetchEntry.path, name = _manifest_metaData_prefetchEntry.name, type = _manifest_metaData_prefetchEntry.type;\n        basicRemoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            prefetchEntry: simpleJoinRemoteEntry(path, name),\n            prefetchEntryType: type\n        });\n    }\n    if ('publicPath' in manifest.metaData) {\n        remoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            publicPath: getPublicPath()\n        });\n    } else {\n        remoteSnapshot = _object_spread_props(_object_spread$1({}, basicRemoteSnapshot), {\n            getPublicPath: getPublicPath()\n        });\n    }\n    return remoteSnapshot;\n}\nfunction isManifestProvider(moduleInfo) {\n    if ('remoteEntry' in moduleInfo && moduleInfo.remoteEntry.includes(MANIFEST_EXT)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator$1(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _ts_generator$1(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction safeWrapper(callback, disableWarn) {\n    return _safeWrapper.apply(this, arguments);\n}\nfunction _safeWrapper() {\n    _safeWrapper = _async_to_generator$1(function(callback, disableWarn) {\n        var res, e;\n        return _ts_generator$1(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    return [\n                        4,\n                        callback()\n                    ];\n                case 1:\n                    res = _state.sent();\n                    return [\n                        2,\n                        res\n                    ];\n                case 2:\n                    e = _state.sent();\n                    !disableWarn && warn(e);\n                    return [\n                        2\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return _safeWrapper.apply(this, arguments);\n}\nfunction isStaticResourcesEqual(url1, url2) {\n    var REG_EXP = /^(https?:)?\\/\\//i;\n    // Transform url1 and url2 into relative paths\n    var relativeUrl1 = url1.replace(REG_EXP, '').replace(/\\/$/, '');\n    var relativeUrl2 = url2.replace(REG_EXP, '').replace(/\\/$/, '');\n    // Check if the relative paths are identical\n    return relativeUrl1 === relativeUrl2;\n}\nfunction createScript(url, cb, attrs, createScriptHook) {\n    // Retrieve the existing script element by its src attribute\n    var script = null;\n    var needAttach = true;\n    var timeout = 20000;\n    var timeoutId;\n    var scripts = document.getElementsByTagName('script');\n    for(var i = 0; i < scripts.length; i++){\n        var s = scripts[i];\n        var scriptSrc = s.getAttribute('src');\n        if (scriptSrc && isStaticResourcesEqual(scriptSrc, url)) {\n            script = s;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!script) {\n        script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n        if (createScriptHook) {\n            var createScriptRes = createScriptHook(url);\n            if (_instanceof(createScriptRes, HTMLScriptElement)) {\n                script = createScriptRes;\n            } else if (typeof createScriptRes === 'object') {\n                if (createScriptRes.script) script = createScriptRes.script;\n                if (createScriptRes.timeout) timeout = createScriptRes.timeout;\n            }\n        }\n    }\n    if (attrs) {\n        Object.keys(attrs).forEach(function(name) {\n            if (script) {\n                if (name === 'async' || name === 'defer') {\n                    script[name] = attrs[name];\n                } else {\n                    script.setAttribute(name, attrs[name]);\n                }\n            }\n        });\n    }\n    var onScriptComplete = function(prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event) {\n        clearTimeout(timeoutId);\n        // Prevent memory leaks in IE.\n        if (script) {\n            script.onerror = null;\n            script.onload = null;\n            safeWrapper(function() {\n                (script === null || script === void 0 ? void 0 : script.parentNode) && script.parentNode.removeChild(script);\n            });\n            if (prev) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var res = prev(event);\n                cb();\n                return res;\n            }\n        }\n        cb();\n    };\n    script.onerror = onScriptComplete.bind(null, script.onerror);\n    script.onload = onScriptComplete.bind(null, script.onload);\n    timeoutId = setTimeout(function() {\n        onScriptComplete(null, new Error('Remote script \"'.concat(url, '\" time-outed.')));\n    }, timeout);\n    return {\n        script: script,\n        needAttach: needAttach\n    };\n}\nfunction createLink(url, cb) {\n    var attrs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, createLinkHook = arguments.length > 3 ? arguments[3] : void 0;\n    // <link rel=\"preload\" href=\"script.js\" as=\"script\">\n    // Retrieve the existing script element by its src attribute\n    var link = null;\n    var needAttach = true;\n    var links = document.getElementsByTagName('link');\n    for(var i = 0; i < links.length; i++){\n        var l = links[i];\n        var linkHref = l.getAttribute('href');\n        var linkRef = l.getAttribute('ref');\n        if (linkHref && isStaticResourcesEqual(linkHref, url) && linkRef === attrs['ref']) {\n            link = l;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!link) {\n        link = document.createElement('link');\n        link.setAttribute('href', url);\n        if (createLinkHook) {\n            var createLinkRes = createLinkHook(url);\n            if (_instanceof(createLinkRes, HTMLLinkElement)) {\n                link = createLinkRes;\n            }\n        }\n    }\n    if (attrs) {\n        Object.keys(attrs).forEach(function(name) {\n            if (link) {\n                link.setAttribute(name, attrs[name]);\n            }\n        });\n    }\n    var onLinkComplete = function(prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event) {\n        // Prevent memory leaks in IE.\n        if (link) {\n            link.onerror = null;\n            link.onload = null;\n            safeWrapper(function() {\n                (link === null || link === void 0 ? void 0 : link.parentNode) && link.parentNode.removeChild(link);\n            });\n            if (prev) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var res = prev(event);\n                cb();\n                return res;\n            }\n        }\n        cb();\n    };\n    link.onerror = onLinkComplete.bind(null, link.onerror);\n    link.onload = onLinkComplete.bind(null, link.onload);\n    return {\n        link: link,\n        needAttach: needAttach\n    };\n}\nfunction loadScript(url, info) {\n    var attrs = info.attrs, createScriptHook = info.createScriptHook;\n    return new Promise(function(resolve, _reject) {\n        var _createScript = createScript(url, resolve, attrs, createScriptHook), script = _createScript.script, needAttach = _createScript.needAttach;\n        needAttach && document.getElementsByTagName('head')[0].appendChild(script);\n    });\n}\n\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _ts_generator(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nfunction importNodeModule(name) {\n    if (!name) {\n        throw new Error('import specifier is required');\n    }\n    var importModule = new Function('name', \"return import(name)\");\n    return importModule(name).then(function(res) {\n        return res.default;\n    }).catch(function(error) {\n        console.error(\"Error importing module \".concat(name, \":\"), error);\n        throw error;\n    });\n}\nfunction createScriptNode(url, cb, attrs, createScriptHook) {\n    if (createScriptHook) {\n        var hookResult = createScriptHook(url);\n        if (hookResult && typeof hookResult === 'object' && 'url' in hookResult) {\n            url = hookResult.url;\n        }\n    }\n    var urlObj;\n    try {\n        urlObj = new URL(url);\n    } catch (e) {\n        console.error('Error constructing URL:', e);\n        cb(new Error(\"Invalid URL: \".concat(e)));\n        return;\n    }\n    var getFetch = function() {\n        var _ref = _async_to_generator(function() {\n            var fetchModule;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        if (!(typeof fetch === 'undefined')) return [\n                            3,\n                            2\n                        ];\n                        return [\n                            4,\n                            importNodeModule('node-fetch')\n                        ];\n                    case 1:\n                        fetchModule = _state.sent();\n                        //@ts-ignore\n                        return [\n                            2,\n                            (fetchModule === null || fetchModule === void 0 ? void 0 : fetchModule.default) || fetchModule\n                        ];\n                    case 2:\n                        return [\n                            2,\n                            fetch\n                        ];\n                    case 3:\n                        return [\n                            2\n                        ];\n                }\n            });\n        });\n        return function getFetch() {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    console.log('fetching', urlObj.href);\n    getFetch().then(function(f) {\n        f(urlObj.href).then(function(res) {\n            return res.text();\n        }).then(function() {\n            var _ref = _async_to_generator(function(data) {\n                var _ref, path, vm, scriptContext, urlDirname, filename, script, exportedInterface, container;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            return [\n                                4,\n                                Promise.all([\n                                    importNodeModule('path'),\n                                    importNodeModule('vm')\n                                ])\n                            ];\n                        case 1:\n                            _ref = _sliced_to_array.apply(void 0, [\n                                _state.sent(),\n                                2\n                            ]), path = _ref[0], vm = _ref[1];\n                            scriptContext = {\n                                exports: {},\n                                module: {\n                                    exports: {}\n                                }\n                            };\n                            urlDirname = urlObj.pathname.split('/').slice(0, -1).join('/');\n                            filename = path.basename(urlObj.pathname);\n                            try {\n                                script = new vm.Script(\"(function(exports, module, require, __dirname, __filename) {\".concat(data, \"\\n})\"), filename);\n                                script.runInThisContext()(scriptContext.exports, scriptContext.module, eval('require'), urlDirname, filename);\n                                exportedInterface = scriptContext.module.exports || scriptContext.exports;\n                                if (attrs && exportedInterface && attrs['globalName']) {\n                                    container = exportedInterface[attrs['globalName']] || exportedInterface;\n                                    cb(undefined, container);\n                                    return [\n                                        2\n                                    ];\n                                }\n                                cb(undefined, exportedInterface);\n                            } catch (e) {\n                                // console.error('Error running script:', e);\n                                cb(new Error(\"Script execution error: \".concat(e)));\n                            }\n                            return [\n                                2\n                            ];\n                    }\n                });\n            });\n            return function(data) {\n                return _ref.apply(this, arguments);\n            };\n        }()).catch(function(err) {\n            // console.error('Error fetching script:', err);\n            cb(err);\n        });\n    });\n}\nfunction loadScriptNode(url, info) {\n    return new Promise(function(resolve, reject) {\n        createScriptNode(url, function(error, scriptContext) {\n            if (error) {\n                reject(error);\n            } else {\n                var _info_attrs, _info_attrs1;\n                var remoteEntryKey = (info === null || info === void 0 ? void 0 : (_info_attrs = info.attrs) === null || _info_attrs === void 0 ? void 0 : _info_attrs['globalName']) || \"__FEDERATION_\".concat(info === null || info === void 0 ? void 0 : (_info_attrs1 = info.attrs) === null || _info_attrs1 === void 0 ? void 0 : _info_attrs1['name'], \":custom__\");\n                var entryExports = globalThis[remoteEntryKey] = scriptContext;\n                resolve(entryExports);\n            }\n        }, info.attrs, info.createScriptHook);\n    });\n}\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _object_spread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction normalizeOptions(enableDefault, defaultOptions, key) {\n    return function(options) {\n        if (options === false) {\n            return false;\n        }\n        if (typeof options === 'undefined') {\n            if (enableDefault) {\n                return defaultOptions;\n            } else {\n                return false;\n            }\n        }\n        if (options === true) {\n            return defaultOptions;\n        }\n        if (options && typeof options === 'object') {\n            return _object_spread({}, defaultOptions, options);\n        }\n        throw new Error(\"Unexpected type for `\".concat(key, \"`, expect boolean/undefined/object, got: \").concat(typeof options === \"undefined\" ? \"undefined\" : _type_of(options)));\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi9zZGsvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsYUFBYTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQkFBK0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsMkdBQTJHO0FBQ2xNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ04saUVBQWlFO0FBQ2pFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0JBQStCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILG1CQUFtQjtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUUyekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2R1bGVBcHBCLy4uLy4uL25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vc2RrL2Rpc3QvaW5kZXguZXNtLmpzPzgwZTEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2RlZmluZV9wcm9wZXJ0eSQzKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG52YXIgRmVkZXJhdGlvbk1vZHVsZU1hbmlmZXN0ID0gJ2ZlZGVyYXRpb24tbWFuaWZlc3QuanNvbic7XG52YXIgTUFOSUZFU1RfRVhUID0gJy5qc29uJztcbnZhciBCUk9XU0VSX0xPR19LRVkgPSAnRkVERVJBVElPTl9ERUJVRyc7XG52YXIgQlJPV1NFUl9MT0dfVkFMVUUgPSAnMSc7XG52YXIgTmFtZVRyYW5zZm9ybVN5bWJvbCA9IHtcbiAgICBBVDogJ0AnLFxuICAgIEhZUEhFTjogJy0nLFxuICAgIFNMQVNIOiAnLydcbn07XG52YXIgX29iajtcbnZhciBOYW1lVHJhbnNmb3JtTWFwID0gKF9vYmogPSB7fSwgX2RlZmluZV9wcm9wZXJ0eSQzKF9vYmosIE5hbWVUcmFuc2Zvcm1TeW1ib2wuQVQsICdzY29wZV8nKSwgX2RlZmluZV9wcm9wZXJ0eSQzKF9vYmosIE5hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOLCAnXycpLCBfZGVmaW5lX3Byb3BlcnR5JDMoX29iaiwgTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSCwgJ19fJyksIF9vYmopO1xudmFyIF9vYmoxO1xudmFyIEVuY29kZWROYW1lVHJhbnNmb3JtTWFwID0gKF9vYmoxID0ge30sIF9kZWZpbmVfcHJvcGVydHkkMyhfb2JqMSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXSwgTmFtZVRyYW5zZm9ybVN5bWJvbC5BVCksIF9kZWZpbmVfcHJvcGVydHkkMyhfb2JqMSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTl0sIE5hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOKSwgX2RlZmluZV9wcm9wZXJ0eSQzKF9vYmoxLCBOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuU0xBU0hdLCBOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIKSwgX29iajEpO1xudmFyIFNFUEFSQVRPUiA9ICc6JztcbnZhciBNYW5pZmVzdEZpbGVOYW1lID0gJ21mLW1hbmlmZXN0Lmpzb24nO1xudmFyIFN0YXRzRmlsZU5hbWUgPSAnbWYtc3RhdHMuanNvbic7XG52YXIgTUZNb2R1bGVUeXBlID0ge1xuICAgIE5QTTogJ25wbScsXG4gICAgQVBQOiAnYXBwJ1xufTtcbnZhciBNT0RVTEVfREVWVE9PTF9JREVOVElGSUVSID0gJ19fTUZfREVWVE9PTFNfTU9EVUxFX0lORk9fXyc7XG5cbnZhciBDb250YWluZXJQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbnZhciBDb250YWluZXJSZWZlcmVuY2VQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbnZhciBNb2R1bGVGZWRlcmF0aW9uUGx1Z2luID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG52YXIgU2hhcmVQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbmZ1bmN0aW9uIGlzQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc0RlYnVnTW9kZSgpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52WydGRURFUkFUSU9OX0RFQlVHJ10pIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocHJvY2Vzcy5lbnZbJ0ZFREVSQVRJT05fREVCVUcnXSk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgRkVERVJBVElPTl9ERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgQm9vbGVhbihGRURFUkFUSU9OX0RFQlVHKTtcbn1cbnZhciBnZXRQcm9jZXNzRW52ID0gZnVuY3Rpb24gZ2V0UHJvY2Vzc0VudigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ID8gcHJvY2Vzcy5lbnYgOiB7fTtcbn07XG5cbmZ1bmN0aW9uIF9hcnJheV9saWtlX3RvX2FycmF5JDIoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKylhcnIyW2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX2FycmF5X3dpdGhvdXRfaG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5JDIoYXJyKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc19jYWxsX2NoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZV9jbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2RlZmluZV9wcm9wZXJ0eSQyKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVfdG9fYXJyYXkkMShpdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5mdW5jdGlvbiBfbm9uX2l0ZXJhYmxlX3NwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3RvX2NvbnN1bWFibGVfYXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIF9hcnJheV93aXRob3V0X2hvbGVzKGFycikgfHwgX2l0ZXJhYmxlX3RvX2FycmF5JDEoYXJyKSB8fCBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkkMihhcnIpIHx8IF9ub25faXRlcmFibGVfc3ByZWFkKCk7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkkMihvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlfbGlrZV90b19hcnJheSQyKG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlfbGlrZV90b19hcnJheSQyKG8sIG1pbkxlbik7XG59XG5mdW5jdGlvbiBzYWZlVG9TdHJpbmcoaW5mbykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbmZvLCBudWxsLCAyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG52YXIgREVCVUdfTE9HID0gJ1sgRkVERVJBVElPTiBERUJVRyBdJztcbmZ1bmN0aW9uIHNhZmVHZXRMb2NhbFN0b3JhZ2VJdGVtKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oQlJPV1NFUl9MT0dfS0VZKSA9PT0gQlJPV1NFUl9MT0dfVkFMVUU7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxudmFyIExvZ2dlciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTG9nZ2VyKGlkZW50aWZpZXIpIHtcbiAgICAgICAgX2NsYXNzX2NhbGxfY2hlY2sodGhpcywgTG9nZ2VyKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSQyKHRoaXMsIFwiZW5hYmxlXCIsIGZhbHNlKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSQyKHRoaXMsIFwiaWRlbnRpZmllclwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyIHx8IERFQlVHX0xPRztcbiAgICAgICAgaWYgKGlzQnJvd3NlckVudigpICYmIHNhZmVHZXRMb2NhbFN0b3JhZ2VJdGVtKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlYnVnTW9kZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NyZWF0ZV9jbGFzcyhMb2dnZXIsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImluZm9cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZvKG1zZywgaW5mbykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnc1RvU3RyaW5nID0gc2FmZVRvU3RyaW5nKGluZm8pIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCcm93c2VyRW52KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIiVjIFwiLmNvbmNhdCh0aGlzLmlkZW50aWZpZXIsIFwiOiBcIikuY29uY2F0KG1zZywgXCIgXCIpLmNvbmNhdChhcmdzVG9TdHJpbmcpLCAnY29sb3I6IzMzMDBDQycpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdcXHgxYlszNG0lcycsIFwiXCIuY29uY2F0KHRoaXMuaWRlbnRpZmllciwgXCI6IFwiKS5jb25jYXQobXNnLCBcIiBcIikuY29uY2F0KGFyZ3NUb1N0cmluZyA/IFwiXFxuXCIuY29uY2F0KGFyZ3NUb1N0cmluZykgOiAnJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibG9nT3JpZ2luYWxJbmZvXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9nT3JpZ2luYWxJbmZvKCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jyb3dzZXJFbnYoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jb25zb2xlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiJWMgXCIuY29uY2F0KHRoaXMuaWRlbnRpZmllciwgXCI6IE9yaWdpbmFsSW5mb1wiKSwgJ2NvbG9yOiMzMzAwQ0MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfY29uc29sZSA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZSwgX3RvX2NvbnN1bWFibGVfYXJyYXkoYXJncykpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jb25zb2xlMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIiVjIFwiLmNvbmNhdCh0aGlzLmlkZW50aWZpZXIsIFwiOiBPcmlnaW5hbEluZm9cIiksICdjb2xvcjojMzMwMENDJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2NvbnNvbGUxID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlMSwgX3RvX2NvbnN1bWFibGVfYXJyYXkoYXJncykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIExvZ2dlcjtcbn0oKTtcblxuZnVuY3Rpb24gX2FycmF5X2xpa2VfdG9fYXJyYXkkMShhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKWFycjJbaV0gPSBhcnJbaV07XG4gICAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfYXJyYXlfd2l0aF9ob2xlcyQxKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVfdG9fYXJyYXkoaXRlcikge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlX3RvX2FycmF5X2xpbWl0JDEoYXJyLCBpKSB7XG4gICAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuICAgIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfcywgX2U7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKXtcbiAgICAgICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2QgPSB0cnVlO1xuICAgICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9hcnI7XG59XG5mdW5jdGlvbiBfbm9uX2l0ZXJhYmxlX3Jlc3QkMSgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfc2xpY2VkX3RvX2FycmF5JDEoYXJyLCBpKSB7XG4gICAgcmV0dXJuIF9hcnJheV93aXRoX2hvbGVzJDEoYXJyKSB8fCBfaXRlcmFibGVfdG9fYXJyYXlfbGltaXQkMShhcnIsIGkpIHx8IF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheSQxKGFyciwgaSkgfHwgX25vbl9pdGVyYWJsZV9yZXN0JDEoKTtcbn1cbmZ1bmN0aW9uIF90b19hcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5X3dpdGhfaG9sZXMkMShhcnIpIHx8IF9pdGVyYWJsZV90b19hcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheSQxKGFycikgfHwgX25vbl9pdGVyYWJsZV9yZXN0JDEoKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheSQxKG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5JDEobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5JDEobywgbWluTGVuKTtcbn1cbnZhciBMT0dfQ0FURUdPUlkgPSAnWyBGZWRlcmF0aW9uIFJ1bnRpbWUgXSc7XG4vLyBlbnRyeTogbmFtZTp2ZXJzaW9uICAgdmVyc2lvbiA6IDEuMC4wIHwgXjEuMi4zXG4vLyBlbnRyeTogbmFtZTplbnRyeSAgZW50cnk6ICBodHRwczovL2xvY2FsaG9zdDo5MDAwL2ZlZGVyYXRpb24tbWFuaWZlc3QuanNvblxudmFyIHBhcnNlRW50cnkgPSBmdW5jdGlvbihzdHIsIGRldlZlck9yVXJsKSB7XG4gICAgdmFyIHNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogU0VQQVJBVE9SO1xuICAgIHZhciBzdHJTcGxpdCA9IHN0ci5zcGxpdChzZXBhcmF0b3IpO1xuICAgIHZhciBkZXZWZXJzaW9uT3JVcmwgPSBnZXRQcm9jZXNzRW52KClbJ05PREVfRU5WJ10gPT09ICdkZXZlbG9wbWVudCcgJiYgZGV2VmVyT3JVcmw7XG4gICAgdmFyIGRlZmF1bHRWZXJzaW9uID0gJyonO1xuICAgIHZhciBpc0VudHJ5ID0gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gcy5zdGFydHNXaXRoKCdodHRwJykgfHwgcy5pbmNsdWRlcyhNQU5JRkVTVF9FWFQpO1xuICAgIH07XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHN0cmluZyBzdGFydHMgd2l0aCBhIHR5cGVcbiAgICBpZiAoc3RyU3BsaXQubGVuZ3RoID49IDIpIHtcbiAgICAgICAgdmFyIF9zdHJTcGxpdCA9IF90b19hcnJheShzdHJTcGxpdCksIG5hbWUgPSBfc3RyU3BsaXRbMF0sIHZlcnNpb25PckVudHJ5QXJyID0gX3N0clNwbGl0LnNsaWNlKDEpO1xuICAgICAgICB2YXIgdmVyc2lvbk9yRW50cnkgPSBkZXZWZXJzaW9uT3JVcmwgfHwgdmVyc2lvbk9yRW50cnlBcnIuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaXNFbnRyeSh2ZXJzaW9uT3JFbnRyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBlbnRyeTogdmVyc2lvbk9yRW50cnlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBcHBseSB2ZXJzaW9uIHJ1bGVcbiAgICAgICAgICAgIC8vIGRldlZlcnNpb25PclVybCA9PiBpbnB1dFZlcnNpb24gPT4gZGVmYXVsdFZlcnNpb25cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uT3JFbnRyeSB8fCBkZWZhdWx0VmVyc2lvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyU3BsaXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBfc3RyU3BsaXQxID0gX3NsaWNlZF90b19hcnJheSQxKHN0clNwbGl0LCAxKSwgbmFtZTEgPSBfc3RyU3BsaXQxWzBdO1xuICAgICAgICBpZiAoZGV2VmVyc2lvbk9yVXJsICYmIGlzRW50cnkoZGV2VmVyc2lvbk9yVXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lMSxcbiAgICAgICAgICAgICAgICBlbnRyeTogZGV2VmVyc2lvbk9yVXJsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lMSxcbiAgICAgICAgICAgIHZlcnNpb246IGRldlZlcnNpb25PclVybCB8fCBkZWZhdWx0VmVyc2lvblxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFwiSW52YWxpZCBlbnRyeSB2YWx1ZTogXCIuY29uY2F0KHN0cik7XG4gICAgfVxufTtcbnZhciBsb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG52YXIgY29tcG9zZUtleVdpdGhTZXBhcmF0b3IgPSAgZnVuY3Rpb24gY29tcG9zZUtleVdpdGhTZXBhcmF0b3IoKSB7XG4gICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKGZ1bmN0aW9uKHN1bSwgY3VyKSB7XG4gICAgICAgIGlmICghY3VyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3VtKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChzdW0pLmNvbmNhdChTRVBBUkFUT1IpLmNvbmNhdChjdXIpO1xuICAgIH0sICcnKTtcbn07XG52YXIgZW5jb2RlTmFtZSA9ICBmdW5jdGlvbiBlbmNvZGVOYW1lKG5hbWUpIHtcbiAgICB2YXIgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiAnJywgd2l0aEV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGV4dCA9IHdpdGhFeHQgPyAnLmpzJyA6ICcnO1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQocHJlZml4KS5jb25jYXQobmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoTmFtZVRyYW5zZm9ybVN5bWJvbC5BVCksICdnJyksIE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5BVF0pLnJlcGxhY2UobmV3IFJlZ0V4cChcIlwiLmNvbmNhdChOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTiksICdnJyksIE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU5dKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSCksICdnJyksIE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF0pKS5jb25jYXQoZXh0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn07XG52YXIgZGVjb2RlTmFtZSA9ICBmdW5jdGlvbiBkZWNvZGVOYW1lKG5hbWUsIHByZWZpeCwgd2l0aEV4dCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBkZWNvZGVkTmFtZSA9IG5hbWU7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICghZGVjb2RlZE5hbWUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZWROYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZE5hbWUgPSBkZWNvZGVkTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAocHJlZml4LCAnZycpLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZE5hbWUgPSBkZWNvZGVkTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXSksICdnJyksIEVuY29kZWROYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5BVF1dKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXSksICdnJyksIEVuY29kZWROYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF1dKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTl0pLCAnZycpLCBFbmNvZGVkTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOXV0pO1xuICAgICAgICBpZiAod2l0aEV4dCkge1xuICAgICAgICAgICAgZGVjb2RlZE5hbWUgPSBkZWNvZGVkTmFtZS5yZXBsYWNlKCcuanMnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29kZWROYW1lO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcbnZhciBnZW5lcmF0ZUV4cG9zZUZpbGVuYW1lID0gIGZ1bmN0aW9uKGV4cG9zZU5hbWUsIHdpdGhFeHQpIHtcbiAgICBpZiAoIWV4cG9zZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgZXhwb3NlID0gZXhwb3NlTmFtZTtcbiAgICBpZiAoZXhwb3NlID09PSAnLicpIHtcbiAgICAgICAgZXhwb3NlID0gJ2RlZmF1bHRfZXhwb3J0JztcbiAgICB9XG4gICAgaWYgKGV4cG9zZS5zdGFydHNXaXRoKCcuLycpKSB7XG4gICAgICAgIGV4cG9zZSA9IGV4cG9zZS5yZXBsYWNlKCcuLycsICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZU5hbWUoZXhwb3NlLCAnX19mZWRlcmF0aW9uX2V4cG9zZV8nLCB3aXRoRXh0KTtcbn07XG52YXIgZ2VuZXJhdGVTaGFyZUZpbGVuYW1lID0gIGZ1bmN0aW9uKHBrZ05hbWUsIHdpdGhFeHQpIHtcbiAgICBpZiAoIXBrZ05hbWUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlTmFtZShwa2dOYW1lLCAnX19mZWRlcmF0aW9uX3NoYXJlZF8nLCB3aXRoRXh0KTtcbn07XG52YXIgZ2V0UmVzb3VyY2VVcmwgPSBmdW5jdGlvbihtb2R1bGUsIHNvdXJjZVVybCkge1xuICAgIGlmICgnZ2V0UHVibGljUGF0aCcgaW4gbW9kdWxlKSB7XG4gICAgICAgIHZhciBwdWJsaWNQYXRoID0gbmV3IEZ1bmN0aW9uKG1vZHVsZS5nZXRQdWJsaWNQYXRoKSgpO1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQocHVibGljUGF0aCkuY29uY2F0KHNvdXJjZVVybCk7XG4gICAgfSBlbHNlIGlmICgncHVibGljUGF0aCcgaW4gbW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChtb2R1bGUucHVibGljUGF0aCkuY29uY2F0KHNvdXJjZVVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDYW4gbm90IGdldCByZXNvdXJjZSB1cmwsIGlmIGluIGRlYnVnIG1vZGUsIHBsZWFzZSBpZ25vcmUnLCBtb2R1bGUsIHNvdXJjZVVybCk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbnZhciBhc3NlcnQgPSBmdW5jdGlvbihjb25kaXRpb24sIG1zZykge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIGVycm9yKG1zZyk7XG4gICAgfVxufTtcbnZhciBlcnJvciA9IGZ1bmN0aW9uKG1zZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChMT0dfQ0FURUdPUlksIFwiOiBcIikuY29uY2F0KG1zZykpO1xufTtcbnZhciB3YXJuID0gZnVuY3Rpb24obXNnKSB7XG4gICAgY29uc29sZS53YXJuKFwiXCIuY29uY2F0KExPR19DQVRFR09SWSwgXCI6IFwiKS5jb25jYXQobXNnKSk7XG59O1xuXG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5JDEob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9vYmplY3Rfc3ByZWFkJDEodGFyZ2V0KSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfZGVmaW5lX3Byb3BlcnR5JDEodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICAgIGlmIChlbnVtZXJhYmxlT25seSkge1xuICAgICAgICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3Rfc3ByZWFkX3Byb3BzKHRhcmdldCwgc291cmNlKSB7XG4gICAgc291cmNlID0gc291cmNlICE9IG51bGwgPyBzb3VyY2UgOiB7fTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxudmFyIHNpbXBsZUpvaW5SZW1vdGVFbnRyeSA9IGZ1bmN0aW9uKHJQYXRoLCByTmFtZSkge1xuICAgIGlmICghclBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHJOYW1lO1xuICAgIH1cbiAgICB2YXIgdHJhbnNmb3JtUGF0aCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBpZiAoc3RyID09PSAnLicpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgnLi8nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIHZhciBzdHJXaXRob3V0U2xhc2ggPSBzdHIuc2xpY2UoMSk7XG4gICAgICAgICAgICBpZiAoc3RyV2l0aG91dFNsYXNoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyV2l0aG91dFNsYXNoLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJXaXRob3V0U2xhc2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuICAgIHZhciB0cmFuc2Zvcm1lZFBhdGggPSB0cmFuc2Zvcm1QYXRoKHJQYXRoKTtcbiAgICBpZiAoIXRyYW5zZm9ybWVkUGF0aCkge1xuICAgICAgICByZXR1cm4gck5hbWU7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1lZFBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodHJhbnNmb3JtZWRQYXRoKS5jb25jYXQock5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIi5jb25jYXQodHJhbnNmb3JtZWRQYXRoLCBcIi9cIikuY29uY2F0KHJOYW1lKTtcbn07XG5mdW5jdGlvbiBpbmZlckF1dG9QdWJsaWNQYXRoKHVybCkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvIy4qJC8sICcnKS5yZXBsYWNlKC9cXD8uKiQvLCAnJykucmVwbGFjZSgvXFwvW15cXC9dKyQvLCAnLycpO1xufVxuLy8gUHJpb3JpdHk6IG92ZXJyaWRlcyA+IHJlbW90ZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGluZXMtcGVyLWZ1bmN0aW9uXG5mdW5jdGlvbiBnZW5lcmF0ZVNuYXBzaG90RnJvbU1hbmlmZXN0KG1hbmlmZXN0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfbWFuaWZlc3RfbWV0YURhdGEsIF9tYW5pZmVzdF9tZXRhRGF0YTE7XG4gICAgdmFyIF9vcHRpb25zX3JlbW90ZXMgPSBvcHRpb25zLnJlbW90ZXMsIHJlbW90ZXMgPSBfb3B0aW9uc19yZW1vdGVzID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX3JlbW90ZXMsIF9vcHRpb25zX292ZXJyaWRlcyA9IG9wdGlvbnMub3ZlcnJpZGVzLCBvdmVycmlkZXMgPSBfb3B0aW9uc19vdmVycmlkZXMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnNfb3ZlcnJpZGVzLCB2ZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uO1xuICAgIHZhciByZW1vdGVTbmFwc2hvdDtcbiAgICB2YXIgZ2V0UHVibGljUGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoJ3B1YmxpY1BhdGgnIGluIG1hbmlmZXN0Lm1ldGFEYXRhKSB7XG4gICAgICAgICAgICBpZiAobWFuaWZlc3QubWV0YURhdGEucHVibGljUGF0aCA9PT0gJ2F1dG8nICYmIHZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAvLyB1c2Ugc2FtZSBpbXBsZW1lbnRhdGlvbiBhcyBwdWJsaWNQYXRoIGF1dG8gcnVudGltZSBtb2R1bGUgaW1wbGVtZW50c1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmZlckF1dG9QdWJsaWNQYXRoKHZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hbmlmZXN0Lm1ldGFEYXRhLnB1YmxpY1BhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWFuaWZlc3QubWV0YURhdGEuZ2V0UHVibGljUGF0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG92ZXJyaWRlc0tleXMgPSBPYmplY3Qua2V5cyhvdmVycmlkZXMpO1xuICAgIHZhciByZW1vdGVzSW5mbyA9IHt9O1xuICAgIC8vIElmIHJlbW90ZXMgYXJlIG5vdCBwcm92aWRlZCwgb25seSB0aGUgcmVtb3RlcyBpbiB0aGUgbWFuaWZlc3Qgd2lsbCBiZSByZWFkXG4gICAgaWYgKCFPYmplY3Qua2V5cyhyZW1vdGVzKS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIF9tYW5pZmVzdF9yZW1vdGVzO1xuICAgICAgICByZW1vdGVzSW5mbyA9ICgoX21hbmlmZXN0X3JlbW90ZXMgPSBtYW5pZmVzdC5yZW1vdGVzKSA9PT0gbnVsbCB8fCBfbWFuaWZlc3RfcmVtb3RlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hbmlmZXN0X3JlbW90ZXMucmVkdWNlKGZ1bmN0aW9uKHJlcywgbmV4dCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWRWZXJzaW9uO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBuZXh0LmZlZGVyYXRpb25Db250YWluZXJOYW1lO1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGVzIGhhdmUgaGlnaGVyIHByaW9yaXR5XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVzS2V5cy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRWZXJzaW9uID0gb3ZlcnJpZGVzW25hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoJ3ZlcnNpb24nIGluIG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb24gPSBuZXh0LnZlcnNpb247XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb24gPSBuZXh0LmVudHJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbjogbWF0Y2hlZFZlcnNpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCB7fSkpIHx8IHt9O1xuICAgIH1cbiAgICAvLyBJZiByZW1vdGVzIChkZXBsb3kgc2NlbmFyaW8pIGFyZSBzcGVjaWZpZWQsIHRoZXkgbmVlZCB0byBiZSB0cmF2ZXJzZWQgYWdhaW5cbiAgICBPYmplY3Qua2V5cyhyZW1vdGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gcmVtb3Rlc0luZm9ba2V5XSA9IHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlcyB3aWxsIG92ZXJyaWRlIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb246IG92ZXJyaWRlc0tleXMuaW5jbHVkZXMoa2V5KSA/IG92ZXJyaWRlc1trZXldIDogcmVtb3Rlc1trZXldXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIF9tYW5pZmVzdF9tZXRhRGF0YTIgPSBtYW5pZmVzdC5tZXRhRGF0YSwgX21hbmlmZXN0X21ldGFEYXRhX3JlbW90ZUVudHJ5ID0gX21hbmlmZXN0X21ldGFEYXRhMi5yZW1vdGVFbnRyeSwgcmVtb3RlRW50cnlQYXRoID0gX21hbmlmZXN0X21ldGFEYXRhX3JlbW90ZUVudHJ5LnBhdGgsIHJlbW90ZUVudHJ5TmFtZSA9IF9tYW5pZmVzdF9tZXRhRGF0YV9yZW1vdGVFbnRyeS5uYW1lLCByZW1vdGVFbnRyeVR5cGUgPSBfbWFuaWZlc3RfbWV0YURhdGFfcmVtb3RlRW50cnkudHlwZSwgcmVtb3RlVHlwZXMgPSBfbWFuaWZlc3RfbWV0YURhdGEyLnR5cGVzLCBidWlsZFZlcnNpb24gPSBfbWFuaWZlc3RfbWV0YURhdGEyLmJ1aWxkSW5mby5idWlsZFZlcnNpb24sIGdsb2JhbE5hbWUgPSBfbWFuaWZlc3RfbWV0YURhdGEyLmdsb2JhbE5hbWU7XG4gICAgdmFyIGV4cG9zZXMgPSBtYW5pZmVzdC5leHBvc2VzO1xuICAgIHZhciBiYXNpY1JlbW90ZVNuYXBzaG90ID0ge1xuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uID8gdmVyc2lvbiA6ICcnLFxuICAgICAgICBidWlsZFZlcnNpb246IGJ1aWxkVmVyc2lvbixcbiAgICAgICAgZ2xvYmFsTmFtZTogZ2xvYmFsTmFtZSxcbiAgICAgICAgcmVtb3RlRW50cnk6IHNpbXBsZUpvaW5SZW1vdGVFbnRyeShyZW1vdGVFbnRyeVBhdGgsIHJlbW90ZUVudHJ5TmFtZSksXG4gICAgICAgIHJlbW90ZUVudHJ5VHlwZTogcmVtb3RlRW50cnlUeXBlLFxuICAgICAgICByZW1vdGVUeXBlczogc2ltcGxlSm9pblJlbW90ZUVudHJ5KHJlbW90ZVR5cGVzLnBhdGgsIHJlbW90ZVR5cGVzLm5hbWUpLFxuICAgICAgICByZW1vdGVUeXBlc1ppcDogcmVtb3RlVHlwZXMuemlwIHx8ICcnLFxuICAgICAgICByZW1vdGVUeXBlc0FQSTogcmVtb3RlVHlwZXMuYXBpIHx8ICcnLFxuICAgICAgICByZW1vdGVzSW5mbzogcmVtb3Rlc0luZm8sXG4gICAgICAgIHNoYXJlZDogbWFuaWZlc3QgPT09IG51bGwgfHwgbWFuaWZlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hbmlmZXN0LnNoYXJlZC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhc3NldHM6IGl0ZW0uYXNzZXRzLFxuICAgICAgICAgICAgICAgIHNoYXJlZE5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBpdGVtLnZlcnNpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICBtb2R1bGVzOiBleHBvc2VzID09PSBudWxsIHx8IGV4cG9zZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4cG9zZXMubWFwKGZ1bmN0aW9uKGV4cG9zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBleHBvc2UubmFtZSxcbiAgICAgICAgICAgICAgICBtb2R1bGVQYXRoOiBleHBvc2UucGF0aCxcbiAgICAgICAgICAgICAgICBhc3NldHM6IGV4cG9zZS5hc3NldHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgfTtcbiAgICBpZiAoKF9tYW5pZmVzdF9tZXRhRGF0YSA9IG1hbmlmZXN0Lm1ldGFEYXRhKSA9PT0gbnVsbCB8fCBfbWFuaWZlc3RfbWV0YURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9tZXRhRGF0YS5wcmVmZXRjaEludGVyZmFjZSkge1xuICAgICAgICB2YXIgcHJlZmV0Y2hJbnRlcmZhY2UgPSBtYW5pZmVzdC5tZXRhRGF0YS5wcmVmZXRjaEludGVyZmFjZTtcbiAgICAgICAgYmFzaWNSZW1vdGVTbmFwc2hvdCA9IF9vYmplY3Rfc3ByZWFkX3Byb3BzKF9vYmplY3Rfc3ByZWFkJDEoe30sIGJhc2ljUmVtb3RlU25hcHNob3QpLCB7XG4gICAgICAgICAgICBwcmVmZXRjaEludGVyZmFjZTogcHJlZmV0Y2hJbnRlcmZhY2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgoX21hbmlmZXN0X21ldGFEYXRhMSA9IG1hbmlmZXN0Lm1ldGFEYXRhKSA9PT0gbnVsbCB8fCBfbWFuaWZlc3RfbWV0YURhdGExID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWFuaWZlc3RfbWV0YURhdGExLnByZWZldGNoRW50cnkpIHtcbiAgICAgICAgdmFyIF9tYW5pZmVzdF9tZXRhRGF0YV9wcmVmZXRjaEVudHJ5ID0gbWFuaWZlc3QubWV0YURhdGEucHJlZmV0Y2hFbnRyeSwgcGF0aCA9IF9tYW5pZmVzdF9tZXRhRGF0YV9wcmVmZXRjaEVudHJ5LnBhdGgsIG5hbWUgPSBfbWFuaWZlc3RfbWV0YURhdGFfcHJlZmV0Y2hFbnRyeS5uYW1lLCB0eXBlID0gX21hbmlmZXN0X21ldGFEYXRhX3ByZWZldGNoRW50cnkudHlwZTtcbiAgICAgICAgYmFzaWNSZW1vdGVTbmFwc2hvdCA9IF9vYmplY3Rfc3ByZWFkX3Byb3BzKF9vYmplY3Rfc3ByZWFkJDEoe30sIGJhc2ljUmVtb3RlU25hcHNob3QpLCB7XG4gICAgICAgICAgICBwcmVmZXRjaEVudHJ5OiBzaW1wbGVKb2luUmVtb3RlRW50cnkocGF0aCwgbmFtZSksXG4gICAgICAgICAgICBwcmVmZXRjaEVudHJ5VHlwZTogdHlwZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCdwdWJsaWNQYXRoJyBpbiBtYW5pZmVzdC5tZXRhRGF0YSkge1xuICAgICAgICByZW1vdGVTbmFwc2hvdCA9IF9vYmplY3Rfc3ByZWFkX3Byb3BzKF9vYmplY3Rfc3ByZWFkJDEoe30sIGJhc2ljUmVtb3RlU25hcHNob3QpLCB7XG4gICAgICAgICAgICBwdWJsaWNQYXRoOiBnZXRQdWJsaWNQYXRoKClcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3RlU25hcHNob3QgPSBfb2JqZWN0X3NwcmVhZF9wcm9wcyhfb2JqZWN0X3NwcmVhZCQxKHt9LCBiYXNpY1JlbW90ZVNuYXBzaG90KSwge1xuICAgICAgICAgICAgZ2V0UHVibGljUGF0aDogZ2V0UHVibGljUGF0aCgpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVtb3RlU25hcHNob3Q7XG59XG5mdW5jdGlvbiBpc01hbmlmZXN0UHJvdmlkZXIobW9kdWxlSW5mbykge1xuICAgIGlmICgncmVtb3RlRW50cnknIGluIG1vZHVsZUluZm8gJiYgbW9kdWxlSW5mby5yZW1vdGVFbnRyeS5pbmNsdWRlcyhNQU5JRkVTVF9FWFQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcCQxKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9hc3luY190b19nZW5lcmF0b3IkMShmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcCQxKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcCQxKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gX2luc3RhbmNlb2YobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAocmlnaHQgIT0gbnVsbCAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIHJpZ2h0W1N5bWJvbC5oYXNJbnN0YW5jZV0pIHtcbiAgICAgICAgcmV0dXJuICEhcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXShsZWZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGVmdCBpbnN0YW5jZW9mIHJpZ2h0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIF90c19nZW5lcmF0b3IkMSh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIGYsIHksIHQsIGcsIF8gPSB7XG4gICAgICAgIGxhYmVsOiAwLFxuICAgICAgICBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTtcbiAgICAgICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgICB9LFxuICAgICAgICB0cnlzOiBbXSxcbiAgICAgICAgb3BzOiBbXVxuICAgIH07XG4gICAgcmV0dXJuIGcgPSB7XG4gICAgICAgIG5leHQ6IHZlcmIoMCksXG4gICAgICAgIFwidGhyb3dcIjogdmVyYigxKSxcbiAgICAgICAgXCJyZXR1cm5cIjogdmVyYigyKVxuICAgIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoW1xuICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgdlxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZShfKXRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW1xuICAgICAgICAgICAgICAgIG9wWzBdICYgMixcbiAgICAgICAgICAgICAgICB0LnZhbHVlXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc3dpdGNoKG9wWzBdKXtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICBvcCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvcCA9IFtcbiAgICAgICAgICAgICAgICA2LFxuICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsXG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHNhZmVXcmFwcGVyKGNhbGxiYWNrLCBkaXNhYmxlV2Fybikge1xuICAgIHJldHVybiBfc2FmZVdyYXBwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9zYWZlV3JhcHBlcigpIHtcbiAgICBfc2FmZVdyYXBwZXIgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yJDEoZnVuY3Rpb24oY2FsbGJhY2ssIGRpc2FibGVXYXJuKSB7XG4gICAgICAgIHZhciByZXMsIGU7XG4gICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yJDEodGhpcywgZnVuY3Rpb24oX3N0YXRlKSB7XG4gICAgICAgICAgICBzd2l0Y2goX3N0YXRlLmxhYmVsKXtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9zdGF0ZS50cnlzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICAzXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBlID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgIWRpc2FibGVXYXJuICYmIHdhcm4oZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3NhZmVXcmFwcGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBpc1N0YXRpY1Jlc291cmNlc0VxdWFsKHVybDEsIHVybDIpIHtcbiAgICB2YXIgUkVHX0VYUCA9IC9eKGh0dHBzPzopP1xcL1xcLy9pO1xuICAgIC8vIFRyYW5zZm9ybSB1cmwxIGFuZCB1cmwyIGludG8gcmVsYXRpdmUgcGF0aHNcbiAgICB2YXIgcmVsYXRpdmVVcmwxID0gdXJsMS5yZXBsYWNlKFJFR19FWFAsICcnKS5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgIHZhciByZWxhdGl2ZVVybDIgPSB1cmwyLnJlcGxhY2UoUkVHX0VYUCwgJycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJlbGF0aXZlIHBhdGhzIGFyZSBpZGVudGljYWxcbiAgICByZXR1cm4gcmVsYXRpdmVVcmwxID09PSByZWxhdGl2ZVVybDI7XG59XG5mdW5jdGlvbiBjcmVhdGVTY3JpcHQodXJsLCBjYiwgYXR0cnMsIGNyZWF0ZVNjcmlwdEhvb2spIHtcbiAgICAvLyBSZXRyaWV2ZSB0aGUgZXhpc3Rpbmcgc2NyaXB0IGVsZW1lbnQgYnkgaXRzIHNyYyBhdHRyaWJ1dGVcbiAgICB2YXIgc2NyaXB0ID0gbnVsbDtcbiAgICB2YXIgbmVlZEF0dGFjaCA9IHRydWU7XG4gICAgdmFyIHRpbWVvdXQgPSAyMDAwMDtcbiAgICB2YXIgdGltZW91dElkO1xuICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHMgPSBzY3JpcHRzW2ldO1xuICAgICAgICB2YXIgc2NyaXB0U3JjID0gcy5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICBpZiAoc2NyaXB0U3JjICYmIGlzU3RhdGljUmVzb3VyY2VzRXF1YWwoc2NyaXB0U3JjLCB1cmwpKSB7XG4gICAgICAgICAgICBzY3JpcHQgPSBzO1xuICAgICAgICAgICAgbmVlZEF0dGFjaCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzY3JpcHQpIHtcbiAgICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgIGlmIChjcmVhdGVTY3JpcHRIb29rKSB7XG4gICAgICAgICAgICB2YXIgY3JlYXRlU2NyaXB0UmVzID0gY3JlYXRlU2NyaXB0SG9vayh1cmwpO1xuICAgICAgICAgICAgaWYgKF9pbnN0YW5jZW9mKGNyZWF0ZVNjcmlwdFJlcywgSFRNTFNjcmlwdEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gY3JlYXRlU2NyaXB0UmVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY3JlYXRlU2NyaXB0UmVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChjcmVhdGVTY3JpcHRSZXMuc2NyaXB0KSBzY3JpcHQgPSBjcmVhdGVTY3JpcHRSZXMuc2NyaXB0O1xuICAgICAgICAgICAgICAgIGlmIChjcmVhdGVTY3JpcHRSZXMudGltZW91dCkgdGltZW91dCA9IGNyZWF0ZVNjcmlwdFJlcy50aW1lb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRycykge1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdhc3luYycgfHwgbmFtZSA9PT0gJ2RlZmVyJykge1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHRbbmFtZV0gPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgb25TY3JpcHRDb21wbGV0ZSA9IGZ1bmN0aW9uKHByZXYsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZXZlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzIGluIElFLlxuICAgICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgICAgICBzY3JpcHQub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICBzY3JpcHQub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIHNhZmVXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIChzY3JpcHQgPT09IG51bGwgfHwgc2NyaXB0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY3JpcHQucGFyZW50Tm9kZSkgJiYgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBwcmV2KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2IoKTtcbiAgICB9O1xuICAgIHNjcmlwdC5vbmVycm9yID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmVycm9yKTtcbiAgICBzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmxvYWQpO1xuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9uU2NyaXB0Q29tcGxldGUobnVsbCwgbmV3IEVycm9yKCdSZW1vdGUgc2NyaXB0IFwiJy5jb25jYXQodXJsLCAnXCIgdGltZS1vdXRlZC4nKSkpO1xuICAgIH0sIHRpbWVvdXQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNjcmlwdDogc2NyaXB0LFxuICAgICAgICBuZWVkQXR0YWNoOiBuZWVkQXR0YWNoXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxpbmsodXJsLCBjYikge1xuICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDoge30sIGNyZWF0ZUxpbmtIb29rID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB2b2lkIDA7XG4gICAgLy8gPGxpbmsgcmVsPVwicHJlbG9hZFwiIGhyZWY9XCJzY3JpcHQuanNcIiBhcz1cInNjcmlwdFwiPlxuICAgIC8vIFJldHJpZXZlIHRoZSBleGlzdGluZyBzY3JpcHQgZWxlbWVudCBieSBpdHMgc3JjIGF0dHJpYnV0ZVxuICAgIHZhciBsaW5rID0gbnVsbDtcbiAgICB2YXIgbmVlZEF0dGFjaCA9IHRydWU7XG4gICAgdmFyIGxpbmtzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpbmsnKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgbCA9IGxpbmtzW2ldO1xuICAgICAgICB2YXIgbGlua0hyZWYgPSBsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICB2YXIgbGlua1JlZiA9IGwuZ2V0QXR0cmlidXRlKCdyZWYnKTtcbiAgICAgICAgaWYgKGxpbmtIcmVmICYmIGlzU3RhdGljUmVzb3VyY2VzRXF1YWwobGlua0hyZWYsIHVybCkgJiYgbGlua1JlZiA9PT0gYXR0cnNbJ3JlZiddKSB7XG4gICAgICAgICAgICBsaW5rID0gbDtcbiAgICAgICAgICAgIG5lZWRBdHRhY2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbGluaykge1xuICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XG4gICAgICAgIGlmIChjcmVhdGVMaW5rSG9vaykge1xuICAgICAgICAgICAgdmFyIGNyZWF0ZUxpbmtSZXMgPSBjcmVhdGVMaW5rSG9vayh1cmwpO1xuICAgICAgICAgICAgaWYgKF9pbnN0YW5jZW9mKGNyZWF0ZUxpbmtSZXMsIEhUTUxMaW5rRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBsaW5rID0gY3JlYXRlTGlua1JlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgb25MaW5rQ29tcGxldGUgPSBmdW5jdGlvbihwcmV2LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGV2ZW50KSB7XG4gICAgICAgIC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzIGluIElFLlxuICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgbGluay5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIGxpbmsub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIHNhZmVXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIChsaW5rID09PSBudWxsIHx8IGxpbmsgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmsucGFyZW50Tm9kZSkgJiYgbGluay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHByZXYoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYigpO1xuICAgIH07XG4gICAgbGluay5vbmVycm9yID0gb25MaW5rQ29tcGxldGUuYmluZChudWxsLCBsaW5rLm9uZXJyb3IpO1xuICAgIGxpbmsub25sb2FkID0gb25MaW5rQ29tcGxldGUuYmluZChudWxsLCBsaW5rLm9ubG9hZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluazogbGluayxcbiAgICAgICAgbmVlZEF0dGFjaDogbmVlZEF0dGFjaFxuICAgIH07XG59XG5mdW5jdGlvbiBsb2FkU2NyaXB0KHVybCwgaW5mbykge1xuICAgIHZhciBhdHRycyA9IGluZm8uYXR0cnMsIGNyZWF0ZVNjcmlwdEhvb2sgPSBpbmZvLmNyZWF0ZVNjcmlwdEhvb2s7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIF9yZWplY3QpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVTY3JpcHQgPSBjcmVhdGVTY3JpcHQodXJsLCByZXNvbHZlLCBhdHRycywgY3JlYXRlU2NyaXB0SG9vayksIHNjcmlwdCA9IF9jcmVhdGVTY3JpcHQuc2NyaXB0LCBuZWVkQXR0YWNoID0gX2NyZWF0ZVNjcmlwdC5uZWVkQXR0YWNoO1xuICAgICAgICBuZWVkQXR0YWNoICYmIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2FycmF5X2xpa2VfdG9fYXJyYXkoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKylhcnIyW2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX2FycmF5X3dpdGhfaG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgICB9XG59XG5mdW5jdGlvbiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZV90b19hcnJheV9saW1pdChhcnIsIGkpIHtcbiAgICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG4gICAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9zLCBfZTtcbiAgICB0cnkge1xuICAgICAgICBmb3IoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpe1xuICAgICAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZCA9IHRydWU7XG4gICAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2Fycjtcbn1cbmZ1bmN0aW9uIF9ub25faXRlcmFibGVfcmVzdCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfc2xpY2VkX3RvX2FycmF5KGFyciwgaSkge1xuICAgIHJldHVybiBfYXJyYXlfd2l0aF9ob2xlcyhhcnIpIHx8IF9pdGVyYWJsZV90b19hcnJheV9saW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheShhcnIsIGkpIHx8IF9ub25faXRlcmFibGVfcmVzdCgpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlfbGlrZV90b19hcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX3RzX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIGYsIHksIHQsIGcsIF8gPSB7XG4gICAgICAgIGxhYmVsOiAwLFxuICAgICAgICBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTtcbiAgICAgICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgICB9LFxuICAgICAgICB0cnlzOiBbXSxcbiAgICAgICAgb3BzOiBbXVxuICAgIH07XG4gICAgcmV0dXJuIGcgPSB7XG4gICAgICAgIG5leHQ6IHZlcmIoMCksXG4gICAgICAgIFwidGhyb3dcIjogdmVyYigxKSxcbiAgICAgICAgXCJyZXR1cm5cIjogdmVyYigyKVxuICAgIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoW1xuICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgdlxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZShfKXRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW1xuICAgICAgICAgICAgICAgIG9wWzBdICYgMixcbiAgICAgICAgICAgICAgICB0LnZhbHVlXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc3dpdGNoKG9wWzBdKXtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICBvcCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvcCA9IFtcbiAgICAgICAgICAgICAgICA2LFxuICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsXG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gaW1wb3J0Tm9kZU1vZHVsZShuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW1wb3J0IHNwZWNpZmllciBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICB2YXIgaW1wb3J0TW9kdWxlID0gbmV3IEZ1bmN0aW9uKCduYW1lJywgXCJyZXR1cm4gaW1wb3J0KG5hbWUpXCIpO1xuICAgIHJldHVybiBpbXBvcnRNb2R1bGUobmFtZSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlcy5kZWZhdWx0O1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbXBvcnRpbmcgbW9kdWxlIFwiLmNvbmNhdChuYW1lLCBcIjpcIiksIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTY3JpcHROb2RlKHVybCwgY2IsIGF0dHJzLCBjcmVhdGVTY3JpcHRIb29rKSB7XG4gICAgaWYgKGNyZWF0ZVNjcmlwdEhvb2spIHtcbiAgICAgICAgdmFyIGhvb2tSZXN1bHQgPSBjcmVhdGVTY3JpcHRIb29rKHVybCk7XG4gICAgICAgIGlmIChob29rUmVzdWx0ICYmIHR5cGVvZiBob29rUmVzdWx0ID09PSAnb2JqZWN0JyAmJiAndXJsJyBpbiBob29rUmVzdWx0KSB7XG4gICAgICAgICAgICB1cmwgPSBob29rUmVzdWx0LnVybDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgdXJsT2JqO1xuICAgIHRyeSB7XG4gICAgICAgIHVybE9iaiA9IG5ldyBVUkwodXJsKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvbnN0cnVjdGluZyBVUkw6JywgZSk7XG4gICAgICAgIGNiKG5ldyBFcnJvcihcIkludmFsaWQgVVJMOiBcIi5jb25jYXQoZSkpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZ2V0RmV0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGZldGNoTW9kdWxlO1xuICAgICAgICAgICAgcmV0dXJuIF90c19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoKF9zdGF0ZS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnROb2RlTW9kdWxlKCdub2RlLWZldGNoJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoTW9kdWxlID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmZXRjaE1vZHVsZSA9PT0gbnVsbCB8fCBmZXRjaE1vZHVsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hNb2R1bGUuZGVmYXVsdCkgfHwgZmV0Y2hNb2R1bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGdldEZldGNoKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9KCk7XG4gICAgY29uc29sZS5sb2coJ2ZldGNoaW5nJywgdXJsT2JqLmhyZWYpO1xuICAgIGdldEZldGNoKCkudGhlbihmdW5jdGlvbihmKSB7XG4gICAgICAgIGYodXJsT2JqLmhyZWYpLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWYsIHBhdGgsIHZtLCBzY3JpcHRDb250ZXh0LCB1cmxEaXJuYW1lLCBmaWxlbmFtZSwgc2NyaXB0LCBleHBvcnRlZEludGVyZmFjZSwgY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goX3N0YXRlLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnROb2RlTW9kdWxlKCdwYXRoJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnROb2RlTW9kdWxlKCd2bScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX3NsaWNlZF90b19hcnJheS5hcHBseSh2b2lkIDAsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCBwYXRoID0gX3JlZlswXSwgdm0gPSBfcmVmWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdENvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybERpcm5hbWUgPSB1cmxPYmoucGF0aG5hbWUuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuam9pbignLycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gcGF0aC5iYXNlbmFtZSh1cmxPYmoucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IG5ldyB2bS5TY3JpcHQoXCIoZnVuY3Rpb24oZXhwb3J0cywgbW9kdWxlLCByZXF1aXJlLCBfX2Rpcm5hbWUsIF9fZmlsZW5hbWUpIHtcIi5jb25jYXQoZGF0YSwgXCJcXG59KVwiKSwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQucnVuSW5UaGlzQ29udGV4dCgpKHNjcmlwdENvbnRleHQuZXhwb3J0cywgc2NyaXB0Q29udGV4dC5tb2R1bGUsIGV2YWwoJ3JlcXVpcmUnKSwgdXJsRGlybmFtZSwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZEludGVyZmFjZSA9IHNjcmlwdENvbnRleHQubW9kdWxlLmV4cG9ydHMgfHwgc2NyaXB0Q29udGV4dC5leHBvcnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMgJiYgZXhwb3J0ZWRJbnRlcmZhY2UgJiYgYXR0cnNbJ2dsb2JhbE5hbWUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gZXhwb3J0ZWRJbnRlcmZhY2VbYXR0cnNbJ2dsb2JhbE5hbWUnXV0gfHwgZXhwb3J0ZWRJbnRlcmZhY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYih1bmRlZmluZWQsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IodW5kZWZpbmVkLCBleHBvcnRlZEludGVyZmFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdFcnJvciBydW5uaW5nIHNjcmlwdDonLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IobmV3IEVycm9yKFwiU2NyaXB0IGV4ZWN1dGlvbiBlcnJvcjogXCIuY29uY2F0KGUpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0oKSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzY3JpcHQ6JywgZXJyKTtcbiAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbG9hZFNjcmlwdE5vZGUodXJsLCBpbmZvKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBjcmVhdGVTY3JpcHROb2RlKHVybCwgZnVuY3Rpb24oZXJyb3IsIHNjcmlwdENvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfaW5mb19hdHRycywgX2luZm9fYXR0cnMxO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdGVFbnRyeUtleSA9IChpbmZvID09PSBudWxsIHx8IGluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfaW5mb19hdHRycyA9IGluZm8uYXR0cnMpID09PSBudWxsIHx8IF9pbmZvX2F0dHJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW5mb19hdHRyc1snZ2xvYmFsTmFtZSddKSB8fCBcIl9fRkVERVJBVElPTl9cIi5jb25jYXQoaW5mbyA9PT0gbnVsbCB8fCBpbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2luZm9fYXR0cnMxID0gaW5mby5hdHRycykgPT09IG51bGwgfHwgX2luZm9fYXR0cnMxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW5mb19hdHRyczFbJ25hbWUnXSwgXCI6Y3VzdG9tX19cIik7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5RXhwb3J0cyA9IGdsb2JhbFRoaXNbcmVtb3RlRW50cnlLZXldID0gc2NyaXB0Q29udGV4dDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGVudHJ5RXhwb3J0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGluZm8uYXR0cnMsIGluZm8uY3JlYXRlU2NyaXB0SG9vayk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVfcHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9vYmplY3Rfc3ByZWFkKHRhcmdldCkge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF90eXBlX29mKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59XG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb25zKGVuYWJsZURlZmF1bHQsIGRlZmF1bHRPcHRpb25zLCBrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdF9zcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHR5cGUgZm9yIGBcIi5jb25jYXQoa2V5LCBcImAsIGV4cGVjdCBib29sZWFuL3VuZGVmaW5lZC9vYmplY3QsIGdvdDogXCIpLmNvbmNhdCh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihvcHRpb25zKSkpO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IEJST1dTRVJfTE9HX0tFWSwgQlJPV1NFUl9MT0dfVkFMVUUsIEVuY29kZWROYW1lVHJhbnNmb3JtTWFwLCBGZWRlcmF0aW9uTW9kdWxlTWFuaWZlc3QsIExvZ2dlciwgTUFOSUZFU1RfRVhULCBNRk1vZHVsZVR5cGUsIE1PRFVMRV9ERVZUT09MX0lERU5USUZJRVIsIE1hbmlmZXN0RmlsZU5hbWUsIE5hbWVUcmFuc2Zvcm1NYXAsIE5hbWVUcmFuc2Zvcm1TeW1ib2wsIFNFUEFSQVRPUiwgU3RhdHNGaWxlTmFtZSwgYXNzZXJ0LCBjb21wb3NlS2V5V2l0aFNlcGFyYXRvciwgQ29udGFpbmVyUGx1Z2luIGFzIGNvbnRhaW5lclBsdWdpbiwgQ29udGFpbmVyUmVmZXJlbmNlUGx1Z2luIGFzIGNvbnRhaW5lclJlZmVyZW5jZVBsdWdpbiwgY3JlYXRlTGluaywgY3JlYXRlU2NyaXB0LCBjcmVhdGVTY3JpcHROb2RlLCBkZWNvZGVOYW1lLCBlbmNvZGVOYW1lLCBlcnJvciwgZ2VuZXJhdGVFeHBvc2VGaWxlbmFtZSwgZ2VuZXJhdGVTaGFyZUZpbGVuYW1lLCBnZW5lcmF0ZVNuYXBzaG90RnJvbU1hbmlmZXN0LCBnZXRQcm9jZXNzRW52LCBnZXRSZXNvdXJjZVVybCwgaW5mZXJBdXRvUHVibGljUGF0aCwgaXNCcm93c2VyRW52LCBpc0RlYnVnTW9kZSwgaXNNYW5pZmVzdFByb3ZpZGVyLCBpc1N0YXRpY1Jlc291cmNlc0VxdWFsLCBsb2FkU2NyaXB0LCBsb2FkU2NyaXB0Tm9kZSwgbG9nZ2VyLCBNb2R1bGVGZWRlcmF0aW9uUGx1Z2luIGFzIG1vZHVsZUZlZGVyYXRpb25QbHVnaW4sIG5vcm1hbGl6ZU9wdGlvbnMsIHBhcnNlRW50cnksIHNhZmVXcmFwcGVyLCBTaGFyZVBsdWdpbiBhcyBzaGFyZVBsdWdpbiwgc2ltcGxlSm9pblJlbW90ZUVudHJ5LCB3YXJuIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@module-federation/sdk/dist/index.esm.js\n");

/***/ }),

/***/ "../../node_modules/@module-federation/webpack-bundler-runtime/dist/constant.cjs.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@module-federation/webpack-bundler-runtime/dist/constant.cjs.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar ENCODE_NAME_PREFIX = 'ENCODE_NAME_PREFIX';\nvar FEDERATION_SUPPORTED_TYPES = [\n    'script'\n];\n\nexports.ENCODE_NAME_PREFIX = ENCODE_NAME_PREFIX;\nexports.FEDERATION_SUPPORTED_TYPES = FEDERATION_SUPPORTED_TYPES;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi93ZWJwYWNrLWJ1bmRsZXItcnVudGltZS9kaXN0L2NvbnN0YW50LmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2R1bGVBcHBCLy4uLy4uL25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vd2VicGFjay1idW5kbGVyLXJ1bnRpbWUvZGlzdC9jb25zdGFudC5janMuanM/NGQ1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBFTkNPREVfTkFNRV9QUkVGSVggPSAnRU5DT0RFX05BTUVfUFJFRklYJztcbnZhciBGRURFUkFUSU9OX1NVUFBPUlRFRF9UWVBFUyA9IFtcbiAgICAnc2NyaXB0J1xuXTtcblxuZXhwb3J0cy5FTkNPREVfTkFNRV9QUkVGSVggPSBFTkNPREVfTkFNRV9QUkVGSVg7XG5leHBvcnRzLkZFREVSQVRJT05fU1VQUE9SVEVEX1RZUEVTID0gRkVERVJBVElPTl9TVVBQT1JURURfVFlQRVM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@module-federation/webpack-bundler-runtime/dist/constant.cjs.js\n");

/***/ }),

/***/ "../../node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar runtime = __webpack_require__(/*! @module-federation/runtime */ \"../../node_modules/@module-federation/runtime/dist/index.esm.js\");\nvar sdk = __webpack_require__(/*! @module-federation/sdk */ \"../../node_modules/@module-federation/sdk/dist/index.cjs.js\");\nvar constant = __webpack_require__(/*! ./constant.cjs.js */ \"../../node_modules/@module-federation/webpack-bundler-runtime/dist/constant.cjs.js\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar runtime__namespace = /*#__PURE__*/_interopNamespace(runtime);\n\nfunction attachShareScopeMap(webpackRequire) {\n    if (!webpackRequire.S || webpackRequire.federation.hasAttachShareScopeMap || !webpackRequire.federation.instance || !webpackRequire.federation.instance.shareScopeMap) {\n        return;\n    }\n    webpackRequire.S = webpackRequire.federation.instance.shareScopeMap;\n    webpackRequire.federation.hasAttachShareScopeMap = true;\n}\n\nfunction remotes(options) {\n    var chunkId = options.chunkId, promises = options.promises, chunkMapping = options.chunkMapping, idToExternalAndNameMapping = options.idToExternalAndNameMapping, webpackRequire = options.webpackRequire, idToRemoteMap = options.idToRemoteMap;\n    attachShareScopeMap(webpackRequire);\n    if (webpackRequire.o(chunkMapping, chunkId)) {\n        chunkMapping[chunkId].forEach(function(id) {\n            var getScope = webpackRequire.R;\n            if (!getScope) {\n                getScope = [];\n            }\n            var data = idToExternalAndNameMapping[id];\n            var remoteInfos = idToRemoteMap[id];\n            // @ts-ignore seems not work\n            if (getScope.indexOf(data) >= 0) {\n                return;\n            }\n            // @ts-ignore seems not work\n            getScope.push(data);\n            if (data.p) {\n                return promises.push(data.p);\n            }\n            var onError = function(error) {\n                if (!error) {\n                    error = new Error('Container missing');\n                }\n                if (typeof error.message === 'string') {\n                    error.message += '\\nwhile loading \"'.concat(data[1], '\" from ').concat(data[2]);\n                }\n                webpackRequire.m[id] = function() {\n                    throw error;\n                };\n                data.p = 0;\n            };\n            var handleFunction = function(fn, arg1, arg2, d, next, first) {\n                try {\n                    var promise = fn(arg1, arg2);\n                    if (promise && promise.then) {\n                        var p = promise.then(function(result) {\n                            return next(result, d);\n                        }, onError);\n                        if (first) {\n                            promises.push(data.p = p);\n                        } else {\n                            return p;\n                        }\n                    } else {\n                        return next(promise, d, first);\n                    }\n                } catch (error) {\n                    onError(error);\n                }\n            };\n            var onExternal = function(external, _, first) {\n                return external ? handleFunction(webpackRequire.I, data[0], 0, external, onInitialized, first) : onError();\n            };\n            // eslint-disable-next-line no-var\n            var onInitialized = function(_, external, first) {\n                return handleFunction(external.get, data[1], getScope, 0, onFactory, first);\n            };\n            // eslint-disable-next-line no-var\n            var onFactory = function(factory) {\n                data.p = 1;\n                webpackRequire.m[id] = function(module) {\n                    module.exports = factory();\n                };\n            };\n            var onRemoteLoaded = function() {\n                try {\n                    var remoteName = sdk.decodeName(remoteInfos[0].name, constant.ENCODE_NAME_PREFIX);\n                    var remoteModuleName = remoteName + data[1].slice(1);\n                    return webpackRequire.federation.instance.loadRemote(remoteModuleName, {\n                        loadFactory: false,\n                        from: 'build'\n                    });\n                } catch (error) {\n                    onError(error);\n                }\n            };\n            var useRuntimeLoad = remoteInfos.length === 1 && [\n                'script'\n            ].includes(remoteInfos[0].externalType) && remoteInfos[0].name;\n            if (useRuntimeLoad) {\n                handleFunction(onRemoteLoaded, data[2], 0, 0, onFactory, 1);\n            } else {\n                handleFunction(webpackRequire, data[2], 0, 0, onExternal, 1);\n            }\n        });\n    }\n}\n\nfunction consumes(options) {\n    var chunkId = options.chunkId, promises = options.promises, chunkMapping = options.chunkMapping, installedModules = options.installedModules, moduleToHandlerMapping = options.moduleToHandlerMapping, webpackRequire = options.webpackRequire;\n    attachShareScopeMap(webpackRequire);\n    if (webpackRequire.o(chunkMapping, chunkId)) {\n        chunkMapping[chunkId].forEach(function(id) {\n            if (webpackRequire.o(installedModules, id)) {\n                return promises.push(installedModules[id]);\n            }\n            var onFactory = function(factory) {\n                installedModules[id] = 0;\n                webpackRequire.m[id] = function(module) {\n                    delete webpackRequire.c[id];\n                    module.exports = factory();\n                };\n            };\n            var onError = function(error) {\n                delete installedModules[id];\n                webpackRequire.m[id] = function(module) {\n                    delete webpackRequire.c[id];\n                    throw error;\n                };\n            };\n            try {\n                var federationInstance = webpackRequire.federation.instance;\n                if (!federationInstance) {\n                    throw new Error('Federation instance not found!');\n                }\n                var _moduleToHandlerMapping_id = moduleToHandlerMapping[id], shareKey = _moduleToHandlerMapping_id.shareKey, getter = _moduleToHandlerMapping_id.getter, shareInfo = _moduleToHandlerMapping_id.shareInfo;\n                var promise = federationInstance.loadShare(shareKey, {\n                    customShareInfo: shareInfo\n                }).then(function(factory) {\n                    if (factory === false) {\n                        return getter();\n                    }\n                    return factory;\n                });\n                if (promise.then) {\n                    promises.push(installedModules[id] = promise.then(onFactory).catch(onError));\n                } else {\n                    // @ts-ignore maintain previous logic\n                    onFactory(promise);\n                }\n            } catch (e) {\n                onError(e);\n            }\n        });\n    }\n}\n\nfunction initializeSharing(param) {\n    var shareScopeName = param.shareScopeName, webpackRequire = param.webpackRequire, initPromises = param.initPromises, initTokens = param.initTokens, initScope = param.initScope;\n    if (!initScope) initScope = [];\n    // handling circular init calls\n    var initToken = initTokens[shareScopeName];\n    if (!initToken) initToken = initTokens[shareScopeName] = {};\n    if (initScope.indexOf(initToken) >= 0) return;\n    initScope.push(initToken);\n    var promise = initPromises[shareScopeName];\n    if (promise) return promise;\n    var warn = function(msg) {\n        return typeof console !== 'undefined' && console.warn && console.warn(msg);\n    };\n    var initExternal = function(id) {\n        var handleError = function(err) {\n            return warn('Initialization of sharing external failed: ' + err);\n        };\n        try {\n            var module = webpackRequire(id);\n            if (!module) return;\n            var initFn = function(module) {\n                return module && module.init && // @ts-ignore compat legacy mf shared behavior\n                module.init(webpackRequire.S[shareScopeName], initScope);\n            };\n            if (module.then) return promises.push(module.then(initFn, handleError));\n            var initResult = initFn(module);\n            // @ts-ignore\n            if (initResult && typeof initResult !== 'boolean' && initResult.then) // @ts-ignore\n            return promises.push(initResult['catch'](handleError));\n        } catch (err) {\n            handleError(err);\n        }\n    };\n    var promises = webpackRequire.federation.instance.initializeSharing(shareScopeName);\n    attachShareScopeMap(webpackRequire);\n    var bundlerRuntimeRemotesOptions = webpackRequire.federation.bundlerRuntimeOptions.remotes;\n    if (bundlerRuntimeRemotesOptions) {\n        Object.keys(bundlerRuntimeRemotesOptions.idToRemoteMap).forEach(function(moduleId) {\n            var info = bundlerRuntimeRemotesOptions.idToRemoteMap[moduleId];\n            var externalModuleId = bundlerRuntimeRemotesOptions.idToExternalAndNameMapping[moduleId][2];\n            if (info.length > 1) {\n                initExternal(externalModuleId);\n            } else if (info.length === 1) {\n                var remoteInfo = info[0];\n                if (!constant.FEDERATION_SUPPORTED_TYPES.includes(remoteInfo.externalType)) {\n                    initExternal(externalModuleId);\n                }\n            }\n        });\n    }\n    if (!promises.length) {\n        return initPromises[shareScopeName] = true;\n    }\n    return initPromises[shareScopeName] = Promise.all(promises).then(function() {\n        return initPromises[shareScopeName] = true;\n    });\n}\n\nfunction handleInitialConsumes(options) {\n    var moduleId = options.moduleId, moduleToHandlerMapping = options.moduleToHandlerMapping, webpackRequire = options.webpackRequire;\n    var federationInstance = webpackRequire.federation.instance;\n    if (!federationInstance) {\n        throw new Error('Federation instance not found!');\n    }\n    var _moduleToHandlerMapping_moduleId = moduleToHandlerMapping[moduleId], shareKey = _moduleToHandlerMapping_moduleId.shareKey, shareInfo = _moduleToHandlerMapping_moduleId.shareInfo;\n    try {\n        return federationInstance.loadShareSync(shareKey, {\n            customShareInfo: shareInfo\n        });\n    } catch (err) {\n        console.error('loadShareSync failed! The function should not be called unless you set \"eager:true\". If you do not set it, and encounter this issue, you can check whether an async boundary is implemented.');\n        console.error('The original error message is as follows: ');\n        throw err;\n    }\n}\nfunction installInitialConsumes(options) {\n    var moduleToHandlerMapping = options.moduleToHandlerMapping, webpackRequire = options.webpackRequire, installedModules = options.installedModules, initialConsumes = options.initialConsumes;\n    initialConsumes.forEach(function(id) {\n        webpackRequire.m[id] = function(module) {\n            // Handle scenario when module is used synchronously\n            installedModules[id] = 0;\n            delete webpackRequire.c[id];\n            var factory = handleInitialConsumes({\n                moduleId: id,\n                moduleToHandlerMapping: moduleToHandlerMapping,\n                webpackRequire: webpackRequire\n            });\n            if (typeof factory !== 'function') {\n                throw new Error(\"Shared module is not available for eager consumption: \".concat(id));\n            }\n            module.exports = factory();\n        };\n    });\n}\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _object_spread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction initContainerEntry(options) {\n    var webpackRequire = options.webpackRequire, shareScope = options.shareScope, initScope = options.initScope, shareScopeKey = options.shareScopeKey, remoteEntryInitOptions = options.remoteEntryInitOptions;\n    if (!webpackRequire.S) return;\n    if (!webpackRequire.federation || !webpackRequire.federation.instance || !webpackRequire.federation.initOptions) return;\n    var federationInstance = webpackRequire.federation.instance;\n    var name = shareScopeKey || 'default';\n    federationInstance.initOptions(_object_spread({\n        name: webpackRequire.federation.initOptions.name,\n        remotes: []\n    }, remoteEntryInitOptions));\n    federationInstance.initShareScopeMap(name, shareScope);\n    if (webpackRequire.federation.attachShareScopeMap) {\n        webpackRequire.federation.attachShareScopeMap(webpackRequire);\n    }\n    // @ts-ignore\n    return webpackRequire.I(name, initScope);\n}\n\nvar federation = {\n    runtime: runtime__namespace,\n    instance: undefined,\n    initOptions: undefined,\n    bundlerRuntime: {\n        remotes: remotes,\n        consumes: consumes,\n        I: initializeSharing,\n        S: {},\n        installInitialConsumes: installInitialConsumes,\n        initContainerEntry: initContainerEntry\n    },\n    attachShareScopeMap: attachShareScopeMap,\n    bundlerRuntimeOptions: {}\n};\n\nmodule.exports = federation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi93ZWJwYWNrLWJ1bmRsZXItcnVudGltZS9kaXN0L2luZGV4LmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsbUdBQTRCO0FBQ2xELFVBQVUsbUJBQU8sQ0FBQywyRkFBd0I7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLDZHQUFtQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2R1bGVBcHBCLy4uLy4uL25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vd2VicGFjay1idW5kbGVyLXJ1bnRpbWUvZGlzdC9pbmRleC5janMuanM/OGUyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBydW50aW1lID0gcmVxdWlyZSgnQG1vZHVsZS1mZWRlcmF0aW9uL3J1bnRpbWUnKTtcbnZhciBzZGsgPSByZXF1aXJlKCdAbW9kdWxlLWZlZGVyYXRpb24vc2RrJyk7XG52YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuL2NvbnN0YW50LmNqcy5qcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgcnVudGltZV9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKHJ1bnRpbWUpO1xuXG5mdW5jdGlvbiBhdHRhY2hTaGFyZVNjb3BlTWFwKHdlYnBhY2tSZXF1aXJlKSB7XG4gICAgaWYgKCF3ZWJwYWNrUmVxdWlyZS5TIHx8IHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaGFzQXR0YWNoU2hhcmVTY29wZU1hcCB8fCAhd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZSB8fCAhd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZS5zaGFyZVNjb3BlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2VicGFja1JlcXVpcmUuUyA9IHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5zdGFuY2Uuc2hhcmVTY29wZU1hcDtcbiAgICB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmhhc0F0dGFjaFNoYXJlU2NvcGVNYXAgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiByZW1vdGVzKG9wdGlvbnMpIHtcbiAgICB2YXIgY2h1bmtJZCA9IG9wdGlvbnMuY2h1bmtJZCwgcHJvbWlzZXMgPSBvcHRpb25zLnByb21pc2VzLCBjaHVua01hcHBpbmcgPSBvcHRpb25zLmNodW5rTWFwcGluZywgaWRUb0V4dGVybmFsQW5kTmFtZU1hcHBpbmcgPSBvcHRpb25zLmlkVG9FeHRlcm5hbEFuZE5hbWVNYXBwaW5nLCB3ZWJwYWNrUmVxdWlyZSA9IG9wdGlvbnMud2VicGFja1JlcXVpcmUsIGlkVG9SZW1vdGVNYXAgPSBvcHRpb25zLmlkVG9SZW1vdGVNYXA7XG4gICAgYXR0YWNoU2hhcmVTY29wZU1hcCh3ZWJwYWNrUmVxdWlyZSk7XG4gICAgaWYgKHdlYnBhY2tSZXF1aXJlLm8oY2h1bmtNYXBwaW5nLCBjaHVua0lkKSkge1xuICAgICAgICBjaHVua01hcHBpbmdbY2h1bmtJZF0uZm9yRWFjaChmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgdmFyIGdldFNjb3BlID0gd2VicGFja1JlcXVpcmUuUjtcbiAgICAgICAgICAgIGlmICghZ2V0U2NvcGUpIHtcbiAgICAgICAgICAgICAgICBnZXRTY29wZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRhdGEgPSBpZFRvRXh0ZXJuYWxBbmROYW1lTWFwcGluZ1tpZF07XG4gICAgICAgICAgICB2YXIgcmVtb3RlSW5mb3MgPSBpZFRvUmVtb3RlTWFwW2lkXTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc2VlbXMgbm90IHdvcmtcbiAgICAgICAgICAgIGlmIChnZXRTY29wZS5pbmRleE9mKGRhdGEpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHNlZW1zIG5vdCB3b3JrXG4gICAgICAgICAgICBnZXRTY29wZS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYgKGRhdGEucCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlcy5wdXNoKGRhdGEucCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignQ29udGFpbmVyIG1pc3NpbmcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlICs9ICdcXG53aGlsZSBsb2FkaW5nIFwiJy5jb25jYXQoZGF0YVsxXSwgJ1wiIGZyb20gJykuY29uY2F0KGRhdGFbMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3ZWJwYWNrUmVxdWlyZS5tW2lkXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRhdGEucCA9IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGhhbmRsZUZ1bmN0aW9uID0gZnVuY3Rpb24oZm4sIGFyZzEsIGFyZzIsIGQsIG5leHQsIGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmbihhcmcxLCBhcmcyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2UgJiYgcHJvbWlzZS50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChyZXN1bHQsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRhdGEucCA9IHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KHByb21pc2UsIGQsIGZpcnN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb25FeHRlcm5hbCA9IGZ1bmN0aW9uKGV4dGVybmFsLCBfLCBmaXJzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHRlcm5hbCA/IGhhbmRsZUZ1bmN0aW9uKHdlYnBhY2tSZXF1aXJlLkksIGRhdGFbMF0sIDAsIGV4dGVybmFsLCBvbkluaXRpYWxpemVkLCBmaXJzdCkgOiBvbkVycm9yKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhclxuICAgICAgICAgICAgdmFyIG9uSW5pdGlhbGl6ZWQgPSBmdW5jdGlvbihfLCBleHRlcm5hbCwgZmlyc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRnVuY3Rpb24oZXh0ZXJuYWwuZ2V0LCBkYXRhWzFdLCBnZXRTY29wZSwgMCwgb25GYWN0b3J5LCBmaXJzdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhclxuICAgICAgICAgICAgdmFyIG9uRmFjdG9yeSA9IGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnAgPSAxO1xuICAgICAgICAgICAgICAgIHdlYnBhY2tSZXF1aXJlLm1baWRdID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9uUmVtb3RlTG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW90ZU5hbWUgPSBzZGsuZGVjb2RlTmFtZShyZW1vdGVJbmZvc1swXS5uYW1lLCBjb25zdGFudC5FTkNPREVfTkFNRV9QUkVGSVgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3RlTW9kdWxlTmFtZSA9IHJlbW90ZU5hbWUgKyBkYXRhWzFdLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZS5sb2FkUmVtb3RlKHJlbW90ZU1vZHVsZU5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRGYWN0b3J5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206ICdidWlsZCdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB1c2VSdW50aW1lTG9hZCA9IHJlbW90ZUluZm9zLmxlbmd0aCA9PT0gMSAmJiBbXG4gICAgICAgICAgICAgICAgJ3NjcmlwdCdcbiAgICAgICAgICAgIF0uaW5jbHVkZXMocmVtb3RlSW5mb3NbMF0uZXh0ZXJuYWxUeXBlKSAmJiByZW1vdGVJbmZvc1swXS5uYW1lO1xuICAgICAgICAgICAgaWYgKHVzZVJ1bnRpbWVMb2FkKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRnVuY3Rpb24ob25SZW1vdGVMb2FkZWQsIGRhdGFbMl0sIDAsIDAsIG9uRmFjdG9yeSwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZUZ1bmN0aW9uKHdlYnBhY2tSZXF1aXJlLCBkYXRhWzJdLCAwLCAwLCBvbkV4dGVybmFsLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb25zdW1lcyhvcHRpb25zKSB7XG4gICAgdmFyIGNodW5rSWQgPSBvcHRpb25zLmNodW5rSWQsIHByb21pc2VzID0gb3B0aW9ucy5wcm9taXNlcywgY2h1bmtNYXBwaW5nID0gb3B0aW9ucy5jaHVua01hcHBpbmcsIGluc3RhbGxlZE1vZHVsZXMgPSBvcHRpb25zLmluc3RhbGxlZE1vZHVsZXMsIG1vZHVsZVRvSGFuZGxlck1hcHBpbmcgPSBvcHRpb25zLm1vZHVsZVRvSGFuZGxlck1hcHBpbmcsIHdlYnBhY2tSZXF1aXJlID0gb3B0aW9ucy53ZWJwYWNrUmVxdWlyZTtcbiAgICBhdHRhY2hTaGFyZVNjb3BlTWFwKHdlYnBhY2tSZXF1aXJlKTtcbiAgICBpZiAod2VicGFja1JlcXVpcmUubyhjaHVua01hcHBpbmcsIGNodW5rSWQpKSB7XG4gICAgICAgIGNodW5rTWFwcGluZ1tjaHVua0lkXS5mb3JFYWNoKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICBpZiAod2VicGFja1JlcXVpcmUubyhpbnN0YWxsZWRNb2R1bGVzLCBpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZXMucHVzaChpbnN0YWxsZWRNb2R1bGVzW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb25GYWN0b3J5ID0gZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIGluc3RhbGxlZE1vZHVsZXNbaWRdID0gMDtcbiAgICAgICAgICAgICAgICB3ZWJwYWNrUmVxdWlyZS5tW2lkXSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2VicGFja1JlcXVpcmUuY1tpZF07XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnN0YWxsZWRNb2R1bGVzW2lkXTtcbiAgICAgICAgICAgICAgICB3ZWJwYWNrUmVxdWlyZS5tW2lkXSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2VicGFja1JlcXVpcmUuY1tpZF07XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZmVkZXJhdGlvbkluc3RhbmNlID0gd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBpZiAoIWZlZGVyYXRpb25JbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZlZGVyYXRpb24gaW5zdGFuY2Ugbm90IGZvdW5kIScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgX21vZHVsZVRvSGFuZGxlck1hcHBpbmdfaWQgPSBtb2R1bGVUb0hhbmRsZXJNYXBwaW5nW2lkXSwgc2hhcmVLZXkgPSBfbW9kdWxlVG9IYW5kbGVyTWFwcGluZ19pZC5zaGFyZUtleSwgZ2V0dGVyID0gX21vZHVsZVRvSGFuZGxlck1hcHBpbmdfaWQuZ2V0dGVyLCBzaGFyZUluZm8gPSBfbW9kdWxlVG9IYW5kbGVyTWFwcGluZ19pZC5zaGFyZUluZm87XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmZWRlcmF0aW9uSW5zdGFuY2UubG9hZFNoYXJlKHNoYXJlS2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVNoYXJlSW5mbzogc2hhcmVJbmZvXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWN0b3J5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldHRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChpbnN0YWxsZWRNb2R1bGVzW2lkXSA9IHByb21pc2UudGhlbihvbkZhY3RvcnkpLmNhdGNoKG9uRXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIG1haW50YWluIHByZXZpb3VzIGxvZ2ljXG4gICAgICAgICAgICAgICAgICAgIG9uRmFjdG9yeShwcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplU2hhcmluZyhwYXJhbSkge1xuICAgIHZhciBzaGFyZVNjb3BlTmFtZSA9IHBhcmFtLnNoYXJlU2NvcGVOYW1lLCB3ZWJwYWNrUmVxdWlyZSA9IHBhcmFtLndlYnBhY2tSZXF1aXJlLCBpbml0UHJvbWlzZXMgPSBwYXJhbS5pbml0UHJvbWlzZXMsIGluaXRUb2tlbnMgPSBwYXJhbS5pbml0VG9rZW5zLCBpbml0U2NvcGUgPSBwYXJhbS5pbml0U2NvcGU7XG4gICAgaWYgKCFpbml0U2NvcGUpIGluaXRTY29wZSA9IFtdO1xuICAgIC8vIGhhbmRsaW5nIGNpcmN1bGFyIGluaXQgY2FsbHNcbiAgICB2YXIgaW5pdFRva2VuID0gaW5pdFRva2Vuc1tzaGFyZVNjb3BlTmFtZV07XG4gICAgaWYgKCFpbml0VG9rZW4pIGluaXRUb2tlbiA9IGluaXRUb2tlbnNbc2hhcmVTY29wZU5hbWVdID0ge307XG4gICAgaWYgKGluaXRTY29wZS5pbmRleE9mKGluaXRUb2tlbikgPj0gMCkgcmV0dXJuO1xuICAgIGluaXRTY29wZS5wdXNoKGluaXRUb2tlbik7XG4gICAgdmFyIHByb21pc2UgPSBpbml0UHJvbWlzZXNbc2hhcmVTY29wZU5hbWVdO1xuICAgIGlmIChwcm9taXNlKSByZXR1cm4gcHJvbWlzZTtcbiAgICB2YXIgd2FybiA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLndhcm4obXNnKTtcbiAgICB9O1xuICAgIHZhciBpbml0RXh0ZXJuYWwgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgaGFuZGxlRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB3YXJuKCdJbml0aWFsaXphdGlvbiBvZiBzaGFyaW5nIGV4dGVybmFsIGZhaWxlZDogJyArIGVycik7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbW9kdWxlID0gd2VicGFja1JlcXVpcmUoaWQpO1xuICAgICAgICAgICAgaWYgKCFtb2R1bGUpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpbml0Rm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlICYmIG1vZHVsZS5pbml0ICYmIC8vIEB0cy1pZ25vcmUgY29tcGF0IGxlZ2FjeSBtZiBzaGFyZWQgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICBtb2R1bGUuaW5pdCh3ZWJwYWNrUmVxdWlyZS5TW3NoYXJlU2NvcGVOYW1lXSwgaW5pdFNjb3BlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobW9kdWxlLnRoZW4pIHJldHVybiBwcm9taXNlcy5wdXNoKG1vZHVsZS50aGVuKGluaXRGbiwgaGFuZGxlRXJyb3IpKTtcbiAgICAgICAgICAgIHZhciBpbml0UmVzdWx0ID0gaW5pdEZuKG1vZHVsZSk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoaW5pdFJlc3VsdCAmJiB0eXBlb2YgaW5pdFJlc3VsdCAhPT0gJ2Jvb2xlYW4nICYmIGluaXRSZXN1bHQudGhlbikgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzLnB1c2goaW5pdFJlc3VsdFsnY2F0Y2gnXShoYW5kbGVFcnJvcikpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwcm9taXNlcyA9IHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5zdGFuY2UuaW5pdGlhbGl6ZVNoYXJpbmcoc2hhcmVTY29wZU5hbWUpO1xuICAgIGF0dGFjaFNoYXJlU2NvcGVNYXAod2VicGFja1JlcXVpcmUpO1xuICAgIHZhciBidW5kbGVyUnVudGltZVJlbW90ZXNPcHRpb25zID0gd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5idW5kbGVyUnVudGltZU9wdGlvbnMucmVtb3RlcztcbiAgICBpZiAoYnVuZGxlclJ1bnRpbWVSZW1vdGVzT3B0aW9ucykge1xuICAgICAgICBPYmplY3Qua2V5cyhidW5kbGVyUnVudGltZVJlbW90ZXNPcHRpb25zLmlkVG9SZW1vdGVNYXApLmZvckVhY2goZnVuY3Rpb24obW9kdWxlSWQpIHtcbiAgICAgICAgICAgIHZhciBpbmZvID0gYnVuZGxlclJ1bnRpbWVSZW1vdGVzT3B0aW9ucy5pZFRvUmVtb3RlTWFwW21vZHVsZUlkXTtcbiAgICAgICAgICAgIHZhciBleHRlcm5hbE1vZHVsZUlkID0gYnVuZGxlclJ1bnRpbWVSZW1vdGVzT3B0aW9ucy5pZFRvRXh0ZXJuYWxBbmROYW1lTWFwcGluZ1ttb2R1bGVJZF1bMl07XG4gICAgICAgICAgICBpZiAoaW5mby5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaW5pdEV4dGVybmFsKGV4dGVybmFsTW9kdWxlSWQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmZvLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciByZW1vdGVJbmZvID0gaW5mb1swXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnN0YW50LkZFREVSQVRJT05fU1VQUE9SVEVEX1RZUEVTLmluY2x1ZGVzKHJlbW90ZUluZm8uZXh0ZXJuYWxUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbml0RXh0ZXJuYWwoZXh0ZXJuYWxNb2R1bGVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGluaXRQcm9taXNlc1tzaGFyZVNjb3BlTmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdFByb21pc2VzW3NoYXJlU2NvcGVOYW1lXSA9IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW5pdFByb21pc2VzW3NoYXJlU2NvcGVOYW1lXSA9IHRydWU7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUluaXRpYWxDb25zdW1lcyhvcHRpb25zKSB7XG4gICAgdmFyIG1vZHVsZUlkID0gb3B0aW9ucy5tb2R1bGVJZCwgbW9kdWxlVG9IYW5kbGVyTWFwcGluZyA9IG9wdGlvbnMubW9kdWxlVG9IYW5kbGVyTWFwcGluZywgd2VicGFja1JlcXVpcmUgPSBvcHRpb25zLndlYnBhY2tSZXF1aXJlO1xuICAgIHZhciBmZWRlcmF0aW9uSW5zdGFuY2UgPSB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmluc3RhbmNlO1xuICAgIGlmICghZmVkZXJhdGlvbkluc3RhbmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmVkZXJhdGlvbiBpbnN0YW5jZSBub3QgZm91bmQhJyk7XG4gICAgfVxuICAgIHZhciBfbW9kdWxlVG9IYW5kbGVyTWFwcGluZ19tb2R1bGVJZCA9IG1vZHVsZVRvSGFuZGxlck1hcHBpbmdbbW9kdWxlSWRdLCBzaGFyZUtleSA9IF9tb2R1bGVUb0hhbmRsZXJNYXBwaW5nX21vZHVsZUlkLnNoYXJlS2V5LCBzaGFyZUluZm8gPSBfbW9kdWxlVG9IYW5kbGVyTWFwcGluZ19tb2R1bGVJZC5zaGFyZUluZm87XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZlZGVyYXRpb25JbnN0YW5jZS5sb2FkU2hhcmVTeW5jKHNoYXJlS2V5LCB7XG4gICAgICAgICAgICBjdXN0b21TaGFyZUluZm86IHNoYXJlSW5mb1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignbG9hZFNoYXJlU3luYyBmYWlsZWQhIFRoZSBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCB1bmxlc3MgeW91IHNldCBcImVhZ2VyOnRydWVcIi4gSWYgeW91IGRvIG5vdCBzZXQgaXQsIGFuZCBlbmNvdW50ZXIgdGhpcyBpc3N1ZSwgeW91IGNhbiBjaGVjayB3aGV0aGVyIGFuIGFzeW5jIGJvdW5kYXJ5IGlzIGltcGxlbWVudGVkLicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBpcyBhcyBmb2xsb3dzOiAnKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluc3RhbGxJbml0aWFsQ29uc3VtZXMob3B0aW9ucykge1xuICAgIHZhciBtb2R1bGVUb0hhbmRsZXJNYXBwaW5nID0gb3B0aW9ucy5tb2R1bGVUb0hhbmRsZXJNYXBwaW5nLCB3ZWJwYWNrUmVxdWlyZSA9IG9wdGlvbnMud2VicGFja1JlcXVpcmUsIGluc3RhbGxlZE1vZHVsZXMgPSBvcHRpb25zLmluc3RhbGxlZE1vZHVsZXMsIGluaXRpYWxDb25zdW1lcyA9IG9wdGlvbnMuaW5pdGlhbENvbnN1bWVzO1xuICAgIGluaXRpYWxDb25zdW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHdlYnBhY2tSZXF1aXJlLm1baWRdID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgc2NlbmFyaW8gd2hlbiBtb2R1bGUgaXMgdXNlZCBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICBpbnN0YWxsZWRNb2R1bGVzW2lkXSA9IDA7XG4gICAgICAgICAgICBkZWxldGUgd2VicGFja1JlcXVpcmUuY1tpZF07XG4gICAgICAgICAgICB2YXIgZmFjdG9yeSA9IGhhbmRsZUluaXRpYWxDb25zdW1lcyh7XG4gICAgICAgICAgICAgICAgbW9kdWxlSWQ6IGlkLFxuICAgICAgICAgICAgICAgIG1vZHVsZVRvSGFuZGxlck1hcHBpbmc6IG1vZHVsZVRvSGFuZGxlck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgd2VicGFja1JlcXVpcmU6IHdlYnBhY2tSZXF1aXJlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNoYXJlZCBtb2R1bGUgaXMgbm90IGF2YWlsYWJsZSBmb3IgZWFnZXIgY29uc3VtcHRpb246IFwiLmNvbmNhdChpZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVfcHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9vYmplY3Rfc3ByZWFkKHRhcmdldCkge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGluaXRDb250YWluZXJFbnRyeShvcHRpb25zKSB7XG4gICAgdmFyIHdlYnBhY2tSZXF1aXJlID0gb3B0aW9ucy53ZWJwYWNrUmVxdWlyZSwgc2hhcmVTY29wZSA9IG9wdGlvbnMuc2hhcmVTY29wZSwgaW5pdFNjb3BlID0gb3B0aW9ucy5pbml0U2NvcGUsIHNoYXJlU2NvcGVLZXkgPSBvcHRpb25zLnNoYXJlU2NvcGVLZXksIHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMgPSBvcHRpb25zLnJlbW90ZUVudHJ5SW5pdE9wdGlvbnM7XG4gICAgaWYgKCF3ZWJwYWNrUmVxdWlyZS5TKSByZXR1cm47XG4gICAgaWYgKCF3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uIHx8ICF3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmluc3RhbmNlIHx8ICF3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmluaXRPcHRpb25zKSByZXR1cm47XG4gICAgdmFyIGZlZGVyYXRpb25JbnN0YW5jZSA9IHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5zdGFuY2U7XG4gICAgdmFyIG5hbWUgPSBzaGFyZVNjb3BlS2V5IHx8ICdkZWZhdWx0JztcbiAgICBmZWRlcmF0aW9uSW5zdGFuY2UuaW5pdE9wdGlvbnMoX29iamVjdF9zcHJlYWQoe1xuICAgICAgICBuYW1lOiB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmluaXRPcHRpb25zLm5hbWUsXG4gICAgICAgIHJlbW90ZXM6IFtdXG4gICAgfSwgcmVtb3RlRW50cnlJbml0T3B0aW9ucykpO1xuICAgIGZlZGVyYXRpb25JbnN0YW5jZS5pbml0U2hhcmVTY29wZU1hcChuYW1lLCBzaGFyZVNjb3BlKTtcbiAgICBpZiAod2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5hdHRhY2hTaGFyZVNjb3BlTWFwKSB7XG4gICAgICAgIHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uYXR0YWNoU2hhcmVTY29wZU1hcCh3ZWJwYWNrUmVxdWlyZSk7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gd2VicGFja1JlcXVpcmUuSShuYW1lLCBpbml0U2NvcGUpO1xufVxuXG52YXIgZmVkZXJhdGlvbiA9IHtcbiAgICBydW50aW1lOiBydW50aW1lX19uYW1lc3BhY2UsXG4gICAgaW5zdGFuY2U6IHVuZGVmaW5lZCxcbiAgICBpbml0T3B0aW9uczogdW5kZWZpbmVkLFxuICAgIGJ1bmRsZXJSdW50aW1lOiB7XG4gICAgICAgIHJlbW90ZXM6IHJlbW90ZXMsXG4gICAgICAgIGNvbnN1bWVzOiBjb25zdW1lcyxcbiAgICAgICAgSTogaW5pdGlhbGl6ZVNoYXJpbmcsXG4gICAgICAgIFM6IHt9LFxuICAgICAgICBpbnN0YWxsSW5pdGlhbENvbnN1bWVzOiBpbnN0YWxsSW5pdGlhbENvbnN1bWVzLFxuICAgICAgICBpbml0Q29udGFpbmVyRW50cnk6IGluaXRDb250YWluZXJFbnRyeVxuICAgIH0sXG4gICAgYXR0YWNoU2hhcmVTY29wZU1hcDogYXR0YWNoU2hhcmVTY29wZU1hcCxcbiAgICBidW5kbGVyUnVudGltZU9wdGlvbnM6IHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZlZGVyYXRpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js\n");

/***/ }),

/***/ "./src/pages/_app.tsx":
/*!****************************!*\
  !*** ./src/pages/_app.tsx ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"webpack/sharing/consume/default/react/jsx-dev-runtime/react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction App() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            backgroundColor: \"green\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                children: \"Module App B\"\n            }, void 0, false, {\n                fileName: \"/Users/sihyungpark/Documents/GitHub/module-federation-example/apps/module-app-b/src/pages/_app.tsx\",\n                lineNumber: 6,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        children: \"Module App B Loaded\"\n                    }, void 0, false, {\n                        fileName: \"/Users/sihyungpark/Documents/GitHub/module-federation-example/apps/module-app-b/src/pages/_app.tsx\",\n                        lineNumber: 8,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {\n                        fallback: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: \"loading Micro App B\"\n                        }, void 0, false, {\n                            fileName: \"/Users/sihyungpark/Documents/GitHub/module-federation-example/apps/module-app-b/src/pages/_app.tsx\",\n                            lineNumber: 9,\n                            columnNumber: 29\n                        }, void 0)\n                    }, void 0, false, {\n                        fileName: \"/Users/sihyungpark/Documents/GitHub/module-federation-example/apps/module-app-b/src/pages/_app.tsx\",\n                        lineNumber: 9,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/sihyungpark/Documents/GitHub/module-federation-example/apps/module-app-b/src/pages/_app.tsx\",\n                lineNumber: 7,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/sihyungpark/Documents/GitHub/module-federation-example/apps/module-app-b/src/pages/_app.tsx\",\n        lineNumber: 5,\n        columnNumber: 5\n    }, this);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvX2FwcC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXVDO0FBRXZDLFNBQVNDO0lBQ1AscUJBQ0UsOERBQUNDO1FBQUlDLE9BQU87WUFBRUMsaUJBQWlCO1FBQVE7OzBCQUNyQyw4REFBQ0M7MEJBQUc7Ozs7OzswQkFDSiw4REFBQ0g7O2tDQUNDLDhEQUFDSTtrQ0FBRzs7Ozs7O2tDQUNKLDhEQUFDTiwyQ0FBUUE7d0JBQUNPLHdCQUFVLDhEQUFDTDtzQ0FBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJakM7QUFFQSxpRUFBZUQsR0FBR0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL21vZHVsZUFwcEIvLi9zcmMvcGFnZXMvX2FwcC50c3g/ZjlkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdXNwZW5zZSwgbGF6eSB9IGZyb20gXCJyZWFjdFwiO1xuXG5mdW5jdGlvbiBBcHAoKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6IFwiZ3JlZW5cIiB9fT5cbiAgICAgIDxoMT5Nb2R1bGUgQXBwIEI8L2gxPlxuICAgICAgPGRpdj5cbiAgICAgICAgPGgyPk1vZHVsZSBBcHAgQiBMb2FkZWQ8L2gyPlxuICAgICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9ezxkaXY+bG9hZGluZyBNaWNybyBBcHAgQjwvZGl2Pn0+PC9TdXNwZW5zZT5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBBcHA7XG4iXSwibmFtZXMiOlsiU3VzcGVuc2UiLCJBcHAiLCJkaXYiLCJzdHlsZSIsImJhY2tncm91bmRDb2xvciIsImgxIiwiaDIiLCJmYWxsYmFjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/_app.tsx\n");

/***/ }),

/***/ "next/dist/compiled/next-server/pages.runtime.dev.js":
/*!**********************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages.runtime.dev.js" ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages.runtime.dev.js");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

module.exports = require("react");

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("react-dom");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "../../node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction default_1() {\n    return {\n        name: 'next-internal-plugin',\n        errorLoadRemote({ id, error, from, origin }) {\n            console.error(id, 'offline');\n            const pg = function () {\n                console.error(id, 'offline', error);\n                return null;\n            };\n            pg.getInitialProps = function (ctx) {\n                return {};\n            };\n            let mod;\n            if (from === 'build') {\n                mod = () => ({\n                    __esModule: true,\n                    default: pg,\n                    getServerSideProps: () => ({ props: {} }),\n                });\n            }\n            else {\n                mod = {\n                    default: pg,\n                    getServerSideProps: () => ({ props: {} }),\n                };\n            }\n            return mod;\n        },\n        beforeInit(args) {\n            const { userOptions, shareInfo } = args;\n            const { shared } = userOptions;\n            if (!globalThis.usedChunks)\n                globalThis.usedChunks = new Set();\n            if (shared) {\n                Object.keys(shared || {}).forEach((sharedKey) => {\n                    const rawShared = shared[sharedKey];\n                    const arrayShared = Array.isArray(rawShared)\n                        ? rawShared\n                        : [rawShared];\n                    arrayShared.forEach((s) => {\n                        if (!s.strategy) {\n                            s.strategy = 'loaded-first';\n                        }\n                    });\n                });\n            }\n            if (typeof __webpack_require__.j === 'string' &&\n                !__webpack_require__.j.startsWith('webpack')) {\n                return args;\n            }\n            // if (__webpack_runtime_id__ && !__webpack_runtime_id__.startsWith('webpack')) return args;\n            const { moduleCache, name } = args.origin;\n            const gs = new Function('return globalThis')();\n            const attachedRemote = gs[name];\n            if (attachedRemote) {\n                moduleCache.set(name, attachedRemote);\n            }\n            return args;\n        },\n        init(args) {\n            return args;\n        },\n        beforeRequest: (args) => {\n            const { options, id } = args;\n            const remoteName = id.split('/').shift();\n            const remote = options.remotes.find((remote) => remote.name === remoteName);\n            if (!remote)\n                return args;\n            //@ts-ignore\n            if (remote?.entry?.includes('?t=')) {\n                return args;\n            }\n            //@ts-ignore\n            remote.entry = `${remote?.entry}?t=${Date.now()}`;\n            return args;\n        },\n        createScript({ url }) {\n            return;\n        },\n        afterResolve(args) {\n            return args;\n        },\n        onLoad(args) {\n            const { exposeModuleFactory, exposeModule, id } = args;\n            const moduleOrFactory = exposeModuleFactory || exposeModule;\n            if (!moduleOrFactory)\n                return args; // Ensure moduleOrFactory is defined\n            if (typeof window === 'undefined') {\n                let exposedModuleExports;\n                try {\n                    exposedModuleExports = moduleOrFactory();\n                }\n                catch (e) {\n                    exposedModuleExports = moduleOrFactory;\n                }\n                const handler = {\n                    get(target, prop, receiver) {\n                        // Check if accessing a static property of the function itself\n                        if (target === exposedModuleExports &&\n                            typeof exposedModuleExports[prop] === 'function') {\n                            return function (...args) {\n                                globalThis.usedChunks.add(id);\n                                return exposedModuleExports[prop].apply(this, args);\n                            };\n                        }\n                        const originalMethod = target[prop];\n                        if (typeof originalMethod === 'function') {\n                            const proxiedFunction = function (...args) {\n                                globalThis.usedChunks.add(id);\n                                return originalMethod.apply(this, args);\n                            };\n                            // Copy all enumerable properties from the original method to the proxied function\n                            Object.keys(originalMethod).forEach((prop) => {\n                                Object.defineProperty(proxiedFunction, prop, {\n                                    value: originalMethod[prop],\n                                    writable: true,\n                                    enumerable: true,\n                                    configurable: true,\n                                });\n                            });\n                            return proxiedFunction;\n                        }\n                        return Reflect.get(target, prop, receiver);\n                    },\n                };\n                if (typeof exposedModuleExports === 'function') {\n                    // If the module export is a function, we create a proxy that can handle both its\n                    // call (as a function) and access to its properties (including static methods).\n                    exposedModuleExports = new Proxy(exposedModuleExports, handler);\n                    // Proxy static properties specifically\n                    const staticProps = Object.getOwnPropertyNames(exposedModuleExports);\n                    staticProps.forEach((prop) => {\n                        if (typeof exposedModuleExports[prop] === 'function') {\n                            exposedModuleExports[prop] = new Proxy(exposedModuleExports[prop], handler);\n                        }\n                    });\n                    return () => exposedModuleExports;\n                }\n                else {\n                    // For objects, just wrap the exported object itself\n                    exposedModuleExports = new Proxy(exposedModuleExports, handler);\n                }\n                return exposedModuleExports;\n            }\n            return args;\n        },\n        resolveShare(args) {\n            if (args.pkgName !== 'react' &&\n                args.pkgName !== 'react-dom' &&\n                !args.pkgName.startsWith('next/')) {\n                return args;\n            }\n            const { shareScopeMap, scope, pkgName, version, GlobalFederation } = args;\n            const host = GlobalFederation['__INSTANCES__'][0];\n            if (!host) {\n                return args;\n            }\n            args.resolver = function () {\n                shareScopeMap[scope][pkgName][version] =\n                    host.options.shared[pkgName][0]; // replace local share scope manually with desired module\n                return shareScopeMap[scope][pkgName][version];\n            };\n            return args;\n        },\n        async beforeLoadShare(args) {\n            return args;\n        },\n    };\n}\nexports[\"default\"] = default_1;\n//# sourceMappingURL=runtimePlugin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi9uZXh0anMtbWYvZGlzdC9zcmMvcGx1Z2lucy9jb250YWluZXIvcnVudGltZVBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSx1QkFBdUIscUJBQXNCO0FBQzdDLGlCQUFpQixxQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjLEtBQUssV0FBVztBQUM1RDtBQUNBLFNBQVM7QUFDVCx1QkFBdUIsS0FBSztBQUM1QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLHdDQUF3QztBQUM1RDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUEyRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2R1bGVBcHBCLy4uLy4uL25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vbmV4dGpzLW1mL2Rpc3Qvc3JjL3BsdWdpbnMvY29udGFpbmVyL3J1bnRpbWVQbHVnaW4uanM/YzBmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGRlZmF1bHRfMSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnbmV4dC1pbnRlcm5hbC1wbHVnaW4nLFxuICAgICAgICBlcnJvckxvYWRSZW1vdGUoeyBpZCwgZXJyb3IsIGZyb20sIG9yaWdpbiB9KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGlkLCAnb2ZmbGluZScpO1xuICAgICAgICAgICAgY29uc3QgcGcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihpZCwgJ29mZmxpbmUnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGcuZ2V0SW5pdGlhbFByb3BzID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgbW9kO1xuICAgICAgICAgICAgaWYgKGZyb20gPT09ICdidWlsZCcpIHtcbiAgICAgICAgICAgICAgICBtb2QgPSAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBfX2VzTW9kdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBwZyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0U2VydmVyU2lkZVByb3BzOiAoKSA9PiAoeyBwcm9wczoge30gfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHBnLFxuICAgICAgICAgICAgICAgICAgICBnZXRTZXJ2ZXJTaWRlUHJvcHM6ICgpID0+ICh7IHByb3BzOiB7fSB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vZDtcbiAgICAgICAgfSxcbiAgICAgICAgYmVmb3JlSW5pdChhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVzZXJPcHRpb25zLCBzaGFyZUluZm8gfSA9IGFyZ3M7XG4gICAgICAgICAgICBjb25zdCB7IHNoYXJlZCB9ID0gdXNlck9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoIWdsb2JhbFRoaXMudXNlZENodW5rcylcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLnVzZWRDaHVua3MgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBpZiAoc2hhcmVkKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc2hhcmVkIHx8IHt9KS5mb3JFYWNoKChzaGFyZWRLZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3U2hhcmVkID0gc2hhcmVkW3NoYXJlZEtleV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5U2hhcmVkID0gQXJyYXkuaXNBcnJheShyYXdTaGFyZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJhd1NoYXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbcmF3U2hhcmVkXTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlTaGFyZWQuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzLnN0cmF0ZWd5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdHJhdGVneSA9ICdsb2FkZWQtZmlyc3QnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgX193ZWJwYWNrX3J1bnRpbWVfaWRfXyA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAhX193ZWJwYWNrX3J1bnRpbWVfaWRfXy5zdGFydHNXaXRoKCd3ZWJwYWNrJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIChfX3dlYnBhY2tfcnVudGltZV9pZF9fICYmICFfX3dlYnBhY2tfcnVudGltZV9pZF9fLnN0YXJ0c1dpdGgoJ3dlYnBhY2snKSkgcmV0dXJuIGFyZ3M7XG4gICAgICAgICAgICBjb25zdCB7IG1vZHVsZUNhY2hlLCBuYW1lIH0gPSBhcmdzLm9yaWdpbjtcbiAgICAgICAgICAgIGNvbnN0IGdzID0gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gZ2xvYmFsVGhpcycpKCk7XG4gICAgICAgICAgICBjb25zdCBhdHRhY2hlZFJlbW90ZSA9IGdzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGF0dGFjaGVkUmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlQ2FjaGUuc2V0KG5hbWUsIGF0dGFjaGVkUmVtb3RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9LFxuICAgICAgICBpbml0KGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9LFxuICAgICAgICBiZWZvcmVSZXF1ZXN0OiAoYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zLCBpZCB9ID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZU5hbWUgPSBpZC5zcGxpdCgnLycpLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCByZW1vdGUgPSBvcHRpb25zLnJlbW90ZXMuZmluZCgocmVtb3RlKSA9PiByZW1vdGUubmFtZSA9PT0gcmVtb3RlTmFtZSk7XG4gICAgICAgICAgICBpZiAoIXJlbW90ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKHJlbW90ZT8uZW50cnk/LmluY2x1ZGVzKCc/dD0nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICByZW1vdGUuZW50cnkgPSBgJHtyZW1vdGU/LmVudHJ5fT90PSR7RGF0ZS5ub3coKX1gO1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVNjcmlwdCh7IHVybCB9KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0sXG4gICAgICAgIGFmdGVyUmVzb2x2ZShhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfSxcbiAgICAgICAgb25Mb2FkKGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXhwb3NlTW9kdWxlRmFjdG9yeSwgZXhwb3NlTW9kdWxlLCBpZCB9ID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZU9yRmFjdG9yeSA9IGV4cG9zZU1vZHVsZUZhY3RvcnkgfHwgZXhwb3NlTW9kdWxlO1xuICAgICAgICAgICAgaWYgKCFtb2R1bGVPckZhY3RvcnkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3M7IC8vIEVuc3VyZSBtb2R1bGVPckZhY3RvcnkgaXMgZGVmaW5lZFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4cG9zZWRNb2R1bGVFeHBvcnRzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZWRNb2R1bGVFeHBvcnRzID0gbW9kdWxlT3JGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZWRNb2R1bGVFeHBvcnRzID0gbW9kdWxlT3JGYWN0b3J5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgICAgICAgICAgICAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYWNjZXNzaW5nIGEgc3RhdGljIHByb3BlcnR5IG9mIHRoZSBmdW5jdGlvbiBpdHNlbGZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IGV4cG9zZWRNb2R1bGVFeHBvcnRzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGV4cG9zZWRNb2R1bGVFeHBvcnRzW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMudXNlZENodW5rcy5hZGQoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3NlZE1vZHVsZUV4cG9ydHNbcHJvcF0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbE1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3hpZWRGdW5jdGlvbiA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMudXNlZENodW5rcy5hZGQoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgZnJvbSB0aGUgb3JpZ2luYWwgbWV0aG9kIHRvIHRoZSBwcm94aWVkIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob3JpZ2luYWxNZXRob2QpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3hpZWRGdW5jdGlvbiwgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9yaWdpbmFsTWV0aG9kW3Byb3BdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveGllZEZ1bmN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBvc2VkTW9kdWxlRXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbW9kdWxlIGV4cG9ydCBpcyBhIGZ1bmN0aW9uLCB3ZSBjcmVhdGUgYSBwcm94eSB0aGF0IGNhbiBoYW5kbGUgYm90aCBpdHNcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCAoYXMgYSBmdW5jdGlvbikgYW5kIGFjY2VzcyB0byBpdHMgcHJvcGVydGllcyAoaW5jbHVkaW5nIHN0YXRpYyBtZXRob2RzKS5cbiAgICAgICAgICAgICAgICAgICAgZXhwb3NlZE1vZHVsZUV4cG9ydHMgPSBuZXcgUHJveHkoZXhwb3NlZE1vZHVsZUV4cG9ydHMsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQcm94eSBzdGF0aWMgcHJvcGVydGllcyBzcGVjaWZpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGljUHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhleHBvc2VkTW9kdWxlRXhwb3J0cyk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1Byb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwb3NlZE1vZHVsZUV4cG9ydHNbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvc2VkTW9kdWxlRXhwb3J0c1twcm9wXSA9IG5ldyBQcm94eShleHBvc2VkTW9kdWxlRXhwb3J0c1twcm9wXSwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZXhwb3NlZE1vZHVsZUV4cG9ydHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3Igb2JqZWN0cywganVzdCB3cmFwIHRoZSBleHBvcnRlZCBvYmplY3QgaXRzZWxmXG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZWRNb2R1bGVFeHBvcnRzID0gbmV3IFByb3h5KGV4cG9zZWRNb2R1bGVFeHBvcnRzLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9zZWRNb2R1bGVFeHBvcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc29sdmVTaGFyZShhcmdzKSB7XG4gICAgICAgICAgICBpZiAoYXJncy5wa2dOYW1lICE9PSAncmVhY3QnICYmXG4gICAgICAgICAgICAgICAgYXJncy5wa2dOYW1lICE9PSAncmVhY3QtZG9tJyAmJlxuICAgICAgICAgICAgICAgICFhcmdzLnBrZ05hbWUuc3RhcnRzV2l0aCgnbmV4dC8nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBzaGFyZVNjb3BlTWFwLCBzY29wZSwgcGtnTmFtZSwgdmVyc2lvbiwgR2xvYmFsRmVkZXJhdGlvbiB9ID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IGhvc3QgPSBHbG9iYWxGZWRlcmF0aW9uWydfX0lOU1RBTkNFU19fJ11bMF07XG4gICAgICAgICAgICBpZiAoIWhvc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3MucmVzb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVTY29wZU1hcFtzY29wZV1bcGtnTmFtZV1bdmVyc2lvbl0gPVxuICAgICAgICAgICAgICAgICAgICBob3N0Lm9wdGlvbnMuc2hhcmVkW3BrZ05hbWVdWzBdOyAvLyByZXBsYWNlIGxvY2FsIHNoYXJlIHNjb3BlIG1hbnVhbGx5IHdpdGggZGVzaXJlZCBtb2R1bGVcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhcmVTY29wZU1hcFtzY29wZV1bcGtnTmFtZV1bdmVyc2lvbl07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGJlZm9yZUxvYWRTaGFyZShhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdF8xO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVudGltZVBsdWdpbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var promiseTrack = [];
__webpack_require__("./node_modules/.federation/entry.a08328371f641a576d7cc8435cf027b0.js");
if(__webpack_require__.f && __webpack_require__.f.consumes) { __webpack_require__.f.consumes("pages/_app", promiseTrack);}

var __webpack_exports__ = Promise.all(promiseTrack).then(function() {
	var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
	var __webpack_exports__ = (__webpack_exec__("./node_modules/.federation/entry.a08328371f641a576d7cc8435cf027b0.js"), __webpack_exec__("./src/pages/_app.tsx"));
	return __webpack_exports__
});module.exports = __webpack_exports__;

})();